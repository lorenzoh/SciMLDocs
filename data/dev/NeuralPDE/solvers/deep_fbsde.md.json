{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/NeuralPDE/y7uHG/docs/src/solvers/deep_fbsde.md","title":"Deep Forward-Backwards SDEs for Terminal Parabolic PDEs"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Deep Forward-Backwards SDEs for Terminal Parabolic PDEs"],"type":"node"},{"attributes":{},"tag":"p","children":["To solve high-dimensional PDEs, one should first describe the PDE in terms of the ",{"attributes":{},"tag":"code","children":["TerminalPDEProblem"],"type":"node"}," with constructor:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/NeuralPDE.TerminalPDEProblem"},"tag":"reference","children":["TerminalPDEProblem"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["g"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["f"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["μ_f"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["σ_f"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["X0"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["tspan"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["which describes the semilinear parabolic PDE of the form:"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{"src":"https://user-images.githubusercontent.com/1814174/63212617-48980480-c0d5-11e9-9fec-0776117464c7.PNG","alt":""},"tag":"img","children":["paraPDE"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["with terminating condition ",{"attributes":{},"tag":"code","children":["u(tspan[2],x) = g(x)"],"type":"node"},". These methods solve the PDE in reverse, satisfying the terminal equation and giving a point estimate at ",{"attributes":{},"tag":"code","children":["u(tspan[1],X0)"],"type":"node"},". The dimensionality of the PDE is determined by the choice of ",{"attributes":{},"tag":"code","children":["X0"],"type":"node"},", which is the initial stochastic state."],"type":"node"},{"attributes":{},"tag":"p","children":["To solve this PDE problem, there exist two algorithms:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["NNPDENS(u0,σᵀ∇u;opt=Flux.ADAM(0.1))"],"type":"node"},": Uses a neural stochastic differential equation, which is then solved by the methods available in DifferentialEquations.jl. The ",{"attributes":{},"tag":"code","children":["alg"],"type":"node"}," keyword is required for specifying the SDE solver algorithm that will be used on the internal SDE. All of the other keyword arguments are passed to the SDE solver."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["NNPDEHan(u0,σᵀ∇u;opt=Flux.ADAM(0.1))"],"type":"node"},": Uses the stochastic RNN algorithm ",{"attributes":{"href":"https://www.pnas.org/content/115/34/8505","title":""},"tag":"a","children":["from Han"],"type":"node"},". Only applicable when ",{"attributes":{},"tag":"code","children":["μ_f"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["σ_f"],"type":"node"}," result in a non-stiff SDE where low order non-adaptive time stepping is applicable."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Here, ",{"attributes":{},"tag":"code","children":["u0"],"type":"node"}," is a Flux.jl chain with a ",{"attributes":{},"tag":"code","children":["d"],"type":"node"},"-dimensional input and a 1-dimensional output. For ",{"attributes":{},"tag":"code","children":["NNPDEHan"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["σᵀ∇u"],"type":"node"}," is an array of ",{"attributes":{},"tag":"code","children":["M"],"type":"node"}," chains with a ",{"attributes":{},"tag":"code","children":["d"],"type":"node"},"-dimensional input and a ",{"attributes":{},"tag":"code","children":["d"],"type":"node"},"-dimensional output, where ",{"attributes":{},"tag":"code","children":["M"],"type":"node"}," is the total number of timesteps. For ",{"attributes":{},"tag":"code","children":["NNPDENS"],"type":"node"}," it is a ",{"attributes":{},"tag":"code","children":["d+1"],"type":"node"},"-dimensional input (where the final value is time) and a ",{"attributes":{},"tag":"code","children":["d"],"type":"node"},"-dimensional output. ",{"attributes":{},"tag":"code","children":["opt"],"type":"node"}," is a Flux.jl optimizer."],"type":"node"},{"attributes":{},"tag":"p","children":["Each of these methods has a special keyword argument ",{"attributes":{},"tag":"code","children":["pabstol"],"type":"node"},", which specifies an absolute tolerance on the PDE's solution, and will exit early if the loss reaches this value. Its default value is ",{"attributes":{},"tag":"code","children":["1f-6"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"}