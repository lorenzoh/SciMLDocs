{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/PolyChaos/THVqe/docs/src/chi_squared_k1.md","title":"Chi-squared Distribution (k=1)"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":"@setup mysetup"},"tag":"codeblock","children":["using PolyChaos\nk = 1\ndeg, Nrec = 2, 20\nopq = GaussOrthoPoly(deg; Nrec=Nrec, addQuadrature=true);\nshowbasis(opq; sym=\"ξ\") # works for `op` too!\nshowpoly(0:2:deg,opq)\nL = dim(opq)\nmu, sig = 0., 1.\nx = [ convert2affinePCE(mu, sig, opq); zeros(Float64,L-2) ]\nt2 = Tensor(2, opq);\nt3 = Tensor(3, opq)\ny = [ sum( x[i]*x[j]*t3.get([i-1,j-1,m-1])/t2.get([m-1,m-1])  for i=1:L, j=1:L ) for m=1:L ]\nmoms_analytic(k) = [k, sqrt(2k), sqrt(8/k)]\nfunction myskew(y)\n   e3 = sum( y[i]*y[j]*y[k]*t3.get([i-1,j-1,k-1]) for i=1:L,j=1:L,k=1:L )\n   μ = y[1]\n   σ = std(y,opq)\n   (e3-3*μ*σ^2-μ^3)/(σ^3)\nend\nprint(\"Expected value:\\t\\t$(moms_analytic(k)[1]) = $(mean(y,opq))\\n\")\nprint(\"\\t\\t\\terror = $(abs(mean(y,opq)-moms_analytic(k)[1]))\\n\")\nprint(\"Standard deviation:\\t$(moms_analytic(k)[2]) = $(std(y,opq))\\n\")\nprint(\"\\t\\t\\terror = $(moms_analytic(k)[2]-std(y,opq))\\n\")\nprint(\"Skewness:\\t\\t$(moms_analytic(k)[3]) = $(myskew(y))\\n\")\nprint(\"\\t\\t\\terror = $(moms_analytic(k)[3]-myskew(y))\\n\")\nusing Plots\nNsmpl = 10000\nysmpl = samplePCE(Nsmpl, y, opq)\nhistogram(ysmpl;normalize=true,xlabel=\"t\",ylabel=\"rho(t)\")\nimport SpecialFunctions: gamma\nρ(t) = 1/(sqrt(2)*gamma(0.5))*1/sqrt(t)*exp(-0.5*t)\nt = range(0.1; stop=maximum(ysmpl), length=100)\nplot!(t, ρ.(t), w=4)\n"],"type":"node"},{"attributes":{},"tag":"h1","children":["Chi-squared Distribution (",{"attributes":{},"tag":"math","children":["k=1"],"type":"node"},")"],"type":"node"},{"attributes":{},"tag":"h2","children":["Theory"],"type":"node"},{"attributes":{},"tag":"p","children":["Given a standard random variable ",{"attributes":{},"tag":"math","children":["X \\sim \\mathcal{N}(0,1)"],"type":"node"}," we would like to find the random variable ",{"attributes":{},"tag":"math","children":["Y = X^2"],"type":"node"},". The analytic solution is known: ",{"attributes":{},"tag":"math","children":["Y"],"type":"node"}," follows a chi-squared distribution with ",{"attributes":{},"tag":"math","children":["k=1"],"type":"node"}," degree of freedom."],"type":"node"},{"attributes":{},"tag":"p","children":["Using polynomial chaos expansion (PCE), the problem can be solved using Galerkin projection. Let ",{"attributes":{},"tag":"math","children":["\\{\\phi_k \\}_{k=0}^{n}"],"type":"node"}," be the monic orthogonal basis relative to the probability density of ",{"attributes":{},"tag":"math","children":["X"],"type":"node"},", namely"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["f_X(x) = \\frac{1}{\\sqrt{2 \\pi}} \\exp \\left( - \\frac{x^2}{2} \\right)."],"type":"node"},{"attributes":{},"tag":"p","children":["Then, the PCE of ",{"attributes":{},"tag":"math","children":["X"],"type":"node"}," is given by"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["X = \\sum_{k=0}^n x_k \\phi_k,"],"type":"node"},{"attributes":{},"tag":"p","children":["with"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["x_0 = 0, \\quad x_1 = 1, \\quad x_i = 0 \\quad \\forall i =2,\\dots,n."],"type":"node"},{"attributes":{},"tag":"p","children":["To find the PCE coefficients ",{"attributes":{},"tag":"math","children":["y_k"],"type":"node"}," for ",{"attributes":{},"tag":"math","children":["Y = \\sum_{k=}^n y_k \\phi_k"],"type":"node"},", we apply Galerkin projection, which leads to"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["y_m \\langle \\phi_m, \\phi_m \\rangle = \\sum_{i=0}^n \\sum_{j=0}^n x_i x_j \\langle \\phi_i \\phi_j, \\phi_m \\rangle \\quad \\forall m = 0, \\dots, n."],"type":"node"},{"attributes":{},"tag":"p","children":["Hence, knowing the scalars ",{"attributes":{},"tag":"math","children":["\\langle \\phi_m, \\phi_m \\rangle"],"type":"node"},", and ",{"attributes":{},"tag":"math","children":["\\langle \\phi_i \\phi_j, \\phi_m \\rangle"],"type":"node"},", the PCE coefficients ",{"attributes":{},"tag":"math","children":["y_k"],"type":"node"}," can be obtained immediately. From the PCE coefficients we can get the moments and compare them to the closed-form expressions."],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"strong","children":["Notice:"],"type":"node"}," A maximum degree of 2 suffices to get the ",{"attributes":{},"tag":"em","children":["exact"],"type":"node"}," solution with PCE. In other words, increasing the maximum degree to values greater than 2 introduces nothing but computational overhead (and numerical errors, possibly)."],"type":"node"},{"attributes":{},"tag":"h2","children":["Practice"],"type":"node"},{"attributes":{},"tag":"p","children":["First, we create a orthogonal basis relative to ",{"attributes":{},"tag":"math","children":["f_X(x)"],"type":"node"}," of degree at most ",{"attributes":{},"tag":"math","children":["d=2"],"type":"node"}," (",{"attributes":{},"tag":"code","children":["deg"],"type":"node"}," below)."],"type":"node"},{"attributes":{},"tag":"p","children":["Notice that we consider a total of ",{"attributes":{},"tag":"code","children":["Nrec"],"type":"node"}," recursion coefficients, and that we also add a quadrature rule by setting ",{"attributes":{},"tag":"code","children":["addQuadrature = true"],"type":"node"},"."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["using PolyChaos\nk = 1\ndeg, Nrec = 2, 20\nopq = GaussOrthoPoly(deg; Nrec=Nrec, addQuadrature=true);\n"],"type":"node"},{"attributes":{},"tag":"p","children":["What are the basis polynomials?"],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["showbasis(opq; sym=\"ξ\")\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Note that the command ",{"attributes":{},"tag":"code","children":["showbasis"],"type":"node"}," is based on the more general ",{"attributes":{},"tag":"code","children":["showpoly"],"type":"node"},":"],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["showpoly(0:2:deg,opq)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Next, we define the PCE for ",{"attributes":{},"tag":"math","children":["X"],"type":"node"},"."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["L = dim(opq)\nmu, sig = 0., 1.\nx = [ convert2affinePCE(mu, sig, opq); zeros(Float64,L-2) ]\n"],"type":"node"},{"attributes":{},"tag":"p","children":["With the orthogonal basis and the quadrature at hand, we can compute the tensors ",{"attributes":{},"tag":"code","children":["t2"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["t3"],"type":"node"}," that store the entries ",{"attributes":{},"tag":"math","children":["\\langle \\phi_m, \\phi_m \\rangle"],"type":"node"},", and ",{"attributes":{},"tag":"math","children":["\\langle \\phi_i \\phi_j, \\phi_m \\rangle"],"type":"node"},", respectively."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["t2 = Tensor(2, opq);\nt3 = Tensor(3, opq)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["With the tensors at hand, we can compute the Galerkin projection."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["y = [ sum( x[i]*x[j]*t3.get([i-1,j-1,m-1])/t2.get([m-1,m-1])  for i=1:L, j=1:L ) for m=1:L ]\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Let's compare the moments via PCE to the closed-form expressions."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["moms_analytic(k) = [k, sqrt(2k), sqrt(8/k)]\nfunction myskew(y)\n   e3 = sum( y[i]*y[j]*y[k]*t3.get([i-1,j-1,k-1]) for i=1:L, j=1:L, k=1:L )\n   μ = y[1]\n   σ = std(y,opq)\n   (e3-3*μ*σ^2-μ^3)/(σ^3)\nend\n\nprint(\"Expected value:\\t\\t$(moms_analytic(k)[1]) = $(mean(y,opq))\\n\")\nprint(\"\\t\\t\\terror = $(abs(mean(y,opq)-moms_analytic(k)[1]))\\n\")\nprint(\"Standard deviation:\\t$(moms_analytic(k)[2]) = $(std(y,opq))\\n\")\nprint(\"\\t\\t\\terror = $(moms_analytic(k)[2]-std(y,opq))\\n\")\nprint(\"Skewness:\\t\\t$(moms_analytic(k)[3]) = $(myskew(y))\\n\")\nprint(\"\\t\\t\\terror = $(moms_analytic(k)[3]-myskew(y))\\n\")\n\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Let's plot the probability density function to compare results. We first draw samples from the measure with the help of ",{"attributes":{},"tag":"code","children":["sampleMeasure()"],"type":"node"},", and then evaluate the basis at these samples and multiply times the PCE coefficients. The latter stop is done using ",{"attributes":{},"tag":"code","children":["evaluatePCE()"],"type":"node"},". Finally, we compare the result agains the analytical PDF ",{"attributes":{},"tag":"math","children":["\\rho(t) = \\frac{\\mathrm{e}^{-0.5t}}{\\sqrt{2 t} \\, \\Gamma(0.5)}"],"type":"node"}," of the chi-squared distribution with one degree of freedom."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["using Plots\nNsmpl = 10000\n# long way: ξ = sampleMeasure(Nsmpl,opq), ysmpl = evaluatePCE(y,ξ,opq)\nysmpl = samplePCE(Nsmpl, y, opq)\nhistogram(ysmpl; normalize=true, xlabel=\"t\", ylabel=\"rho(t)\")\n\nimport SpecialFunctions: gamma\nρ(t) = 1/(sqrt(2)*gamma(0.5))*1/sqrt(t)*exp(-0.5*t)\nt = range(0.1; stop=maximum(ysmpl), length=100)\nplot!(t, ρ.(t), w=4)\n"],"type":"node"}],"type":"node"}],"type":"node"}