{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/LinearSolve/X7B6E/docs/src/basics/Preconditioners.md","title":"[Preconditioners]( prec)"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["[Preconditioners](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," prec)"],"type":"node"},{"attributes":{},"tag":"p","children":["Many linear solvers can be accelerated by using what is known as a ",{"attributes":{},"tag":"strong","children":["preconditioner"],"type":"node"},", an approximation to the matrix inverse action which is cheap to evaluate. These can improve the numerical conditioning of the solver process and in turn improve the performance. LinearSolve.jl provides an interface for the definition of preconditioners which works with the wrapped packages."],"type":"node"},{"attributes":{},"tag":"h2","children":["Using Preconditioners"],"type":"node"},{"attributes":{},"tag":"h3","children":["Mathematical Definition"],"type":"node"},{"attributes":{},"tag":"p","children":["Preconditioners are specified in the keyword arguments of ",{"attributes":{},"tag":"code","children":["init"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["solve"],"type":"node"},". The right preconditioner, ",{"attributes":{},"tag":"code","children":["Pr"],"type":"node"}," transforms the linear system ",{"attributes":{},"tag":"math","children":["Au = b"],"type":"node"}," into the form:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["AP_r^{-1}(Pu) = AP_r^{-1}y = b"],"type":"node"},{"attributes":{},"tag":"p","children":["to add the solving step ",{"attributes":{},"tag":"math","children":["P_r u = y"],"type":"node"},". The left preconditioner, ",{"attributes":{},"tag":"code","children":["Pl"],"type":"node"},", transforms the linear system into the form:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["P_l^{-1}(Au - b) = 0"],"type":"node"},{"attributes":{},"tag":"p","children":["A two-sided preconditioned system is of the form:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["P_l A P_r^{-1} (P_r u) = P_l b"],"type":"node"},{"attributes":{},"tag":"p","children":["By default, if no preconditioner is given the preconditioner is assumed to be the identity ",{"attributes":{},"tag":"math","children":["I"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h3","children":["Using Preconditioners"],"type":"node"},{"attributes":{},"tag":"p","children":["In the following, we will use the ",{"attributes":{},"tag":"code","children":["DiagonalPreconditioner"],"type":"node"}," to define a two-sided preconditioned system which first divides by some random numbers and then multiplies by the same values. This is commonly used in the case where if, instead of random, ",{"attributes":{},"tag":"code","children":["s"],"type":"node"}," is an approximation to the eigenvalues of a system."],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"USING","children":[{"attributes":{},"tag":"USING","children":["using"],"type":"node"},{"attributes":{},"tag":"DOT","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/LinearSolve"},"tag":"reference","children":["LinearSolve"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"DOT","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["LinearAlgebra"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["s"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["rand"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["n"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["Pl"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["Diagonal"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["s"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["A"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["rand"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["n"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["n"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["b"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["rand"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["n"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["prob"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/SciMLBase.LinearProblem"},"tag":"reference","children":["LinearProblem"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["A"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["b"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["sol"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/CommonSolve.solve"},"tag":"reference","children":["solve"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["prob"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["IterativeSolvers_GMRES"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["Pl"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["Pl"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Preconditioner Interface"],"type":"node"},{"attributes":{},"tag":"p","children":["To define a new preconditioner you define a Julia type which satisfies the following interface:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["Base.eltype(::Preconditioner)"],"type":"node"}," (Required only for Krylov.jl)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["LinearAlgebra.ldiv!(::AbstractVector,::Preconditioner,::AbstractVector)"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["LinearAlgebra.ldiv!(::Preconditioner,::AbstractVector)"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Curated List of Pre-Defined Preconditioners"],"type":"node"},{"attributes":{},"tag":"p","children":["The following preconditioners match the interface of LinearSolve.jl."],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["LinearSolve.ComposePreconditioner(prec1,prec2)"],"type":"node"},": composes the preconditioners to apply ",{"attributes":{},"tag":"code","children":["prec1"],"type":"node"}," before ",{"attributes":{},"tag":"code","children":["prec2"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["LinearSolve.InvPreconditioner(prec)"],"type":"node"},": inverts ",{"attributes":{},"tag":"code","children":["mul!"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["ldiv!"],"type":"node"}," in a preconditioner definition as a lazy inverse."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["LinearAlgera.Diagonal(s::Union{Number,AbstractVector})"],"type":"node"},": the lazy Diagonal matrix type of Base.LinearAlgebra. Used for efficient construction of a diagonal preconditioner."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Other ",{"attributes":{},"tag":"code","children":["Base.LinearAlgera"],"type":"node"}," types: all define the full Preconditioner interface."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://github.com/haampie/IncompleteLU.jl","title":""},"tag":"a","children":["IncompleteLU.ilu"],"type":"node"},": an implementation of the incomplete LU-factorization preconditioner. This requires ",{"attributes":{},"tag":"code","children":["A"],"type":"node"}," as a ",{"attributes":{},"tag":"code","children":["SparseMatrixCSC"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://github.com/mohamed82008/Preconditioners.jl","title":""},"tag":"a","children":["Preconditioners.CholeskyPreconditioner(A, i)"],"type":"node"},": An incomplete Cholesky preconditioner with cut-off level ",{"attributes":{},"tag":"code","children":["i"],"type":"node"},". Requires ",{"attributes":{},"tag":"code","children":["A"],"type":"node"}," as a ",{"attributes":{},"tag":"code","children":["AbstractMatrix"],"type":"node"}," and positive semi-definite."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://github.com/JuliaLinearAlgebra/AlgebraicMultigrid.jl","title":""},"tag":"a","children":["AlgebraicMultiGrid"],"type":"node"},": Implementations of the algebraic multigrid method. Must be converted to a preconditioner via ",{"attributes":{},"tag":"code","children":["AlgebraicMultiGrid.aspreconditioner(AlgebraicMultiGrid.precmethod(A))"],"type":"node"},". Requires ",{"attributes":{},"tag":"code","children":["A"],"type":"node"}," as a ",{"attributes":{},"tag":"code","children":["AbstractMatrix"],"type":"node"},". Provides the following methods:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["AlgebraicMultiGrid.ruge_stuben(A)"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["AlgebraicMultiGrid.smoothed_aggregation(A)"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://github.com/cortner/PyAMG.jl","title":""},"tag":"a","children":["PyAMG"],"type":"node"},": Implementations of the algebraic multigrid method. Must be converted to a preconditioner via ",{"attributes":{},"tag":"code","children":["PyAMG.aspreconditioner(PyAMG.precmethod(A))"],"type":"node"},". Requires ",{"attributes":{},"tag":"code","children":["A"],"type":"node"}," as a ",{"attributes":{},"tag":"code","children":["AbstractMatrix"],"type":"node"},". Provides the following methods:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["PyAMG.RugeStubenSolver(A)"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["PyAMG.SmoothedAggregationSolver(A)"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://github.com/mcovalt/ILUZero.jl","title":""},"tag":"a","children":["ILUZero.ILU0Precon(A::SparseMatrixCSC",", b_type = T)"],"type":"node"},": An incomplete LU implementation. Requires ",{"attributes":{},"tag":"code","children":["A"],"type":"node"}," as a ",{"attributes":{},"tag":"code","children":["SparseMatrixCSC"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://github.com/JuliaSmoothOptimizers/LimitedLDLFactorizations.jl","title":""},"tag":"a","children":["LimitedLDLFactorizations.lldl"],"type":"node"},": A limited-memory LDLᵀ factorization for symmetric matrices. Requires ",{"attributes":{},"tag":"code","children":["A"],"type":"node"}," as a ",{"attributes":{},"tag":"code","children":["SparseMatrixCSC"],"type":"node"},". Applying ",{"attributes":{},"tag":"code","children":["F = lldl(A); F.D .= abs.(F.D)"],"type":"node"}," before usage as a preconditioner makes the preconditioner symmetric postive definite and thus is required for Krylov methods which are specialized for symmetric linear systems."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://github.com/tjdiamandis/RandomizedPreconditioners.jl","title":""},"tag":"a","children":["RandomizedPreconditioners.NystromPreconditioner"],"type":"node"}," A randomized sketching method for positive semidefinite matrices ",{"attributes":{},"tag":"code","children":["A"],"type":"node"},". Builds a preconditioner ",{"attributes":{},"tag":"math","children":["P ≈ A + μ*I"],"type":"node"}," for the system ",{"attributes":{},"tag":"math","children":["(A + μ*I)x = b"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}