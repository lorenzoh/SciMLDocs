{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/DiffEqNoiseProcess/iWugD/docs/src/abstract_noise_processes.md","title":"Abstract Noise Processes"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Abstract Noise Processes"],"type":"node"},{"attributes":{},"tag":"p","children":["In addition to the ",{"attributes":{},"tag":"code","children":["NoiseProcess"],"type":"node"}," type, more general ",{"attributes":{},"tag":"code","children":["AbstractNoiseProcess"],"type":"node"},"es are defined. The ",{"attributes":{},"tag":"code","children":["NoiseGrid"],"type":"node"}," allows you to define a noise process from a set of pre-calculated points (the \"normal\" way). The ",{"attributes":{},"tag":"code","children":["NoiseApproximation"],"type":"node"}," allows you to define a new noise process as the solution to some stochastic differential equation. While these methods are only approximate, they are more general and allow the user to easily define their own colored noise to use in simulations."],"type":"node"},{"attributes":{},"tag":"p","children":["The ",{"attributes":{},"tag":"code","children":["NoiseWrapper"],"type":"node"}," allows one to wrap a ",{"attributes":{},"tag":"code","children":["NoiseProcess"],"type":"node"}," from a previous simulation to re-use it in a new simulation in a way that follows the same stochastic trajectory (even if different points are hit, for example solving with a smaller ",{"attributes":{},"tag":"code","children":["dt"],"type":"node"},") in a distributionally-exact manner. It is demonstrated how the ",{"attributes":{},"tag":"code","children":["NoiseWrapper"],"type":"node"}," can be used to wrap the ",{"attributes":{},"tag":"code","children":["NoiseProcess"],"type":"node"}," of one SDE/RODE solution in order to re-use the same noise process in another simulation."],"type":"node"},{"attributes":{},"tag":"p","children":["The ",{"attributes":{},"tag":"code","children":["VirtualBrownianTree"],"type":"node"}," allows one to trade speed for O(1) memory usage. Instead of storing Brownian motion increments, the ",{"attributes":{},"tag":"code","children":["VirtualBrownianTree"],"type":"node"}," samples recursively from the midpoint ",{"attributes":{},"tag":"code","children":["tmid"],"type":"node"}," of Brownian bridges, using a splittable PRNG. The recursion terminates when the query time agrees within some tolerance with ",{"attributes":{},"tag":"code","children":["tmid"],"type":"node"}," or when the maximum depth of the tree is reached."],"type":"node"},{"attributes":{},"tag":"p","children":["Lastly, the ",{"attributes":{},"tag":"code","children":["NoiseFunction"],"type":"node"}," allows you to use any function of time as the noise process. Together, this functionality allows you to define any colored noise process and use this efficiently and accurately in your simulations."],"type":"node"},{"attributes":{},"tag":"h2","children":["The Standard ",{"attributes":{},"tag":"code","children":["AbstractNoiseProcess"],"type":"node"}],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["NoiseProcess\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["Alternative ",{"attributes":{},"tag":"code","children":["AbstractNoiseProcess"],"type":"node"}," Types"],"type":"node"},{"attributes":{},"tag":"p","children":["In addition to the mathematically-defined noise processes above, there exists more generic functionality for building noise processes from other noise processes, from arbitrary functions, from arrays, and from approximations of stochastic differential equations."],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["NoiseWrapper\nNoiseFunction\nNoiseGrid\nNoiseApproximation\nVirtualBrownianTree\nSimpleNoiseProcess\nBoxWedgeTail\npCN\n"],"type":"node"}],"type":"node"}],"type":"node"}