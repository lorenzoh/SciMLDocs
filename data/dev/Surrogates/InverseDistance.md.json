{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/Surrogates/zwNvG/docs/src/InverseDistance.md","title":"InverseDistance"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["The ",{"attributes":{},"tag":"strong","children":["Inverse Distance Surrogate"],"type":"node"}," is an interpolating method and in this method the unknown points are calculated with a weighted average of the sampling points. This model uses the inverse distance between the unknown and training points to predict the unknown point. We do not need to fit this model because the response of an unknown point x is computed with respect to the distance between x and the training points."],"type":"node"},{"attributes":{},"tag":"p","children":["Let's optimize following function to use Inverse Distance Surrogate:"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"math","children":["f(x) = sin(x) + sin(x)^2 + sin(x)^3"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["First of all, we have to import these two packages: ",{"attributes":{},"tag":"code","children":["Surrogates"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["Plots"],"type":"node"},"."],"type":"node"},{"attributes":{"lang":"@example Inverse_Distance1D"},"tag":"codeblock","children":["using Surrogates\nusing Plots\ndefault()\n"],"type":"node"},{"attributes":{},"tag":"h3","children":["Sampling"],"type":"node"},{"attributes":{},"tag":"p","children":["We choose to sample f in 25 points between 0 and 10 using the ",{"attributes":{},"tag":"code","children":["sample"],"type":"node"}," function. The sampling points are chosen using a Low Discrepancy, this can be done by passing ",{"attributes":{},"tag":"code","children":["LowDiscrepancySample()"],"type":"node"}," to the ",{"attributes":{},"tag":"code","children":["sample"],"type":"node"}," function."],"type":"node"},{"attributes":{"lang":"@example Inverse_Distance1D"},"tag":"codeblock","children":["f(x) = sin(x) + sin(x)^2 + sin(x)^3\n\nn_samples = 25\nlower_bound = 0.0\nupper_bound = 10.0\nx = sample(n_samples, lower_bound, upper_bound, LowDiscrepancySample(2))\ny = f.(x)\n\nscatter(x, y, label=\"Sampled points\", xlims=(lower_bound, upper_bound), legend=:top)\nplot!(f, label=\"True function\", xlims=(lower_bound, upper_bound), legend=:top)\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["Building a Surrogate"],"type":"node"},{"attributes":{"lang":"@example Inverse_Distance1D"},"tag":"codeblock","children":["InverseDistance = InverseDistanceSurrogate(x, y, lower_bound, upper_bound)\nadd_point!(InverseDistance, 5.0, f(5.0))\nadd_point!(InverseDistance, [5.1,5.2], [f(5.1),f(5.2)])\nprediction = InverseDistance(5.0)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Now, we will simply plot ",{"attributes":{},"tag":"code","children":["InverseDistance"],"type":"node"},":"],"type":"node"},{"attributes":{"lang":"@example Inverse_Distance1D"},"tag":"codeblock","children":["plot(x, y, seriestype=:scatter, label=\"Sampled points\", xlims=(lower_bound, upper_bound), legend=:top)\nplot!(f, label=\"True function\",  xlims=(lower_bound, upper_bound), legend=:top)\nplot!(InverseDistance, label=\"Surrogate function\",  xlims=(lower_bound, upper_bound), legend=:top)\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["Optimizing"],"type":"node"},{"attributes":{},"tag":"p","children":["Having built a surrogate, we can now use it to search for minimas in our original function ",{"attributes":{},"tag":"code","children":["f"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["To optimize using our surrogate we call ",{"attributes":{},"tag":"code","children":["surrogate_optimize"],"type":"node"}," method. We choose to use Stochastic RBF as optimization technique and again Sobol sampling as sampling technique."],"type":"node"},{"attributes":{"lang":"@example Inverse_Distance1D"},"tag":"codeblock","children":["@show surrogate_optimize(f, SRBF(), lower_bound, upper_bound, InverseDistance, SobolSample())\nscatter(x, y, label=\"Sampled points\", legend=:top)\nplot!(f, label=\"True function\",  xlims=(lower_bound, upper_bound), legend=:top)\nplot!(InverseDistance, label=\"Surrogate function\",  xlims=(lower_bound, upper_bound), legend=:top)\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["Inverse Distance Surrogate Tutorial (ND):"],"type":"node"},{"attributes":{},"tag":"p","children":["First of all we will define the ",{"attributes":{},"tag":"code","children":["Schaffer"],"type":"node"}," function we are going to build surrogate for. Notice, one how its argument is a vector of numbers, one for each coordinate, and its output is a scalar."],"type":"node"},{"attributes":{"lang":"@example Inverse_DistanceND"},"tag":"codeblock","children":["using Plots # hide\ndefault(c=:matter, legend=false, xlabel=\"x\", ylabel=\"y\") # hide\nusing Surrogates # hide\n\nfunction schaffer(x)\n    x1=x[1]\n    x2=x[2]\n    fact1 = (sin(x1^2-x2^2))^2 - 0.5;\n    fact2 = (1 + 0.001*(x1^2+x2^2))^2;\n    y = 0.5 + fact1/fact2;\nend\n"],"type":"node"},{"attributes":{},"tag":"h3","children":["Sampling"],"type":"node"},{"attributes":{},"tag":"p","children":["Let's define our bounds, this time we are working in two dimensions. In particular we want our first dimension ",{"attributes":{},"tag":"code","children":["x"],"type":"node"}," to have bounds ",{"attributes":{},"tag":"code","children":["-5, 10"],"type":"node"},", and ",{"attributes":{},"tag":"code","children":["0, 15"],"type":"node"}," for the second dimension. We are taking 60 samples of the space using Sobol Sequences. We then evaluate our function on all of the sampling points."],"type":"node"},{"attributes":{"lang":"@example Inverse_DistanceND"},"tag":"codeblock","children":["n_samples = 60\nlower_bound = [-5.0, 0.0]\nupper_bound = [10.0, 15.0]\n\nxys = sample(n_samples, lower_bound, upper_bound, SobolSample())\nzs = schaffer.(xys);\n"],"type":"node"},{"attributes":{"lang":"@example Inverse_DistanceND"},"tag":"codeblock","children":["x, y = -5:10, 0:15 # hide\np1 = surface(x, y, (x1,x2) -> schaffer((x1,x2))) # hide\nxs = [xy[1] for xy in xys] # hide\nys = [xy[2] for xy in xys] # hide\nscatter!(xs, ys, zs) # hide\np2 = contour(x, y, (x1,x2) -> schaffer((x1,x2))) # hide\nscatter!(xs, ys) # hide\nplot(p1, p2, title=\"True function\") # hide\n"],"type":"node"},{"attributes":{},"tag":"h3","children":["Building a surrogate"],"type":"node"},{"attributes":{},"tag":"p","children":["Using the sampled points we build the surrogate, the steps are analogous to the 1-dimensional case."],"type":"node"},{"attributes":{"lang":"@example Inverse_DistanceND"},"tag":"codeblock","children":["InverseDistance = InverseDistanceSurrogate(xys, zs,  lower_bound, upper_bound)\n"],"type":"node"},{"attributes":{"lang":"@example Inverse_DistanceND"},"tag":"codeblock","children":["p1 = surface(x, y, (x, y) -> InverseDistance([x y])) # hide\nscatter!(xs, ys, zs, marker_z=zs) # hide\np2 = contour(x, y, (x, y) -> InverseDistance([x y])) # hide\nscatter!(xs, ys, marker_z=zs) # hide\nplot(p1, p2, title=\"Surrogate\") # hide\n"],"type":"node"},{"attributes":{},"tag":"h3","children":["Optimizing"],"type":"node"},{"attributes":{},"tag":"p","children":["With our surrogate we can now search for the minimas of the function."],"type":"node"},{"attributes":{},"tag":"p","children":["Notice how the new sampled points, which were created during the optimization process, are appended to the ",{"attributes":{},"tag":"code","children":["xys"],"type":"node"}," array. This is why its size changes."],"type":"node"},{"attributes":{"lang":"@example Inverse_DistanceND"},"tag":"codeblock","children":["size(xys)\n"],"type":"node"},{"attributes":{"lang":"@example Inverse_DistanceND"},"tag":"codeblock","children":["surrogate_optimize(schaffer, SRBF(), lower_bound, upper_bound, InverseDistance, SobolSample(), maxiters=10)\n"],"type":"node"},{"attributes":{"lang":"@example Inverse_DistanceND"},"tag":"codeblock","children":["size(xys)\n"],"type":"node"},{"attributes":{"lang":"@example Inverse_DistanceND"},"tag":"codeblock","children":["p1 = surface(x, y, (x, y) -> InverseDistance([x y])) # hide\nxs = [xy[1] for xy in xys] # hide\nys = [xy[2] for xy in xys] # hide\nzs = schaffer.(xys) # hide\nscatter!(xs, ys, zs, marker_z=zs) # hide\np2 = contour(x, y, (x, y) -> InverseDistance([x y])) # hide\nscatter!(xs, ys, marker_z=zs) # hide\nplot(p1, p2) # hide\n"],"type":"node"}],"type":"node"}],"type":"node"}