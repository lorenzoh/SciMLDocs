{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/ModelingToolkit/fp90z/docs/src/mtkitize_tutorials/modelingtoolkitize.md","title":"Automatically Accelerating ODEProblem Code"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Automatically Accelerating ODEProblem Code"],"type":"node"},{"attributes":{},"tag":"p","children":["For some ",{"attributes":{},"tag":"code","children":["DEProblem"],"type":"node"}," types, automatic tracing functionality is already included via the ",{"attributes":{},"tag":"code","children":["modelingtoolkitize"],"type":"node"}," function. Take, for example, the Robertson ODE defined as an ",{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"}," for DifferentialEquations.jl:"],"type":"node"},{"attributes":{"lang":"@example mtkize"},"tag":"codeblock","children":["using DifferentialEquations, ModelingToolkit\nfunction rober(du,u,p,t)\n  y₁,y₂,y₃ = u\n  k₁,k₂,k₃ = p\n  du[1] = -k₁*y₁+k₃*y₂*y₃\n  du[2] =  k₁*y₁-k₂*y₂^2-k₃*y₂*y₃\n  du[3] =  k₂*y₂^2\n  nothing\nend\nprob = ODEProblem(rober,[1.0,0.0,0.0],(0.0,1e5),(0.04,3e7,1e4))\n"],"type":"node"},{"attributes":{},"tag":"p","children":["If we want to get a symbolic representation, we can simply call ",{"attributes":{},"tag":"code","children":["modelingtoolkitize"],"type":"node"}," on the ",{"attributes":{},"tag":"code","children":["prob"],"type":"node"},", which will return an ",{"attributes":{},"tag":"code","children":["ODESystem"],"type":"node"},":"],"type":"node"},{"attributes":{"lang":"@example mtkize"},"tag":"codeblock","children":["sys = modelingtoolkitize(prob)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Using this, we can symbolically build the Jacobian and then rebuild the ODEProblem:"],"type":"node"},{"attributes":{"lang":"@example mtkize"},"tag":"codeblock","children":["prob_jac = ODEProblem(sys,[],(0.0,1e5),jac=true)\n"],"type":"node"}],"type":"node"}],"type":"node"}