{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/ModelingToolkit/fp90z/docs/src/internals.md","title":"Internal Details"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Internal Details"],"type":"node"},{"attributes":{},"tag":"p","children":["This is a page for detailing some of the inner workings to help future contributors to the library."],"type":"node"},{"attributes":{},"tag":"h2","children":["Observables and Variable Elimination"],"type":"node"},{"attributes":{},"tag":"p","children":["In the variable \"elimination\" algorithms, what is actually done is that variables are removed from being states and equations are moved into the ",{"attributes":{},"tag":"code","children":["observed"],"type":"node"}," category of the system. The ",{"attributes":{},"tag":"code","children":["observed"],"type":"node"}," equations are explicit algebraic equations which are then substituted out to completely eliminate these variables from the other equations, allowing the system to act as though these variables no longer exist."],"type":"node"},{"attributes":{},"tag":"p","children":["However, as a user may have wanted to interact with such variables, for example, plotting their output, these relationships are stored and are then used to generate the ",{"attributes":{},"tag":"code","children":["observed"],"type":"node"}," equation found in the ",{"attributes":{},"tag":"code","children":["SciMLFunction"],"type":"node"}," interface, so that ",{"attributes":{},"tag":"code","children":["sol[x]"],"type":"node"}," lazily reconstructs the observed variable when necessary. In this sense, there is an equivalence between observables and the variable elimination system."],"type":"node"},{"attributes":{},"tag":"p","children":["The procedure for variable elimination inside ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"ModelingToolkit/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["structural_simplify"],"type":"node"}],"type":"node"}," is"],"type":"node"},{"attributes":{},"tag":"ol","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"ModelingToolkit/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["ModelingToolkit.initialize_system_structure"],"type":"node"}],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"ModelingToolkit/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["ModelingToolkit.alias_elimination"],"type":"node"}],"type":"node"},". This step moves equations into ",{"attributes":{},"tag":"code","children":["observed(sys)"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"ModelingToolkit/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["ModelingToolkit.dae_index_lowering"],"type":"node"}],"type":"node"}," by means of ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"ModelingToolkit/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["pantelides!"],"type":"node"}],"type":"node"}," (if the system is an ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"ModelingToolkit/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["ODESystem"],"type":"node"}],"type":"node"},")."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"ModelingToolkit/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["ModelingToolkit.tearing"],"type":"node"}],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Preparing a system for simulation"],"type":"node"},{"attributes":{},"tag":"p","children":["Before a simulation or optimization can be performed, the symbolic equations stored in an ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"ModelingToolkit/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["AbstractSystem"],"type":"node"}],"type":"node"}," must be converted into executable code. This step is typically occurs after the simplification explained above, and is performed when an instance of a ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"ModelingToolkit/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["AbsSciMLBase.SciMLProblem"],"type":"node"}],"type":"node"},", such as a ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"ModelingToolkit/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"}],"type":"node"},", is constructed. The call chain typically looks like this, with the function names in the case of an ",{"attributes":{},"tag":"code","children":["ODESystem"],"type":"node"}," indicated in parenthesis"],"type":"node"},{"attributes":{},"tag":"ol","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Problem constructor (",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"ModelingToolkit/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"}],"type":"node"},")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Build an ",{"attributes":{},"tag":"code","children":["DEFunction"],"type":"node"}," (",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"ModelingToolkit/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["process_DEProblem"],"type":"node"}],"type":"node"}," -> ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"ModelingToolkit/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["ODEFunction"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Write actual executable code (",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"ModelingToolkit/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["generate_function"],"type":"node"}],"type":"node"},")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Apart from ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"ModelingToolkit/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["generate_function"],"type":"node"}],"type":"node"},", which generates the dynamics function, ",{"attributes":{},"tag":"code","children":["ODEFunction"],"type":"node"}," also builds functions for observed equations (",{"attributes":{},"tag":"code","children":["build_explicit_observed_function"],"type":"node"},") and jacobians (",{"attributes":{},"tag":"code","children":["generate_jacobian"],"type":"node"},") etc. These are all stored in the ",{"attributes":{},"tag":"code","children":["ODEFunction"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"}