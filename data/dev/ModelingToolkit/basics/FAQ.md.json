{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/ModelingToolkit/fp90z/docs/src/basics/FAQ.md","title":"Frequently Asked Questions"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Frequently Asked Questions"],"type":"node"},{"attributes":{},"tag":"h2","children":["Getting the index for a symbol"],"type":"node"},{"attributes":{},"tag":"p","children":["Since ",{"attributes":{},"tag":"strong","children":["ordering of symbols is not guaranteed after symbolic transformations"],"type":"node"},", one should normally refer to values by their name. For example, ",{"attributes":{},"tag":"code","children":["sol[lorenz.x]"],"type":"node"}," from the solution. But what if you need to get the index? The following helper function will do the trick:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["indexof"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["sym"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["syms"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["findfirst"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["isequal"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["sym"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["syms"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["indexof"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["σ"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/ModelingToolkit.parameters"},"tag":"reference","children":["parameters"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["sys"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Transforming value maps to arrays"],"type":"node"},{"attributes":{},"tag":"p","children":["ModelingToolkit.jl allows (and recommends) input maps like ",{"attributes":{},"tag":"code","children":["[x => 2.0, y => 3.0]"],"type":"node"}," because symbol ordering is not guaranteed. However, what if you want to get the lowered array? You can use the internal function ",{"attributes":{},"tag":"code","children":["varmap_to_vars"],"type":"node"},". For example:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["pnew"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/ModelingToolkit.varmap_to_vars"},"tag":"reference","children":["varmap_to_vars"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"VECT","children":[{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["β"],"type":"node"},{"attributes":{},"tag":"PAIR_ARROW","children":["=>"],"type":"node"},{"attributes":{},"tag":"FLOAT","children":["3.0"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["c"],"type":"node"},{"attributes":{},"tag":"PAIR_ARROW","children":["=>"],"type":"node"},{"attributes":{},"tag":"FLOAT","children":["10.0"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["γ"],"type":"node"},{"attributes":{},"tag":"PAIR_ARROW","children":["=>"],"type":"node"},{"attributes":{},"tag":"FLOAT","children":["2.0"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/ModelingToolkit.parameters"},"tag":"reference","children":["parameters"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["sys"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["How do I handle ",{"attributes":{},"tag":"code","children":["if"],"type":"node"}," statements in my symbolic forms?"],"type":"node"},{"attributes":{},"tag":"p","children":["For statements that are in the ",{"attributes":{},"tag":"code","children":["if then else"],"type":"node"}," form, use ",{"attributes":{},"tag":"code","children":["IfElse.ifelse"],"type":"node"}," from the ",{"attributes":{"href":"https://github.com/SciML/IfElse.jl","title":""},"tag":"a","children":["IfElse.jl"],"type":"node"}," package to represent the code in a functional form. For handling direct ",{"attributes":{},"tag":"code","children":["if"],"type":"node"}," statements, you can use equivalent boolean mathematical expressions. For example ",{"attributes":{},"tag":"code","children":["if x > 0 ..."],"type":"node"}," can be implemented as just ",{"attributes":{},"tag":"code","children":["(x > 0) * "],"type":"node"},", where if ",{"attributes":{},"tag":"code","children":["x <= 0"],"type":"node"}," then the boolean will evaluate to ",{"attributes":{},"tag":"code","children":["0"],"type":"node"}," and thus the term will be excluded from the model."],"type":"node"},{"attributes":{},"tag":"h2","children":["ERROR: TypeError: non-boolean (Num) used in boolean context?"],"type":"node"},{"attributes":{},"tag":"p","children":["If you see the error:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":["ERROR: TypeError: non-boolean (Num) used in boolean context"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["then it's likely you are trying to trace through a function which cannot be directly represented in Julia symbols. The techniques to handle this problem, such as ",{"attributes":{},"tag":"code","children":["@register_symbolic"],"type":"node"},", are described in detail ",{"attributes":{"href":"https://symbolics.juliasymbolics.org/dev/manual/faq/#Transforming-my-function-to-a-symbolic-equation-has-failed.-What-do-I-do?-1","title":""},"tag":"a","children":["in the Symbolics.jl documentation"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"}