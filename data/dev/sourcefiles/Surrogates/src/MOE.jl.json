{"attributes":{"module":"Surrogates","backlinks":[],"path":"/Users/lorenz/.julia/packages/Surrogates/zwNvG/src/MOE.jl","title":"Surrogates/src/MOE.jl"},"tag":"sourcefile","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["using Clustering #using GaussianMixtures using LinearAlgebra"],"type":"node"},{"attributes":{},"tag":"p","children":["mutable struct MOE <: AbstractSurrogate x::X y::Y lb::L ub::U local_surr::S k::K means::M varcov::V weights::W end"],"type":"node"},{"attributes":{},"tag":"p","children":["function MOE(x,y,lb::Number,ub::Number; scale_factor::Number = 1.0, k::Int = 2, local_kind = [RadialBasisStructure(radial_function = linearRadial, scale_factor=1.0,sparse = false),RadialBasisStructure(radial_function = cubicRadial, scale_factor=1.0, sparse = false)]) if k != length(local_kind) throw(\"Number of mixtures = $k is not equal to length of local surrogates\") end n = length(x) x = x ./ scale_factor y = y ./ scale_factor # find weight, mean and variance for each mixture # For GaussianMixtures I need nxd matrix X_G = reshape(x,(n,1)) moe_gmm = GaussianMixtures.GMM(k,X_G) weights = GaussianMixtures.weights(moe_gmm) means = GaussianMixtures.means(moe_gmm) variances = moe_gmm.Σ"],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["#cluster the points\n#For clustering I need dxn matrix\nX_C = reshape(x,(1,n))\nKNN = kmeans(X_C, k)\nx_c = [ Array{eltype(x)}(undef,0) for i = 1:k]\ny_c = [ Array{eltype(y)}(undef,0) for i = 1:k]\na = assignments(KNN)\n@inbounds for i = 1:n\n    pos = a[i]\n    append!(x_c[pos],x[i])\n    append!(y_c[pos],y[i])\nend\n\nlocal_surr = Dict()\nfor i = 1:k\n    if local_kind[i][1] == \"RadialBasis\"\n        #fit and append to local_surr\n        my_local_i = RadialBasis(x_c[i],y_c[i],lb,ub,rad = local_kind[i].radial_function, scale_factor = local_kind[i].scale_factor, sparse = local_kind[i].sparse)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i][1] == \"Kriging\"\n        my_local_i = Kriging(x_c[i], y_c[i],lb,ub, p = local_kind[i].p, theta = local_kind[i].theta)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i][1] == \"GEK\"\n        my_local_i = GEK(x_c[i], y_c[i],lb,ub, p = local_kind[i].p, theta = local_kind[i].theta)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i] == \"LinearSurrogate\"\n        my_local_i = LinearSurrogate(x_c[i], y_c[i],lb,ub)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i][1] == \"InverseDistanceSurrogate\"\n        my_local_i = InverseDistanceSurrogate(x_c[i], y_c[i],lb,ub, local_kind[i].p)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i][1] == \"LobachevskySurrogate\"\n        my_local_i = LobachevskySurrogate(x_c[i], y_c[i],lb,ub,alpha = local_kind[i].alpha , n = local_kind[i].n, sparse = local_kind[i].sparse)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i][1] == \"NeuralSurrogate\"\n        my_local_i = NeuralSurrogate(x_c[i], y_c[i],lb,ub, model = local_kind[i].model , loss = local_kind[i].loss ,opt = local_kind[i].opt ,n_echos = local_kind[i].n_echos)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i][1] == \"RandomForestSurrogate\"\n        my_local_i = RandomForestSurrogate(x_c[i], y_c[i],lb,ub, num_round = local_kind[i].num_round)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i] == \"SecondOrderPolynomialSurrogate\"\n        my_local_i = SecondOrderPolynomialSurrogate(x_c[i], y_c[i],lb,ub)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i][1] == \"Wendland\"\n        my_local_i = Wendand(x_c[i], y_c[i],lb,ub, eps = local_kind[i].eps, maxiters = local_kind[i].maxiters, tol = local_kind[i].tol)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i][1] == \"PolynomialChaosSurrogate\"\n        my_local_i = PolynomialChaosSurrogate(x,y,lb,ub, op = local_kind[i].op)\n        local_surr[i] = my_local_i\n    else\n        throw(\"A surrogate with name provided does not exist or is not currently supported with MOE.\")\n    end\nend\nreturn MOE(x,y,lb,ub,local_surr,k,means,variances,weights)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["end"],"type":"node"},{"attributes":{},"tag":"p","children":["function MOE(x,y,lb,ub; k::Int = 2, scale_factor::Number = 1.0, local_kind = [RadialBasisStructure(radial_function = linearRadial, scale_factor=1.0, sparse = false),RadialBasisStructure(radial_function = cubicRadial, scale_factor=1.0, sparse = false)])"],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["n = length(x)\nd = length(lb)\nfor i = 1:n\n    x[i] = x[i] ./ scale_factor\nend\ny = y ./ scale_factor\n#GMM parameters:\nX_G = collect(reshape(collect(Base.Iterators.flatten(x)), (d,n))')\nmy_gmm = GMM(k,X_G,kind = :full)\nweights = my_gmm.w\nmeans = my_gmm.μ\nvarcov = my_gmm.Σ\n\n#cluster the points\nX_C = collect(reshape(collect(Base.Iterators.flatten(x)), (d,n)))\nKNN = kmeans(X_C, k)\nx_c = [ Array{eltype(x)}(undef,0) for i = 1:k]\ny_c = [ Array{eltype(y)}(undef,0) for i = 1:k]\na = assignments(KNN)\n@inbounds for i = 1:n\n    pos = a[i]\n    x_c[pos] = vcat(x_c[pos],x[i])\n    append!(y_c[pos],y[i])\nend\n\nlocal_surr = Dict()\nfor i = 1:k\n    if local_kind[i][1] == \"RadialBasis\"\n        #fit and append to local_surr\n        my_local_i = RadialBasis(x_c[i],y_c[i],lb,ub,rad = local_kind[i].radial_function, scale_factor = local_kind[i].scale_factor, sparse = local_kind[i].sparse)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i][1] == \"Kriging\"\n        my_local_i = Kriging(x_c[i], y_c[i],lb,ub, p = local_kind[i].p, theta = local_kind[i].theta)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i][1] == \"GEK\"\n        my_local_i = GEK(x_c[i], y_c[i],lb,ub, p = local_kind[i].p, theta = local_kind[i].theta)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i] == \"LinearSurrogate\"\n        my_local_i = LinearSurrogate(x_c[i], y_c[i],lb,ub)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i][1] == \"InverseDistanceSurrogate\"\n        my_local_i = InverseDistanceSurrogate(x_c[i], y_c[i],lb,ub, local_kind[i].p)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i][1] == \"LobachevskySurrogate\"\n        my_local_i = LobachevskySurrogate(x_c[i], y_c[i],lb,ub,alpha = local_kind[i].alpha , n = local_kind[i].n, sparse = local_kind[i].sparse)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i][1] == \"NeuralSurrogate\"\n        my_local_i = NeuralSurrogate(x_c[i], y_c[i],lb,ub, model = local_kind[i].model , loss = local_kind[i].loss ,opt = local_kind[i].opt ,n_echos = local_kind[i].n_echos)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i][1] == \"RandomForestSurrogate\"\n        my_local_i = RandomForestSurrogate(x_c[i], y_c[i],lb,ub, num_round = local_kind[i].num_round)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i] == \"SecondOrderPolynomialSurrogate\"\n        my_local_i = SecondOrderPolynomialSurrogate(x_c[i], y_c[i],lb,ub)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i][1] == \"Wendland\"\n        my_local_i = Wendand(x_c[i], y_c[i],lb,ub, eps = local_kind[i].eps, maxiters = local_kind[i].maxiters, tol = local_kind[i].tol)\n        local_surr[i] = my_local_i\n\n    elseif local_kind[i][1] == \"PolynomialChaosSurrogate\"\n        my_local_i = PolynomialChaosSurrogate(x,y,lb,ub, op = local_kind[i].op)\n        local_surr[i] = my_local_i\n    else\n        throw(\"A surrogate with name \"* local_kind[i][1] *\" does not exist or is not currently supported with MOE.\")\n    end\nend\nreturn MOE(x,y,lb,ub,local_surr,k,means,varcov,weights)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["end"],"type":"node"},{"attributes":{},"tag":"p","children":["function _prob_x_in_i(x::Number,i,mu,varcov,alpha,k) num = (1/sqrt(varcov[i]))",{"attributes":{},"tag":"em","children":["alpha[i]",{"attributes":{},"tag":"em","children":["exp(-0.5(x-mu[i])"],"type":"node"},"(1/varcov[i])"],"type":"node"},"(x-mu[i])) den = sum([(1/sqrt(varcov[j]))",{"attributes":{},"tag":"em","children":["alpha[j]",{"attributes":{},"tag":"em","children":["exp(-0.5(x-mu[j])"],"type":"node"},"(1/varcov[j])"],"type":"node"},"(x-mu[j]))  for j = 1:k]) return num/den end"],"type":"node"},{"attributes":{},"tag":"p","children":["function _prob_x_in_i(x,i,mu,varcov,alpha,k) num = (1/sqrt(det(varcov[i])))",{"attributes":{},"tag":"em","children":["alpha[i]",{"attributes":{},"tag":"em","children":["exp(-0.5"],"type":"node"},"(x .- mu[i,:])'"],"type":"node"},"(inv(varcov[i]))",{"attributes":{},"tag":"em","children":["(x .- mu[i,:]))"," ","den = sum([(1/sqrt(det(varcov[j])))",{"attributes":{},"tag":"em","children":["alpha[j]",{"attributes":{},"tag":"em","children":["exp(-0.5"],"type":"node"},"(x .- mu[j,:])'"],"type":"node"},"(inv(varcov[j]))"],"type":"node"},"(x .- mu[j,:])) for j = 1:k]) return num/den end"],"type":"node"},{"attributes":{},"tag":"p","children":["function (moe::MOE)(val) return prod([moe.local_surr",{"attributes":{"reftype":"document","href":"val","title":"","document_id":"sourcefiles/Surrogates/src/val"},"tag":"reference","children":["i"],"type":"node"},"*_prob_x_in_i(val,i,moe.means,moe.varcov,moe.weights,moe.k) for i = 1:moe.k]) end"],"type":"node"},{"attributes":{},"tag":"p","children":["function add_point!(my_moe::MOE,x_new,y_new) if length(my_moe.x[1]) == 1 #1D my_moe.x = vcat(my_moe.x,x_new) my_moe.y = vcat(my_moe.y,y_new) n = length(my_moe.x)"],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["    #New mixture parameters\n    X_G = reshape(my_moe.x,(n,1))\n    moe_gmm = GaussianMixtures.GMM(my_moe.k,X_G)\n    my_moe.weights = GaussianMixtures.weights(moe_gmm)\n    my_moe.means = GaussianMixtures.means(moe_gmm)\n    my_moe.varcov = moe_gmm.Σ\n\n    #Find cluster of new point(s):\n    n_added = length(x_new)\n    X_C = reshape(my_moe.x,(1,n))\n    KNN = kmeans(X_C, my_moe.k)\n    a = assignments(KNN)\n    #Recalculate only relevant surrogates\n    for i = 1:n_added\n        pos = a[n-n_added+i]\n        add_point!(my_moe.local_surr[i],my_moe.x[n-n_added+i],my_moe.y[n-n_added+i])\n    end\nelse\n    #ND\n    my_moe.x = vcat(my_moe.x,x_new)\n    my_moe.y = vcat(my_moe.y,y_new)\n    n = length(my_moe.x)\n    d = length(my_moe.lb)\n    #New mixture parameters\n    X_G = collect(reshape(collect(Base.Iterators.flatten(my_moe.x)), (d,n))')\n    my_gmm = GMM(my_moe.k,X_G,kind = :full)\n    my_moe.weights = my_gmm.w\n    my_moe.means = my_gmm.μ\n    my_moe.varcov = my_gmm.Σ\n\n    #cluster the points\n    X_C = collect(reshape(collect(Base.Iterators.flatten(my_moe.x)), (d,n)))\n    KNN = kmeans(X_C, my_moe.k)\n    a = assignments(KNN)\n    n_added = length(x_new)\n    for i = 1:n_added\n        pos = a[n-n_added+i]\n        add_point!(my_moe.local_surr[i],my_moe.x[n-n_added+i],my_moe.y[n-n_added+i])\n    end\nend\nnothing\n"],"type":"node"},{"attributes":{},"tag":"p","children":["end"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}