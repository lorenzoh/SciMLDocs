{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"DiffEqOperators/src/DiffEqOperators.jl","docid":"sourcefiles/DiffEqOperators/src/DiffEqOperators.jl"},{"tag":"sourcefile","title":"DiffEqOperators/src/docstrings.jl","docid":"sourcefiles/DiffEqOperators/src/docstrings.jl"},{"tag":"sourcefile","title":"DiffEqOperators/src/derivative_operators/multi_dim_bc_operators.jl","docid":"sourcefiles/DiffEqOperators/src/derivative_operators/multi_dim_bc_operators.jl"},{"tag":"document","title":"Derivative Operators","docid":"DiffEqOperators/operators/derivative_operators.md"},{"tag":"sourcefile","title":"DiffEqOperators/src/derivative_operators/bc_operators.jl","docid":"sourcefiles/DiffEqOperators/src/derivative_operators/bc_operators.jl"}],"methods":[{"line":144,"file":"/Users/lorenz/.julia/packages/DiffEqOperators/NWEwW/src/derivative_operators/bc_operators.jl","method_id":"DiffEqOperators.NeumannBC_1","symbol_id":"DiffEqOperators.NeumannBC","filedoc":"sourcefiles/DiffEqOperators/src/derivative_operators/bc_operators.jl","signature":"DiffEqOperators.NeumannBC(α::Tuple{T, T}, dx::Union{AbstractVector{T}, T})"},{"line":144,"file":"/Users/lorenz/.julia/packages/DiffEqOperators/NWEwW/src/derivative_operators/bc_operators.jl","method_id":"DiffEqOperators.NeumannBC_2","symbol_id":"DiffEqOperators.NeumannBC","filedoc":"sourcefiles/DiffEqOperators/src/derivative_operators/bc_operators.jl","signature":"DiffEqOperators.NeumannBC(α::Tuple{T, T}, dx::Union{AbstractVector{T}, T}, order)"},{"line":102,"file":"/Users/lorenz/.julia/packages/DiffEqOperators/NWEwW/src/derivative_operators/multi_dim_bc_operators.jl","method_id":"DiffEqOperators.NeumannBC_3","symbol_id":"DiffEqOperators.NeumannBC","filedoc":"sourcefiles/DiffEqOperators/src/derivative_operators/multi_dim_bc_operators.jl","signature":"DiffEqOperators.NeumannBC(α::Tuple{T, T}, dxyz, order, s)"}],"name":"NeumannBC","title":"NeumannBC","symbol_id":"DiffEqOperators.NeumannBC","public":true,"module_id":"DiffEqOperators"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["q = RobinBC(l, r, dx::T, approximation_order) where T # When this BC extends a dimension with a uniform step size\n\nq = RobinBC(l, r, dx::Vector{T}, approximation_order) where T # When this BC extends a dimension with a non-uniform step size. dx should be the vector of step sizes for the whole dimension.\n"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["l"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["r"],"type":"node"}," are the BC coefficients, i.e., ",{"attributes":{},"tag":"code","children":["(αl, βl, γl)"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["(αl, βl, γl)"],"type":"node"}," (tuples and vectors work) and correspond to BCs of the form:"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["αl * u + βl * u' = γl"],"type":"node"}," ",{"attributes":{},"tag":"code","children":["αr * u + βr * u' = γr"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["imposed on the lower (",{"attributes":{},"tag":"code","children":["l"],"type":"node"},") and higher (",{"attributes":{},"tag":"code","children":["r"],"type":"node"},") index boundaries, respectively."],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["RobinBC"],"type":"node"}," implements a Robin boundary condition operator ",{"attributes":{},"tag":"code","children":["Q"],"type":"node"}," that acts on a vector to give an extended vector as a result (see https://github.com/JuliaDiffEq/DiffEqOperators.jl/files/3267835/ghost_node.pdf)."],"type":"node"},{"attributes":{},"tag":"p","children":["Write vector b̄₁ as a vertical concatenation with b0 and the rest of the elements of b̄₁, denoted b̄",{"attributes":{},"tag":"code","children":["₁, the same with ū into u0 and ū"],"type":"node"},". b̄",{"attributes":{},"tag":"code","children":["₁ = b̄"],"type":"node"},"_2 = fill(β/Δx, length(stencil)-1). Pull out the product of u0 and b0 from the dot product. The stencil used to approximate u",{"attributes":{},"tag":"code","children":["is denoted s. b0 = α+(β/Δx)*s[1]. Rearrange terms to find a general formula for u0:= -b̄"],"type":"node"},"₁̇⋅ū",{"attributes":{},"tag":"code","children":["/b0 + γ/b0, which is dependent on ū"],"type":"node"}," the robin coefficients and Δx. The non-identity part of Qa is qa:= -b`₁/b0 = -β.",{"attributes":{},"tag":"em","children":["s[2:end]/(α+β"],"type":"node"},"s[1]/Δx). The constant part is Qb = γ/(α+β*s[1]/Δx) do the same at the other boundary (amounts to a flip of s[2:end], with the other set of boundary coefficients)."],"type":"node"}],"type":"node"}],"type":"node"}