{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"DiffEqSensitivity/src/forward_sensitivity.jl","docid":"sourcefiles/DiffEqSensitivity/src/forward_sensitivity.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/concrete_solve.jl","docid":"sourcefiles/DiffEqSensitivity/src/concrete_solve.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/DiffEqSensitivity.jl","docid":"sourcefiles/DiffEqSensitivity/src/DiffEqSensitivity.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/sensitivity_algorithms.jl","docid":"sourcefiles/DiffEqSensitivity/src/sensitivity_algorithms.jl"},{"tag":"document","title":"Optimization of Stochastic Differential Equations","docid":"DiffEqSensitivity/sde_fitting/optimization_sde.md"}],"methods":[{"line":99,"file":"/Users/lorenz/.julia/packages/DiffEqSensitivity/GjhZ8/src/sensitivity_algorithms.jl","method_id":"DiffEqSensitivity.ForwardDiffSensitivity_1","symbol_id":"DiffEqSensitivity.ForwardDiffSensitivity","filedoc":"sourcefiles/DiffEqSensitivity/src/sensitivity_algorithms.jl","signature":"DiffEqSensitivity.ForwardDiffSensitivity(; chunk_size, convert_tspan)"}],"name":"ForwardDiffSensitivity","title":"ForwardDiffSensitivity","symbol_id":"DiffEqSensitivity.ForwardDiffSensitivity","public":true,"module_id":"DiffEqSensitivity"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["ForwardDiffSensitivity <: AbstractForwardSensitivityAlgorithm"],"type":"node"},{"attributes":{},"tag":"p","children":["An implementation of discrete forward sensitivity analysis through ForwardDiff.jl. When used within adjoint differentiation (i.e. via Zygote), this will cause forward differentiation of the ",{"attributes":{},"tag":"code","children":["solve"],"type":"node"}," call within the reverse-mode automatic differentiation environment."],"type":"node"},{"attributes":{},"tag":"h2","children":["Constructor"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/DiffEqSensitivity.ForwardDiffSensitivity"},"tag":"reference","children":["ForwardDiffSensitivity"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"PARAMETERS","children":[{"attributes":{},"tag":"SEMICOLON","children":[";"],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["chunk_size"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["0"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{"reftype":"symbol","document_id":"references/DiffEqSensitivity.convert_tspan"},"tag":"reference","children":["convert_tspan"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Keyword Arguments"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["chunk_size"],"type":"node"},": the chunk size used by ForwardDiff for computing the Jacobian, i.e. the number of simultaneous columns computed."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["convert_tspan"],"type":"node"},": whether to convert time to also be ",{"attributes":{},"tag":"code","children":["Dual"],"type":"node"}," valued. By default this is ",{"attributes":{},"tag":"code","children":["nothing"],"type":"node"}," which will only convert if callbacks are found. Conversion is required in order to accurately differentiate callbacks (hybrid equations)."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["SciMLProblem Support"],"type":"node"},{"attributes":{},"tag":"p","children":["This ",{"attributes":{},"tag":"code","children":["sensealg"],"type":"node"}," supports any ",{"attributes":{},"tag":"code","children":["SciMLProblem"],"type":"node"},"s, provided that the solver algorithms is ",{"attributes":{},"tag":"code","children":["SciMLBase.isautodifferentiable"],"type":"node"},". Note that ",{"attributes":{},"tag":"code","children":["ForwardDiffSensitivity"],"type":"node"}," can accurately differentiate code with callbacks only when ",{"attributes":{},"tag":"code","children":["convert_tspan=true"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"}