{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"DiffEqSensitivity/src/concrete_solve.jl","docid":"sourcefiles/DiffEqSensitivity/src/concrete_solve.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/steadystate_adjoint.jl","docid":"sourcefiles/DiffEqSensitivity/src/steadystate_adjoint.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/DiffEqSensitivity.jl","docid":"sourcefiles/DiffEqSensitivity/src/DiffEqSensitivity.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/sensitivity_algorithms.jl","docid":"sourcefiles/DiffEqSensitivity/src/sensitivity_algorithms.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/sensitivity_interface.jl","docid":"sourcefiles/DiffEqSensitivity/src/sensitivity_interface.jl"}],"methods":[{"line":918,"file":"/Users/lorenz/.julia/packages/DiffEqSensitivity/GjhZ8/src/sensitivity_algorithms.jl","method_id":"DiffEqSensitivity.SteadyStateAdjoint_1","symbol_id":"DiffEqSensitivity.SteadyStateAdjoint","filedoc":"sourcefiles/DiffEqSensitivity/src/sensitivity_algorithms.jl","signature":"DiffEqSensitivity.SteadyStateAdjoint(; chunk_size, autodiff, diff_type, autojacvec, linsolve)"}],"name":"SteadyStateAdjoint","title":"SteadyStateAdjoint","symbol_id":"DiffEqSensitivity.SteadyStateAdjoint","public":true,"module_id":"DiffEqSensitivity"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["SteadyStateAdjoint <: AbstractAdjointSensitivityAlgorithm"],"type":"node"},{"attributes":{},"tag":"p","children":["An implementation of the adjoint differentiation of a nonlinear solve. Uses the implicit function theorem to directly compute the derivative of the solution to ",{"attributes":{},"tag":"math","children":["f(u,p) = 0"],"type":"node"}," with respect to ",{"attributes":{},"tag":"code","children":["p"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h2","children":["Constructor"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/DiffEqSensitivity.SteadyStateAdjoint"},"tag":"reference","children":["SteadyStateAdjoint"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"PARAMETERS","children":[{"attributes":{},"tag":"SEMICOLON","children":[";"],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["chunk_size"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["0"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["autodiff"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"TRUE","children":["true"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":[" \n                    "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{"reftype":"symbol","document_id":"references/DiffEqSensitivity.diff_type"},"tag":"reference","children":["diff_type"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CURLY","children":[{"attributes":{},"tag":"IDENTIFIER","children":["Val"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"QUOTE","children":[{"attributes":{},"tag":"COLON","children":[":"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["central"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                    "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["autojacvec"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["autodiff"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["linsolve"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Keyword Arguments"],"type":"node"},{"attributes":{},"tag":"h2","children":["Keyword Arguments"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["autodiff"],"type":"node"},": Use automatic differentiation for constructing the Jacobian if the Jacobian needs to be constructed.  Defaults to ",{"attributes":{},"tag":"code","children":["true"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["chunk_size"],"type":"node"},": Chunk size for forward-mode differentiation if full Jacobians are built (",{"attributes":{},"tag":"code","children":["autojacvec=false"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["autodiff=true"],"type":"node"},"). Default is ",{"attributes":{},"tag":"code","children":["0"],"type":"node"}," for automatic choice of chunk size."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["diff_type"],"type":"node"},": The method used by FiniteDiff.jl for constructing the Jacobian if the full Jacobian is required with ",{"attributes":{},"tag":"code","children":["autodiff=false"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["autojacvec"],"type":"node"},": Calculate the vector-Jacobian product (",{"attributes":{},"tag":"code","children":["J'*v"],"type":"node"},") via automatic differentiation with special seeding. The default is ",{"attributes":{},"tag":"code","children":["true"],"type":"node"},". The total set of choices are:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["false"],"type":"node"},": the Jacobian is constructed via FiniteDiff.jl"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["true"],"type":"node"},": the Jacobian is constructed via ForwardDiff.jl"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["TrackerVJP"],"type":"node"},": Uses Tracker.jl for the vjp."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["ZygoteVJP"],"type":"node"},": Uses Zygote.jl for the vjp."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["EnzymeVJP"],"type":"node"},": Uses Enzyme.jl for the vjp."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["ReverseDiffVJP(compile=false)"],"type":"node"},": Uses ReverseDiff.jl for the vjp. ",{"attributes":{},"tag":"code","children":["compile"],"type":"node"}," is a boolean for whether to precompile the tape, which should only be done if there are no branches (",{"attributes":{},"tag":"code","children":["if"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["while"],"type":"node"}," statements) in the ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," function."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["linsolve"],"type":"node"},": the linear solver used in the adjoint solve. Defaults to ",{"attributes":{},"tag":"code","children":["nothing"],"type":"node"},", which uses a polyalgorithm to attempt to automatically choose an efficient algorithm."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["For more details on the vjp choices, please consult the sensitivity algorithms documentation page or the docstrings of the vjp types."],"type":"node"},{"attributes":{},"tag":"h2","children":["References"],"type":"node"},{"attributes":{},"tag":"p","children":["Johnson, S. G., Notes on Adjoint Methods for 18.336, Online at http://math.mit.edu/stevenj/18.336/adjoint.pdf (2007)"],"type":"node"}],"type":"node"}],"type":"node"}