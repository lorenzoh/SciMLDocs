{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"DiffEqSensitivity/src/derivative_wrappers.jl","docid":"sourcefiles/DiffEqSensitivity/src/derivative_wrappers.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/quadrature_adjoint.jl","docid":"sourcefiles/DiffEqSensitivity/src/quadrature_adjoint.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/concrete_solve.jl","docid":"sourcefiles/DiffEqSensitivity/src/concrete_solve.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/adjoint_common.jl","docid":"sourcefiles/DiffEqSensitivity/src/adjoint_common.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/DiffEqSensitivity.jl","docid":"sourcefiles/DiffEqSensitivity/src/DiffEqSensitivity.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/sensitivity_algorithms.jl","docid":"sourcefiles/DiffEqSensitivity/src/sensitivity_algorithms.jl"}],"methods":[{"line":958,"file":"/Users/lorenz/.julia/packages/DiffEqSensitivity/GjhZ8/src/sensitivity_algorithms.jl","method_id":"DiffEqSensitivity.EnzymeVJP_1","symbol_id":"DiffEqSensitivity.EnzymeVJP","filedoc":"sourcefiles/DiffEqSensitivity/src/sensitivity_algorithms.jl","signature":"DiffEqSensitivity.EnzymeVJP()"}],"name":"EnzymeVJP","title":"EnzymeVJP","symbol_id":"DiffEqSensitivity.EnzymeVJP","public":true,"module_id":"DiffEqSensitivity"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["EnzymeVJP <: VJPChoice"],"type":"node"},{"attributes":{},"tag":"p","children":["Uses Enzyme.jl to compute vector-Jacobian products. Is the fastest VJP whenever applicable, though Enzyme.jl currently has low coverage over the Julia programming language, for example restricting the user's defined ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," function to not do things like require garbage collection or calls to BLAS/LAPACK. However, mutation is supported, meaning that in-place ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," with fully mutating non-allocating code will work with Enzyme (provided no high level calls to C like BLAS/LAPACK are used) and this will be the most efficient adjoint implementation."],"type":"node"},{"attributes":{},"tag":"h2","children":["Constructor"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/DiffEqSensitivity.EnzymeVJP"},"tag":"reference","children":["EnzymeVJP"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["compile"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"FALSE","children":["false"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}