{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"SciMLBase/src/problems/rode_problems.jl","docid":"sourcefiles/SciMLBase/src/problems/rode_problems.jl"},{"tag":"sourcefile","title":"SciMLBase/src/SciMLBase.jl","docid":"sourcefiles/SciMLBase/src/SciMLBase.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/quadrature_adjoint.jl","docid":"sourcefiles/DiffEqSensitivity/src/quadrature_adjoint.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/backsolve_adjoint.jl","docid":"sourcefiles/DiffEqSensitivity/src/backsolve_adjoint.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/adjoint_common.jl","docid":"sourcefiles/DiffEqSensitivity/src/adjoint_common.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/sensitivity_interface.jl","docid":"sourcefiles/DiffEqSensitivity/src/sensitivity_interface.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/interpolating_adjoint.jl","docid":"sourcefiles/DiffEqSensitivity/src/interpolating_adjoint.jl"}],"methods":[{"line":79,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/problems/rode_problems.jl","method_id":"SciMLBase.RODEProblem_1","symbol_id":"SciMLBase.RODEProblem","filedoc":"sourcefiles/SciMLBase/src/problems/rode_problems.jl","signature":"RODEProblem(f::RODEFunction, u0, tspan)"},{"line":79,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/problems/rode_problems.jl","method_id":"SciMLBase.RODEProblem_2","symbol_id":"SciMLBase.RODEProblem","filedoc":"sourcefiles/SciMLBase/src/problems/rode_problems.jl","signature":"RODEProblem(f::RODEFunction, u0, tspan, p; kwargs...)"},{"line":83,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/problems/rode_problems.jl","method_id":"SciMLBase.RODEProblem_3","symbol_id":"SciMLBase.RODEProblem","filedoc":"sourcefiles/SciMLBase/src/problems/rode_problems.jl","signature":"RODEProblem(f, u0, tspan)"},{"line":83,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/problems/rode_problems.jl","method_id":"SciMLBase.RODEProblem_4","symbol_id":"SciMLBase.RODEProblem","filedoc":"sourcefiles/SciMLBase/src/problems/rode_problems.jl","signature":"RODEProblem(f, u0, tspan, p; kwargs...)"}],"name":"RODEProblem","title":"RODEProblem","symbol_id":"SciMLBase.RODEProblem","public":true,"module_id":"SciMLBase"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["Defines a random ordinary differential equation (RODE) problem. Documentation Page: https://diffeq.sciml.ai/stable/types/rode_types/"],"type":"node"},{"attributes":{},"tag":"h2","children":["Mathematical Specification of a RODE Problem"],"type":"node"},{"attributes":{},"tag":"p","children":["To define a RODE Problem, you simply need to give the function ",{"attributes":{},"tag":"math","children":["f"],"type":"node"}," and the initial condition ",{"attributes":{},"tag":"math","children":["u_0"],"type":"node"}," which define an ODE:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\frac{du}{dt} = f(u,p,t,W(t))"],"type":"node"},{"attributes":{},"tag":"p","children":["where ",{"attributes":{},"tag":"code","children":["W(t)"],"type":"node"}," is a random process. ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," should be specified as ",{"attributes":{},"tag":"code","children":["f(u,p,t,W)"],"type":"node"}," (or in-place as ",{"attributes":{},"tag":"code","children":["f(du,u,p,t,W)"],"type":"node"},"), and ",{"attributes":{},"tag":"code","children":["u₀"],"type":"node"}," should be an AbstractArray (or number) whose geometry matches the desired geometry of ",{"attributes":{},"tag":"code","children":["u"],"type":"node"},". Note that we are not limited to numbers or vectors for ",{"attributes":{},"tag":"code","children":["u₀"],"type":"node"},"; one is allowed to provide ",{"attributes":{},"tag":"code","children":["u₀"],"type":"node"}," as arbitrary matrices / higher dimension tensors as well."],"type":"node"},{"attributes":{},"tag":"h3","children":["Constructors"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["RODEProblem(f::RODEFunction,u0,tspan,p=NullParameters();noise=WHITE_NOISE,rand_prototype=nothing,callback=nothing)"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["RODEProblem{isinplace}(f,u0,tspan,p=NullParameters();noise=WHITE_NOISE,rand_prototype=nothing,callback=nothing,mass_matrix=I)"],"type":"node"}," : Defines the RODE with the specified functions. The default noise is ",{"attributes":{},"tag":"code","children":["WHITE_NOISE"],"type":"node"},". ",{"attributes":{},"tag":"code","children":["isinplace"],"type":"node"}," optionally sets whether the function is inplace or not. This is determined automatically, but not inferred."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Parameters are optional, and if not given then a ",{"attributes":{},"tag":"code","children":["NullParameters()"],"type":"node"}," singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a ",{"attributes":{},"tag":"code","children":["callback"],"type":"node"}," in the problem, then that ",{"attributes":{},"tag":"code","children":["callback"],"type":"node"}," will be added in every solve call."],"type":"node"},{"attributes":{},"tag":"p","children":["For specifying Jacobians and mass matrices, see the [DiffEqFunctions](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," performance_overloads) page."],"type":"node"},{"attributes":{},"tag":"h3","children":["Fields"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["f"],"type":"node"},": The drift function in the SDE."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["u0"],"type":"node"},": The initial condition."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["tspan"],"type":"node"},": The timespan for the problem."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["p"],"type":"node"},": The optional parameters for the problem. Defaults to ",{"attributes":{},"tag":"code","children":["NullParameters"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["noise"],"type":"node"},": The noise process applied to the noise upon generation. Defaults to Gaussian white noise. For information on defining different noise processes, see [the noise process documentation page](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," noise_process)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["rand_prototype"],"type":"node"},": A prototype type instance for the noise vector. It defaults to ",{"attributes":{},"tag":"code","children":["nothing"],"type":"node"},", which means the problem should be interpreted as having a noise vector whose size matches ",{"attributes":{},"tag":"code","children":["u0"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["kwargs"],"type":"node"},": The keyword arguments passed onto the solves."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}