{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"SciMLBase/src/problems/dde_problems.jl","docid":"sourcefiles/SciMLBase/src/problems/dde_problems.jl"},{"tag":"sourcefile","title":"SciMLBase/src/SciMLBase.jl","docid":"sourcefiles/SciMLBase/src/SciMLBase.jl"}],"methods":[{"line":243,"file":"/home/runner/.julia/packages/SciMLBase/dYFnI/src/problems/dde_problems.jl","method_id":"SciMLBase.DDEProblem_1","symbol_id":"SciMLBase.DDEProblem","filedoc":"sourcefiles/SciMLBase/src/problems/dde_problems.jl","signature":"SciMLBase.DDEProblem(f::SciMLBase.AbstractDDEFunction, args...; kwargs...)"},{"line":240,"file":"/home/runner/.julia/packages/SciMLBase/dYFnI/src/problems/dde_problems.jl","method_id":"SciMLBase.DDEProblem_2","symbol_id":"SciMLBase.DDEProblem","filedoc":"sourcefiles/SciMLBase/src/problems/dde_problems.jl","signature":"SciMLBase.DDEProblem(f, args...; kwargs...)"}],"name":"DDEProblem","title":"DDEProblem","symbol_id":"SciMLBase.DDEProblem","public":true,"module_id":"SciMLBase"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["Defines a delay differential equation (DDE) problem. Documentation Page: https://diffeq.sciml.ai/stable/types/dde_types/"],"type":"node"},{"attributes":{},"tag":"h2","children":["Mathematical Specification of a DDE Problem"],"type":"node"},{"attributes":{},"tag":"p","children":["To define a DDE Problem, you simply need to give the function ",{"attributes":{},"tag":"math","children":["f"],"type":"node"},", the initial condition ",{"attributes":{},"tag":"math","children":["u_0"],"type":"node"}," at time point ",{"attributes":{},"tag":"math","children":["t_0"],"type":"node"},", and the history function ",{"attributes":{},"tag":"math","children":["h"],"type":"node"}," which together define a DDE:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\frac{du}{dt} = f(u,h,p,t) \\qquad (t \\geq t_0)"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["u(t_0) = u_0,"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["u(t) = h(t) \\qquad (t < t_0)."],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"math","children":["f"],"type":"node"}," should be specified as ",{"attributes":{},"tag":"code","children":["f(u, h, p, t)"],"type":"node"}," (or in-place as ",{"attributes":{},"tag":"code","children":["f(du, u, h, p, t)"],"type":"node"},"), ",{"attributes":{},"tag":"math","children":["u_0"],"type":"node"}," should be an AbstractArray (or number) whose geometry matches the desired geometry of ",{"attributes":{},"tag":"code","children":["u"],"type":"node"},", and ",{"attributes":{},"tag":"math","children":["h"],"type":"node"}," should be specified as described below. The history function ",{"attributes":{},"tag":"code","children":["h"],"type":"node"}," is accessed for all delayed values. Note that we are not limited to numbers or vectors for ",{"attributes":{},"tag":"math","children":["u_0"],"type":"node"},"; one is allowed to provide ",{"attributes":{},"tag":"math","children":["u_0"],"type":"node"}," as arbitrary matrices / higher dimension tensors as well."],"type":"node"},{"attributes":{},"tag":"h2","children":["Functional Forms of the History Function"],"type":"node"},{"attributes":{},"tag":"p","children":["The history function ",{"attributes":{},"tag":"code","children":["h"],"type":"node"}," can be called in the following ways:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["h(p, t)"],"type":"node"},": out-of-place calculation"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["h(out, p, t)"],"type":"node"},": in-place calculation"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["h(p, t, deriv::Type{Val{i}})"],"type":"node"},": out-of-place calculation of the ",{"attributes":{},"tag":"code","children":["i"],"type":"node"},"th derivative"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["h(out, p, t, deriv::Type{Val{i}})"],"type":"node"},": in-place calculation of the ",{"attributes":{},"tag":"code","children":["i"],"type":"node"},"th derivative"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["h(args...; idxs)"],"type":"node"},": calculation of ",{"attributes":{},"tag":"code","children":["h(args...)"],"type":"node"}," for indices ",{"attributes":{},"tag":"code","children":["idxs"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Note that a dispatch for the supplied history function of matching form is required for whichever function forms are used in the user derivative function ",{"attributes":{},"tag":"code","children":["f"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h2","children":["Declaring Lags"],"type":"node"},{"attributes":{},"tag":"p","children":["Lags are declared separately from their use. One can use any lag by simply using the interpolant of ",{"attributes":{},"tag":"code","children":["h"],"type":"node"}," at that point. However, one should use caution in order to achieve the best accuracy. When lags are declared, the solvers can more efficiently be more accurate and thus this is recommended."],"type":"node"},{"attributes":{},"tag":"h2","children":["Neutral and Retarded Delay Differential Equations"],"type":"node"},{"attributes":{},"tag":"p","children":["Note that the history function specification can be used to specify general retarded arguments, i.e. ",{"attributes":{},"tag":"code","children":["h(p,α(u,t))"],"type":"node"},". Neutral delay differential equations can be specified by using the ",{"attributes":{},"tag":"code","children":["deriv"],"type":"node"}," value in the history interpolation. For example, ",{"attributes":{},"tag":"code","children":["h(p,t-τ, Val{1})"],"type":"node"}," returns the first derivative of the history values at time ",{"attributes":{},"tag":"code","children":["t-τ"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["Note that algebraic equations can be specified by using a singular mass matrix."],"type":"node"},{"attributes":{},"tag":"h2","children":["Problem Type"],"type":"node"},{"attributes":{},"tag":"h3","children":["Constructors"],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["DDEProblem(f[, u0], h, tspan[, p]; <keyword arguments>)\nDDEProblem{isinplace}(f[, u0], h, tspan[, p]; <keyword arguments>)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Parameter ",{"attributes":{},"tag":"code","children":["isinplace"],"type":"node"}," optionally sets whether the function is inplace or not. This is determined automatically, but not inferred."],"type":"node"},{"attributes":{},"tag":"p","children":["Parameters are optional, and if not given then a ",{"attributes":{},"tag":"code","children":["NullParameters()"],"type":"node"}," singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a ",{"attributes":{},"tag":"code","children":["callback"],"type":"node"}," in the problem, then that ",{"attributes":{},"tag":"code","children":["callback"],"type":"node"}," will be added in every solve call."],"type":"node"},{"attributes":{},"tag":"p","children":["For specifying Jacobians and mass matrices, see the [DiffEqFunctions](",{"attributes":{},"tag":"citation","children":[],"type":"node"}," performance_overloads) page."],"type":"node"},{"attributes":{},"tag":"h3","children":["Arguments"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["f"],"type":"node"},": The function in the DDE."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["u0"],"type":"node"},": The initial condition. Defaults to the value ",{"attributes":{},"tag":"code","children":["h(p, first(tspan))"],"type":"node"}," of the history function evaluated at the initial time point."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["h"],"type":"node"},": The history function for the DDE before ",{"attributes":{},"tag":"code","children":["t0"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["tspan"],"type":"node"},": The timespan for the problem."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["p"],"type":"node"},": The parameters with which function ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," is called. Defaults to ",{"attributes":{},"tag":"code","children":["NullParameters"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["constant_lags"],"type":"node"},": A collection of constant lags used by the history function ",{"attributes":{},"tag":"code","children":["h"],"type":"node"},". Defaults to ",{"attributes":{},"tag":"code","children":["()"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["dependent_lags"],"type":"node"}," A tuple of functions ",{"attributes":{},"tag":"code","children":["(u, p, t) -> lag"],"type":"node"}," for the state-dependent lags used by the history function ",{"attributes":{},"tag":"code","children":["h"],"type":"node"},". Defaults to ",{"attributes":{},"tag":"code","children":["()"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["neutral"],"type":"node"},": If the DDE is neutral, i.e., if delays appear in derivative terms."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["order_discontinuity_t0"],"type":"node"},": The order of the discontinuity at the initial time point. Defaults to ",{"attributes":{},"tag":"code","children":["0"],"type":"node"}," if an initial condition ",{"attributes":{},"tag":"code","children":["u0"],"type":"node"}," is provided. Otherwise it is forced to be greater or equal than ",{"attributes":{},"tag":"code","children":["1"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["kwargs"],"type":"node"},": The keyword arguments passed onto the solves."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Dynamical Delay Differential Equations"],"type":"node"},{"attributes":{},"tag":"p","children":["Much like [Dynamical ODEs](",{"attributes":{},"tag":"citation","children":[],"type":"node"}," dynamical_prob), a Dynamical DDE is a Partitioned DDE of the form:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\frac{dv}{dt} = f_1(u,t,h) \\\\\n\\frac{du}{dt} = f_2(v,h) \\\\"],"type":"node"},{"attributes":{},"tag":"h3","children":["Constructors"],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["DynamicalDDEProblem(f1, f2[, v0, u0], h, tspan[, p]; <keyword arguments>)\nDynamicalDDEProblem{isinplace}(f1, f2[, v0, u0], h, tspan[, p]; <keyword arguments>)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Parameter ",{"attributes":{},"tag":"code","children":["isinplace"],"type":"node"}," optionally sets whether the function is inplace or not. This is determined automatically, but not inferred."],"type":"node"},{"attributes":{},"tag":"h3","children":["Arguments"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["f"],"type":"node"},": The function in the DDE."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["v0"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["u0"],"type":"node"},": The initial condition. Defaults to the values ",{"attributes":{},"tag":"code","children":["h(p, first(tspan))..."],"type":"node"}," of the history function evaluated at the initial time point."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["h"],"type":"node"},": The history function for the DDE before ",{"attributes":{},"tag":"code","children":["t0"],"type":"node"},". Must return an object with the indices 1 and 2, with the values of ",{"attributes":{},"tag":"code","children":["v"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["u"],"type":"node"}," respectively."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["tspan"],"type":"node"},": The timespan for the problem."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["p"],"type":"node"},": The parameters with which function ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," is called. Defaults to ",{"attributes":{},"tag":"code","children":["NullParameters"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["constant_lags"],"type":"node"},": A collection of constant lags used by the history function ",{"attributes":{},"tag":"code","children":["h"],"type":"node"},". Defaults to ",{"attributes":{},"tag":"code","children":["()"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["dependent_lags"],"type":"node"}," A tuple of functions ",{"attributes":{},"tag":"code","children":["(v, u, p, t) -> lag"],"type":"node"}," for the state-dependent lags used by the history function ",{"attributes":{},"tag":"code","children":["h"],"type":"node"},". Defaults to ",{"attributes":{},"tag":"code","children":["()"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["neutral"],"type":"node"},": If the DDE is neutral, i.e., if delays appear in derivative terms."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["order_discontinuity_t0"],"type":"node"},": The order of the discontinuity at the initial time point. Defaults to ",{"attributes":{},"tag":"code","children":["0"],"type":"node"}," if an initial condition ",{"attributes":{},"tag":"code","children":["u0"],"type":"node"}," is provided. Otherwise it is forced to be greater or equal than ",{"attributes":{},"tag":"code","children":["1"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["kwargs"],"type":"node"},": The keyword arguments passed onto the solves."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The for dynamical and second order DDEs, the history function will return an object with the indicies 1 and 2 defined, where ",{"attributes":{},"tag":"code","children":["h(p, t_prev)[1]"],"type":"node"}," is the value of ",{"attributes":{},"tag":"math","children":["f_2(v, u, h, p, t_{\\mathrm{prev}})"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["h(p, t_prev)[2]"],"type":"node"}," is the value of ",{"attributes":{},"tag":"math","children":["f_1(v, u, h, p, t_{\\mathrm{prev}})"],"type":"node"}," (this is for consistency with the ordering of the intitial conditions in the constructor). The supplied history function must also return such a 2-index object, which can be accomplished with a tuple ",{"attributes":{},"tag":"code","children":["(v,u)"],"type":"node"}," or vector ",{"attributes":{},"tag":"code","children":["[v,u]"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h2","children":["2nd Order Delay Differential Equations"],"type":"node"},{"attributes":{},"tag":"p","children":["To define a 2nd Order DDE Problem, you simply need to give the function ",{"attributes":{},"tag":"math","children":["f"],"type":"node"}," and the initial condition ",{"attributes":{},"tag":"math","children":["u_0"],"type":"node"}," which define an DDE:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["u'' = f(u',u,h,p,t)"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["f"],"type":"node"}," should be specified as ",{"attributes":{},"tag":"code","children":["f(du,u,p,t)"],"type":"node"}," (or in-place as ",{"attributes":{},"tag":"code","children":["f(ddu,du,u,p,t)"],"type":"node"},"), and ",{"attributes":{},"tag":"code","children":["u₀"],"type":"node"}," should be an AbstractArray (or number) whose geometry matches the desired geometry of ",{"attributes":{},"tag":"code","children":["u"],"type":"node"},". Note that we are not limited to numbers or vectors for ",{"attributes":{},"tag":"code","children":["u₀"],"type":"node"},"; one is allowed to provide ",{"attributes":{},"tag":"code","children":["u₀"],"type":"node"}," as arbitrary matrices / higher dimension tensors as well."],"type":"node"},{"attributes":{},"tag":"p","children":["From this form, a dynamical ODE:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["v' = f(v,u,h,p,t) \\\\\nu' = v \\\\"],"type":"node"},{"attributes":{},"tag":"h3","children":["Constructors"],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["SecondOrderDDEProblem(f, [, du0, u0], h, tspan[, p]; <keyword arguments>)\nSecondOrderDDEProblem{isinplace}(f, [, du0, u0], h, tspan[, p]; <keyword arguments>)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Parameter ",{"attributes":{},"tag":"code","children":["isinplace"],"type":"node"}," optionally sets whether the function is inplace or not. This is determined automatically, but not inferred."],"type":"node"},{"attributes":{},"tag":"h3","children":["Arguments"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["f"],"type":"node"},": The function in the DDE."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["du0"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["u0"],"type":"node"},": The initial condition. Defaults to the values ",{"attributes":{},"tag":"code","children":["h(p, first(tspan))..."],"type":"node"}," of the history function evaluated at the initial time point."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["h"],"type":"node"},": The history function for the DDE before ",{"attributes":{},"tag":"code","children":["t0"],"type":"node"},". Must return an object with the indices 1 and 2, with the values of ",{"attributes":{},"tag":"code","children":["v"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["u"],"type":"node"}," respectively."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["tspan"],"type":"node"},": The timespan for the problem."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["p"],"type":"node"},": The parameters with which function ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," is called. Defaults to ",{"attributes":{},"tag":"code","children":["NullParameters"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["constant_lags"],"type":"node"},": A collection of constant lags used by the history function ",{"attributes":{},"tag":"code","children":["h"],"type":"node"},". Defaults to ",{"attributes":{},"tag":"code","children":["()"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["dependent_lags"],"type":"node"}," A tuple of functions ",{"attributes":{},"tag":"code","children":["(v, u, p, t) -> lag"],"type":"node"}," for the state-dependent lags used by the history function ",{"attributes":{},"tag":"code","children":["h"],"type":"node"},". Defaults to ",{"attributes":{},"tag":"code","children":["()"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["neutral"],"type":"node"},": If the DDE is neutral, i.e., if delays appear in derivative terms."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["order_discontinuity_t0"],"type":"node"},": The order of the discontinuity at the initial time point. Defaults to ",{"attributes":{},"tag":"code","children":["0"],"type":"node"}," if an initial condition ",{"attributes":{},"tag":"code","children":["u0"],"type":"node"}," is provided. Otherwise it is forced to be greater or equal than ",{"attributes":{},"tag":"code","children":["1"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["kwargs"],"type":"node"},": The keyword arguments passed onto the solves."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["As above, the history function will return an object with indices 1 and 2, with the values of ",{"attributes":{},"tag":"code","children":["du"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["u"],"type":"node"}," respectively. The supplied history function must also match this return type, e.g. by returning a 2-element tuple or vector."],"type":"node"},{"attributes":{},"tag":"h2","children":["Example Problems"],"type":"node"},{"attributes":{},"tag":"p","children":["Example problems can be found in ",{"attributes":{"href":"https://github.com/JuliaDiffEq/DiffEqProblemLibrary.jl/tree/master/src/dde","title":""},"tag":"a","children":["DiffEqProblemLibrary.jl"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["To use a sample problem, such as ",{"attributes":{},"tag":"code","children":["prob_ode_linear"],"type":"node"},", you can do something like:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"COMMENT","children":["#] add DiffEqProblemLibrary"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"USING","children":[{"attributes":{},"tag":"USING","children":["using"],"type":"node"},{"attributes":{},"tag":"DOT","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["DiffEqProblemLibrary"],"type":"node"},{"attributes":{},"tag":"DOT","children":["."],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["ODEProblemLibrary"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"COMMENT","children":["# load problems"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"DOT","children":[{"attributes":{},"tag":"IDENTIFIER","children":["ODEProblemLibrary"],"type":"node"},{"attributes":{},"tag":"DOT","children":["."],"type":"node"},{"attributes":{},"tag":"QUOTE","children":[{"attributes":{},"tag":"IDENTIFIER","children":["importodeproblems"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["prob"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"DOT","children":[{"attributes":{},"tag":"IDENTIFIER","children":["ODEProblemLibrary"],"type":"node"},{"attributes":{},"tag":"DOT","children":["."],"type":"node"},{"attributes":{},"tag":"QUOTE","children":[{"attributes":{},"tag":"IDENTIFIER","children":["prob_ode_linear"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["sol"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["solve"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["prob"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}