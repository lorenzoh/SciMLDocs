{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"DiffEqFlux/src/hnn.jl","docid":"sourcefiles/DiffEqFlux/src/hnn.jl"},{"tag":"document","title":"DiffEqSensitivity: Automatic Differentiation and Adjoints for (Differential) Equation Solvers","docid":"DiffEqSensitivity/index.md"},{"tag":"sourcefile","title":"DiffEqFlux/src/neural_de.jl","docid":"sourcefiles/DiffEqFlux/src/neural_de.jl"},{"tag":"document","title":"[Solving Optimal Control Problems with Universal Differential Equations]( optcontrol)","docid":"DiffEqSensitivity/optimal_control/optimal_control.md"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/concrete_solve.jl","docid":"sourcefiles/DiffEqSensitivity/src/concrete_solve.jl"},{"tag":"document","title":"Universal Differential Equations for Neural Feedback Control","docid":"DiffEqSensitivity/optimal_control/feedback_control.md"},{"tag":"sourcefile","title":"DiffEqFlux/src/ffjord.jl","docid":"sourcefiles/DiffEqFlux/src/ffjord.jl"},{"tag":"document","title":"Benchmarks","docid":"DiffEqSensitivity/Benchmark.md"},{"tag":"documentation","title":"NeuralODEMM","docid":"references/DiffEqFlux.NeuralODEMM"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/DiffEqSensitivity.jl","docid":"sourcefiles/DiffEqSensitivity/src/DiffEqSensitivity.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/sensitivity_algorithms.jl","docid":"sourcefiles/DiffEqSensitivity/src/sensitivity_algorithms.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/sensitivity_interface.jl","docid":"sourcefiles/DiffEqSensitivity/src/sensitivity_interface.jl"},{"tag":"documentation","title":"adjoint_sensitivities","docid":"references/DiffEqSensitivity.adjoint_sensitivities"},{"tag":"document","title":"Simultaneous Fitting of Multiple Neural Networks","docid":"DiffEqSensitivity/training_tips/multiple_nn.md"},{"tag":"documentation","title":"NeuralODE","docid":"references/DiffEqFlux.NeuralODE"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/interpolating_adjoint.jl","docid":"sourcefiles/DiffEqSensitivity/src/interpolating_adjoint.jl"}],"methods":[{"line":362,"file":"/Users/lorenz/.julia/packages/DiffEqSensitivity/GjhZ8/src/sensitivity_algorithms.jl","method_id":"DiffEqSensitivity.InterpolatingAdjoint_1","symbol_id":"DiffEqSensitivity.InterpolatingAdjoint","filedoc":"sourcefiles/DiffEqSensitivity/src/sensitivity_algorithms.jl","signature":"DiffEqSensitivity.InterpolatingAdjoint(; chunk_size, autodiff, diff_type, autojacvec, checkpointing, noise, noisemixing)"}],"name":"InterpolatingAdjoint","title":"InterpolatingAdjoint","symbol_id":"DiffEqSensitivity.InterpolatingAdjoint","public":true,"module_id":"DiffEqSensitivity"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["InterpolatingAdjoint <: AbstractAdjointSensitivityAlgorithm"],"type":"node"},{"attributes":{},"tag":"p","children":["An implementation of adjoint sensitivity analysis which uses the interpolation of the forward solution for the reverse solve vector-Jacobian products. By default it requires a dense solution of the forward pass and will internally ignore saving arguments during the gradient calculation. When checkpointing is enabled it will only require the memory to interpolate between checkpoints."],"type":"node"},{"attributes":{},"tag":"h2","children":["Constructor"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":["function InterpolatingAdjoint(;chunk_size=0,autodiff=true,\n                               diff_type=Val{:central},\n                               autojacvec=autodiff,\n                               checkpointing=false, noise=true, noisemixing=false)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Keyword Arguments"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["autodiff"],"type":"node"},": Use automatic differentiation for constructing the Jacobian if the Jacobian needs to be constructed.  Defaults to ",{"attributes":{},"tag":"code","children":["true"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["chunk_size"],"type":"node"},": Chunk size for forward-mode differentiation if full Jacobians are built (",{"attributes":{},"tag":"code","children":["autojacvec=false"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["autodiff=true"],"type":"node"},"). Default is ",{"attributes":{},"tag":"code","children":["0"],"type":"node"}," for automatic choice of chunk size."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["diff_type"],"type":"node"},": The method used by FiniteDiff.jl for constructing the Jacobian if the full Jacobian is required with ",{"attributes":{},"tag":"code","children":["autodiff=false"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["autojacvec"],"type":"node"},": Calculate the vector-Jacobian product (",{"attributes":{},"tag":"code","children":["J'*v"],"type":"node"},") via automatic differentiation with special seeding. The default is ",{"attributes":{},"tag":"code","children":["true"],"type":"node"},". The total set of choices are:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["false"],"type":"node"},": the Jacobian is constructed via FiniteDiff.jl"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["true"],"type":"node"},": the Jacobian is constructed via ForwardDiff.jl"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["TrackerVJP"],"type":"node"},": Uses Tracker.jl for the vjp."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["ZygoteVJP"],"type":"node"},": Uses Zygote.jl for the vjp."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["EnzymeVJP"],"type":"node"},": Uses Enzyme.jl for the vjp."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["ReverseDiffVJP(compile=false)"],"type":"node"},": Uses ReverseDiff.jl for the vjp. ",{"attributes":{},"tag":"code","children":["compile"],"type":"node"}," is a boolean for whether to precompile the tape, which should only be done if there are no branches (",{"attributes":{},"tag":"code","children":["if"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["while"],"type":"node"}," statements) in the ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," function."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["checkpointing"],"type":"node"},": whether checkpointing is enabled for the reverse pass. Defaults to ",{"attributes":{},"tag":"code","children":["true"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["noise"],"type":"node"},": Calculate the vector-Jacobian product (",{"attributes":{},"tag":"code","children":["J'*v"],"type":"node"},") of the diffusion term of an SDE via automatic differentiation with special seeding. The default is ",{"attributes":{},"tag":"code","children":["true"],"type":"node"},". The total set of choices are:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["false"],"type":"node"},": the Jacobian is constructed via FiniteDiff.jl"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["true"],"type":"node"},": the Jacobian is constructed via ForwardDiff.jl"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["DiffEqSensitivity.ZygoteNoise()"],"type":"node"},": Uses Zygote.jl for the vjp."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["DiffEqSensitivity.ReverseDiffNoise(compile=false)"],"type":"node"},": Uses ReverseDiff.jl for the vjp. ",{"attributes":{},"tag":"code","children":["compile"],"type":"node"}," is a boolean for whether to precompile the tape, which should only be done if there are no branches (",{"attributes":{},"tag":"code","children":["if"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["while"],"type":"node"}," statements) in the ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," function."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["noisemixing"],"type":"node"},": Handle noise processes that are not of the form ",{"attributes":{},"tag":"code","children":["du[i] = f(u[i])"],"type":"node"},". For example, to compute the sensitivities of an SDE with diagonal diffusion"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"FUNCTION","children":[{"attributes":{},"tag":"FUNCTION","children":["function"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["g_mixing!"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["du"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["u"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["t"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"BLOCK","children":[{"attributes":{},"tag":"NEWLINE_WS","children":["\n  "],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["du"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["1"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["3"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"STAR","children":["*"],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["u"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["1"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"PLUS","children":["+"],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["4"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"STAR","children":["*"],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["u"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["2"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n  "],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["du"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["2"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["3"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"STAR","children":["*"],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["u"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["1"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"PLUS","children":["+"],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["4"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"STAR","children":["*"],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["u"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["2"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n  "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"END","children":["end"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["correctly, ",{"attributes":{},"tag":"code","children":["noisemixing=true"],"type":"node"}," must be enabled. The default is ",{"attributes":{},"tag":"code","children":["false"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["For more details on the vjp choices, please consult the sensitivity algorithms documentation page or the docstrings of the vjp types."],"type":"node"},{"attributes":{},"tag":"h2","children":["Checkpointing"],"type":"node"},{"attributes":{},"tag":"p","children":["To reduce the memory usage of the reverse pass, ",{"attributes":{},"tag":"code","children":["InterpolatingAdjoint"],"type":"node"}," includes a checkpointing feature. If ",{"attributes":{},"tag":"code","children":["sol"],"type":"node"}," is ",{"attributes":{},"tag":"code","children":["dense"],"type":"node"},", checkpointing is ignored and the continuous solution is used for calculating ",{"attributes":{},"tag":"code","children":["u(t)"],"type":"node"}," at arbitrary time points. If ",{"attributes":{},"tag":"code","children":["checkpointing=true"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["sol"],"type":"node"}," is not ",{"attributes":{},"tag":"code","children":["dense"],"type":"node"},", then dense intervals between ",{"attributes":{},"tag":"code","children":["sol.t[i]"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["sol.t[i+1]"],"type":"node"}," are reconstructed on-demand for calculating ",{"attributes":{},"tag":"code","children":["u(t)"],"type":"node"}," at arbitrary time points. This reduces the total memory requirement to only the cost of holding the dense solution over the largest time interval (in terms of number of required steps). The total compute cost is no more than double the original forward compute cost."],"type":"node"},{"attributes":{},"tag":"h2","children":["SciMLProblem Support"],"type":"node"},{"attributes":{},"tag":"p","children":["This ",{"attributes":{},"tag":"code","children":["sensealg"],"type":"node"}," only supports ",{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"},"s, ",{"attributes":{},"tag":"code","children":["SDEProblem"],"type":"node"},"s, and ",{"attributes":{},"tag":"code","children":["RODEProblem"],"type":"node"},"s. This ",{"attributes":{},"tag":"code","children":["sensealg"],"type":"node"}," supports callbacks (events)."],"type":"node"},{"attributes":{},"tag":"h2","children":["References"],"type":"node"},{"attributes":{},"tag":"p","children":["Rackauckas, C. and Ma, Y. and Martensen, J. and Warner, C. and Zubov, K. and Supekar, R. and Skinner, D. and Ramadhana, A. and Edelman, A., Universal Differential Equations for Scientific Machine Learning,\tarXiv:2001.04385"],"type":"node"},{"attributes":{},"tag":"p","children":["Hindmarsh, A. C. and Brown, P. N. and Grant, K. E. and Lee, S. L. and Serban, R. and Shumaker, D. E. and Woodward, C. S., SUNDIALS: Suite of nonlinear and differential/algebraic equation solvers, ACM Transactions on Mathematical Software (TOMS), 31, pp:363–396 (2005)"],"type":"node"},{"attributes":{},"tag":"p","children":["Rackauckas, C. and Ma, Y. and Dixit, V. and Guo, X. and Innes, M. and Revels, J. and Nyberg, J. and Ivaturi, V., A comparison of automatic differentiation and continuous sensitivity analysis for derivatives of differential equation solutions, arXiv:1812.01892"],"type":"node"}],"type":"node"}],"type":"node"}