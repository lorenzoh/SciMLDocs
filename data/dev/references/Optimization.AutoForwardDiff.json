{"attributes":{"kind":"struct","backlinks":[{"tag":"document","title":"NLopt.jl","docid":"Optimization/optimization_packages/nlopt.md"},{"tag":"document","title":"Basic usage","docid":"Optimization/tutorials/intro.md"},{"tag":"document","title":"Rosenbrock function examples","docid":"Optimization/tutorials/rosenbrock.md"},{"tag":"document","title":"[Optim.jl]( optim)","docid":"Optimization/optimization_packages/optim.md"},{"tag":"sourcefile","title":"DiffEqFlux/src/train.jl","docid":"sourcefiles/DiffEqFlux/src/train.jl"},{"tag":"document","title":"Handling Divergent and Unstable Trajectories","docid":"DiffEqSensitivity/training_tips/divergence.md"},{"tag":"sourcefile","title":"Optimization/src/function/forwarddiff.jl","docid":"sourcefiles/Optimization/src/function/forwarddiff.jl"},{"tag":"document","title":"MathOptInterface.jl","docid":"Optimization/optimization_packages/mathoptinterface.md"}],"methods":[{"line":30,"file":"/Users/lorenz/.julia/packages/Optimization/RUgSr/src/function/forwarddiff.jl","method_id":"Optimization.AutoForwardDiff_1","symbol_id":"Optimization.AutoForwardDiff","filedoc":"sourcefiles/Optimization/src/function/forwarddiff.jl","signature":"Optimization.AutoForwardDiff()"},{"line":30,"file":"/Users/lorenz/.julia/packages/Optimization/RUgSr/src/function/forwarddiff.jl","method_id":"Optimization.AutoForwardDiff_2","symbol_id":"Optimization.AutoForwardDiff","filedoc":"sourcefiles/Optimization/src/function/forwarddiff.jl","signature":"Optimization.AutoForwardDiff(chunksize)"}],"name":"AutoForwardDiff","title":"AutoForwardDiff","symbol_id":"Optimization.AutoForwardDiff","public":false,"module_id":"Optimization"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["AutoForwardDiff <: AbstractADType"],"type":"node"},{"attributes":{},"tag":"p","children":["An AbstractADType choice for use in OptimizationFunction for automatically generating the unspecified derivative functions. Usage:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/SciMLBase.OptimizationFunction"},"tag":"reference","children":["OptimizationFunction"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["f"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/Optimization.AutoForwardDiff"},"tag":"reference","children":["AutoForwardDiff"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"PARAMETERS","children":[{"attributes":{},"tag":"SEMICOLON","children":[";"],"type":"node"},{"attributes":{},"tag":"DDDOT","children":[{"attributes":{},"tag":"IDENTIFIER","children":["kwargs"],"type":"node"},{"attributes":{},"tag":"DDDOT","children":["..."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["This uses the ",{"attributes":{"href":"https://github.com/JuliaDiff/ForwardDiff.jl","title":""},"tag":"a","children":["ForwardDiff.jl"],"type":"node"}," package. It is the fastest choice for small systems, especially with heavy scalar interactions. It is easy to use and compatible with most pure is Julia functions which have loose type restrictions. However, because it's forward-mode, it scales poorly in comparison to other AD choices. Hessian construction is suboptimal as it uses the forward-over-forward approach."],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Compatible with GPUs"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Compatible with Hessian-based optimization"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Compatible with Hv-based optimization"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Compatible with constraints"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Note that only the unspecified derivative functions are defined. For example, if a ",{"attributes":{},"tag":"code","children":["hess"],"type":"node"}," function is supplied to the ",{"attributes":{},"tag":"code","children":["OptimizationFunction"],"type":"node"},", then the Hessian is not defined via ForwardDiff."],"type":"node"}],"type":"node"}],"type":"node"}