{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/DiffEqSensitivity/GjhZ8/docs/src/index.md","title":"DiffEqSensitivity: Automatic Differentiation and Adjoints for (Differential) Equation Solvers"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["DiffEqSensitivity: Automatic Differentiation and Adjoints for (Differential) Equation Solvers"],"type":"node"},{"attributes":{},"tag":"p","children":["DiffEqSensitivity.jl is the automatic differentiation and adjoints system for the SciML ecosystem. Also known as local sensitivity analysis, these methods allow for calculation of fast derivatives of SciML problem types which are commonly used to analyze model sensitivities, callibrate models to data, train neural ODEs, perform automated model discovery via universal differential equations, and more. SciMLSensitivity.jl is a high level interface that pulls together all of the tools with heuristics and helper functions to make solving inverse problems and inferring models as easy as possible without losing efficiency."],"type":"node"},{"attributes":{},"tag":"p","children":["Thus, what DiffEqSensitivity.jl provides is:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Automatic differentiation overloads for improving the performance and flexibility of AD calls over ",{"attributes":{},"tag":"code","children":["solve"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["A bunch of tutorials, documentation, and test cases for this combination with parameter estimation (data fitting / model calibration), neural network libraries and GPUs."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{"class":"note"},"tag":"admonition","children":[{"attributes":{},"tag":"admonitiontitle","children":["Note"],"type":"node"},{"attributes":{},"tag":"admonitionbody","children":[{"attributes":{},"tag":"p","children":["This documentation assumes familiarity with the solver packages for the respective problem types. If one is not familiar with the solver packages, please consult the documentation for pieces like ",{"attributes":{"href":"https://diffeq.sciml.ai/stable/","title":""},"tag":"a","children":["DifferentialEquations.jl"],"type":"node"},", ",{"attributes":{"href":"https://nonlinearsolve.sciml.ai/dev/","title":""},"tag":"a","children":["NonlinearSolve.jl"],"type":"node"},", ",{"attributes":{"href":"http://linearsolve.sciml.ai/dev/","title":""},"tag":"a","children":["LinearSolve.jl"],"type":"node"},", etc. first."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["High Level Interface: ",{"attributes":{},"tag":"code","children":["sensealg"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The highest level interface is provided by the function ",{"attributes":{},"tag":"code","children":["solve"],"type":"node"},":"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/CommonSolve.solve"},"tag":"reference","children":["solve"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["prob"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"DDDOT","children":[{"attributes":{},"tag":"IDENTIFIER","children":["args"],"type":"node"},{"attributes":{},"tag":"DDDOT","children":["..."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"PARAMETERS","children":[{"attributes":{},"tag":"SEMICOLON","children":[";"],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["sensealg"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/DiffEqSensitivity.InterpolatingAdjoint"},"tag":"reference","children":["InterpolatingAdjoint"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n      "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["checkpoints"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"DOT","children":[{"attributes":{},"tag":"IDENTIFIER","children":["sol"],"type":"node"},{"attributes":{},"tag":"DOT","children":["."],"type":"node"},{"attributes":{},"tag":"QUOTE","children":[{"attributes":{},"tag":"IDENTIFIER","children":["t"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"DDDOT","children":[{"attributes":{},"tag":"IDENTIFIER","children":["kwargs"],"type":"node"},{"attributes":{},"tag":"DDDOT","children":["..."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["solve"],"type":"node"}," is fully compatible with automatic differentiation libraries like:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://github.com/FluxML/Zygote.jl","title":""},"tag":"a","children":["Zygote.jl"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://github.com/JuliaDiff/ReverseDiff.jl","title":""},"tag":"a","children":["ReverseDiff.jl"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://github.com/FluxML/Tracker.jl","title":""},"tag":"a","children":["Tracker.jl"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://github.com/JuliaDiff/ForwardDiff.jl","title":""},"tag":"a","children":["ForwardDiff.jl"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["and will automatically replace any calculations of the solution's derivative with a fast method. The keyword argument ",{"attributes":{},"tag":"code","children":["sensealg"],"type":"node"}," controls the dispatch to the ",{"attributes":{},"tag":"code","children":["AbstractSensitivityAlgorithm"],"type":"node"}," used for the sensitivity calculation. Note that ",{"attributes":{},"tag":"code","children":["solve"],"type":"node"}," in an AD context does not allow higher order interpolations unless ",{"attributes":{},"tag":"code","children":["sensealg=DiffEqBase.SensitivityADPassThrough()"],"type":"node"}," is used, i.e. going back to the AD mechanism."],"type":"node"},{"attributes":{"class":"note"},"tag":"admonition","children":[{"attributes":{},"tag":"admonitiontitle","children":["Note"],"type":"node"},{"attributes":{},"tag":"admonitionbody","children":[{"attributes":{},"tag":"p","children":["The behavior of ForwardDiff.jl is different from the other automatic differentiation libraries mentioned above. The ",{"attributes":{},"tag":"code","children":["sensealg"],"type":"node"}," keyword is ignored. Instead, the differential equations are solved using ",{"attributes":{},"tag":"code","children":["Dual"],"type":"node"}," numbers for ",{"attributes":{},"tag":"code","children":["u0"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["p"],"type":"node"},". If only ",{"attributes":{},"tag":"code","children":["p"],"type":"node"}," is perturbed in the sensitivity analysis, but not ",{"attributes":{},"tag":"code","children":["u0"],"type":"node"},", the state is still implemented as a ",{"attributes":{},"tag":"code","children":["Dual"],"type":"node"}," number. ForwardDiff.jl will thus not dispatch into continuous forward nor adjoint sensitivity analysis even if a ",{"attributes":{},"tag":"code","children":["sensealg"],"type":"node"}," is provided."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Equation Scope"],"type":"node"},{"attributes":{},"tag":"p","children":["SciMLSensitivity.jl supports all of the equation types of the ",{"attributes":{"href":"https://scimlbase.sciml.ai/dev/","title":""},"tag":"a","children":["SciML Common Interface"],"type":"node"},", extending the problem types by adding overloads for automatic differentiation to improve the performance and flexibility of the differentiation system. This includes:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Linear systems (",{"attributes":{},"tag":"code","children":["LinearProblem"],"type":"node"},")"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Direct methods for dense and sparse"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Iterative solvers with preconditioning"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Nonlinear Systems (",{"attributes":{},"tag":"code","children":["NonlinearProblem"],"type":"node"},")"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Systems of nonlinear equations"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Scalar bracketing systems"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Integrals (quadrature) (",{"attributes":{},"tag":"code","children":["QuadratureProblem"],"type":"node"},")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Differential Equations"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Discrete equations (function maps, discrete stochastic (Gillespie/Markov) simulations) (",{"attributes":{},"tag":"code","children":["DiscreteProblem"],"type":"node"},")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Ordinary differential equations (ODEs) (",{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"},")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Split and Partitioned ODEs (Symplectic integrators, IMEX Methods) (",{"attributes":{},"tag":"code","children":["SplitODEProblem"],"type":"node"},")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Stochastic ordinary differential equations (SODEs or SDEs) (",{"attributes":{},"tag":"code","children":["SDEProblem"],"type":"node"},")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Stochastic differential-algebraic equations (SDAEs) (",{"attributes":{},"tag":"code","children":["SDEProblem"],"type":"node"}," with mass matrices)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Random differential equations (RODEs or RDEs) (",{"attributes":{},"tag":"code","children":["RODEProblem"],"type":"node"},")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Differential algebraic equations (DAEs) (",{"attributes":{},"tag":"code","children":["DAEProblem"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"}," with mass matrices)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Delay differential equations (DDEs) (",{"attributes":{},"tag":"code","children":["DDEProblem"],"type":"node"},")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Neutral, retarded, and algebraic delay differential equations (NDDEs, RDDEs, and DDAEs)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Stochastic delay differential equations (SDDEs) (",{"attributes":{},"tag":"code","children":["SDDEProblem"],"type":"node"},")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Experimental support for stochastic neutral, retarded, and algebraic delay differential equations (SNDDEs, SRDDEs, and SDDAEs)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Mixed discrete and continuous equations (Hybrid Equations, Jump Diffusions) (",{"attributes":{},"tag":"code","children":["DEProblem"],"type":"node"},"s with callbacks)"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Optimization (",{"attributes":{},"tag":"code","children":["OptimizationProblem"],"type":"node"},")"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Nonlinear (constrained) optimization"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["(Stochastic/Delay/Differential-Algebraic) Partial Differential Equations (",{"attributes":{},"tag":"code","children":["PDESystem"],"type":"node"},")"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Finite difference and finite volume methods"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Interfaces to finite element methods"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Physics-Informed Neural Networks (PINNs)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Integro-Differential Equations"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Fractional Differential Equations"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["SciMLSensitivity and Universal Differential Equations"],"type":"node"},{"attributes":{},"tag":"p","children":["SciMLSensitivity is for universal differential equations, where these can include delays, physical constraints, stochasticity, events, and all other kinds of interesting behavior that shows up in scientific simulations. Neural networks can be all or part of the model. They can be around the differential equation, in the cost function, or inside of the differential equation. Neural networks representing unknown portions of the model or functions can go anywhere you have uncertainty in the form of the scientific simulator. Forward sensitivity and adjoint equations are automatically generated with checkpointing and stabilization to ensure it works for large stiff equations, while specializations on static objects allows for high efficiency on small equations. For an overview of the topic with applications, consult the paper ",{"attributes":{"href":"https://arxiv.org/abs/2001.04385","title":""},"tag":"a","children":["Universal Differential Equations for Scientific Machine"," ","Learning"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["You can efficiently use the package for:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Parameter estimation of scientific models (ODEs, SDEs, DDEs, DAEs, etc.)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Neural ODEs, Neural SDE, Neural DAEs, Neural DDEs, etc."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Nonlinear optimal control, including training neural controllers"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["(Stiff) universal ordinary differential equations (universal ODEs)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Universal stochastic differential equations (universal SDEs)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Universal delay differential equations (universal DDEs)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Universal partial differential equations (universal PDEs)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Universal jump stochastic differential equations (universal jump diffusions)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Hybrid universal differential equations (universal DEs with event handling)"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["with high order, adaptive, implicit, GPU-accelerated, Newton-Krylov, etc. methods. For examples, please refer to ",{"attributes":{"href":"https://julialang.org/blog/2019/01/fluxdiffeq","title":""},"tag":"a","children":["the DiffEqFlux release blog"," ","post"],"type":"node"}," (which we try to keep updated for changes to the libraries). Additional demonstrations, like neural PDEs and neural jump SDEs, can be found ",{"attributes":{"href":"http://www.stochasticlifestyle.com/neural-jump-sdes-jump-diffusions-and-neural-pdes/","title":""},"tag":"a","children":["at this blog"," ","post"],"type":"node"}," (among many others!). All of these features are only part of the advantage, as this library [routinely benchmarks orders of magnitude faster than competing libraries like torchdiffeq](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," Benchmarks). Use with GPUs is highly optimized by ",{"attributes":{"href":"https://www.stochasticlifestyle.com/solving-systems-stochastic-pdes-using-gpus-julia/","title":""},"tag":"a","children":["recompiling the solvers to GPUs to remove all CPU-GPU data transfers"],"type":"node"},", while use with CPUs uses specialized kernels for accelerating differential equation solves."],"type":"node"},{"attributes":{},"tag":"p","children":["Many different training techniques are supported by this package, including:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Optimize-then-discretize (backsolve adjoints, checkpointed adjoints, quadrature adjoints)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Discretize-then-optimize (forward and reverse mode discrete sensitivity analysis)"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["This is a generalization of ",{"attributes":{"href":"https://arxiv.org/pdf/1902.10298.pdf","title":""},"tag":"a","children":["ANODE"],"type":"node"}," and ",{"attributes":{"href":"https://arxiv.org/pdf/1906.04596.pdf","title":""},"tag":"a","children":["ANODEv2"],"type":"node"}," to all ",{"attributes":{"href":"https://diffeq.sciml.ai/latest/solvers/ode_solve/","title":""},"tag":"a","children":["DifferentialEquations.jl ODE solvers"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Hybrid approaches (adaptive time stepping + AD for adaptive discretize-then-optimize)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["O(1) memory backprop of ODEs via BacksolveAdjoint, and Virtual Brownian Trees for O(1) backprop of SDEs"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["[Continuous adjoints for integral loss functions](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," continuous_loss)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Probabilistic programming and variational inference on ODEs/SDEs/DAEs/DDEs/hybrid equations etc. is provided by integration with ",{"attributes":{"href":"https://turing.ml/dev/","title":""},"tag":"a","children":["Turing.jl"],"type":"node"}," and ",{"attributes":{"href":"https://github.com/probcomp/Gen.jl","title":""},"tag":"a","children":["Gen.jl"],"type":"node"},". Reproduce ",{"attributes":{"href":"https://arxiv.org/abs/2001.01328","title":""},"tag":"a","children":["variational loss functions"],"type":"node"}," by plugging ",{"attributes":{"href":"https://turing.ml/dev/tutorials/9-variationalinference/","title":""},"tag":"a","children":["composible libraries together"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["all while mixing forward mode and reverse mode approaches as appropriate for the most speed. For more details on the adjoint sensitivity analysis methods for computing fast gradients, see the [adjoints details page](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," sensitivity_diffeq)."],"type":"node"},{"attributes":{},"tag":"p","children":["With this package, you can explore various ways to integrate the two methodologies:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Neural networks can be defined where the “activations” are nonlinear functions described by differential equations"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Neural networks can be defined where some layers are ODE solves"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["ODEs can be defined where some terms are neural networks"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Cost functions on ODEs can define neural networks"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Note on Modularity and Composability with Solvers"],"type":"node"},{"attributes":{},"tag":"p","children":["Note that DiffEqSensitivity.jl purely built on composable and modular infrastructure. DiffEqSensitivity provides high level helper functions and documentation for the user, but the code generation stack is modular and composes in many different ways. For example, one can use and swap out the ODE solver between any common interface compatible library, like:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Sundials.jl"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["OrdinaryDiffEq.jl"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["LSODA.jl"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://github.com/mikelehu/IRKGaussLegendre.jl","title":""},"tag":"a","children":["IRKGaussLegendre.jl"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://github.com/SciML/SciPyDiffEq.jl","title":""},"tag":"a","children":["SciPyDiffEq.jl"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://diffeq.sciml.ai/stable/solvers/ode_solve/","title":""},"tag":"a","children":["... etc. many other choices!"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["In addition, due to the composability of the system, none of the components are directly tied to the Flux.jl machine learning framework. For example, you can ",{"attributes":{"href":"https://youtu.be/n2MwJ1guGVQ?t=284","title":""},"tag":"a","children":["use DiffEqSensitivity.jl"," ","to generate TensorFlow graphs and train the neural network with TensorFlow.jl"],"type":"node"},", ",{"attributes":{"href":"https://github.com/FluxML/Torch.jl","title":""},"tag":"a","children":["use PyTorch arrays via Torch.jl"],"type":"node"},", and more all with single line code changes by utilizing the underlying code generation. The tutorials shown here are thus mostly a guide on how to use the ecosystem as a whole, only showing a small snippet of the possible ways to compose the thousands of differentiable libraries together! Swap out ODEs for SDEs, DDEs, DAEs, etc., put quadrature libraries or ",{"attributes":{"href":"https://github.com/mcabbott/Tullio.jl","title":""},"tag":"a","children":["Tullio.jl"],"type":"node"}," in the loss function, the world is your oyster!"],"type":"node"},{"attributes":{},"tag":"p","children":["As a proof of composability, note that the implementation of Bayesian neural ODEs required zero code changes to the library, and instead just relied on the composability with other Julia packages."],"type":"node"},{"attributes":{},"tag":"h2","children":["Citation"],"type":"node"},{"attributes":{},"tag":"p","children":["If you use DiffEqSensitivity.jl or are influenced by its ideas, please cite:"],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["@article{rackauckas2020universal,\n  title={Universal differential equations for scientific machine learning},\n  author={Rackauckas, Christopher and Ma, Yingbo and Martensen, Julius and Warner, Collin and Zubov, Kirill and Supekar, Rohit and Skinner, Dominic and Ramadhan, Ali},\n  journal={arXiv preprint arXiv:2001.04385},\n  year={2020}\n}\n"],"type":"node"}],"type":"node"}],"type":"node"}