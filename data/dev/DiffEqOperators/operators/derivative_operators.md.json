{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/DiffEqOperators/NWEwW/docs/src/operators/derivative_operators.md","title":"Derivative Operators"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Derivative Operators"],"type":"node"},{"attributes":{},"tag":"p","children":["As shown in the figure, the operators act on a set of samples ",{"attributes":{},"tag":"code","children":["f_j = f(x_j)"],"type":"node"}," for a function ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," at a grid of points ",{"attributes":{},"tag":"code","children":["x_j"],"type":"node"},". The grid has ",{"attributes":{},"tag":"code","children":["n"],"type":"node"}," interior points at ",{"attributes":{},"tag":"code","children":["x_j = jh"],"type":"node"}," for ",{"attributes":{},"tag":"code","children":["j = 1"],"type":"node"}," to ",{"attributes":{},"tag":"code","children":["n"],"type":"node"},", and 2 boundary points at ",{"attributes":{},"tag":"code","children":["x_0 = 0"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["x_{n+1} = (n+1) h"],"type":"node"},". The input to the numerical operators is a vector ",{"attributes":{},"tag":"code","children":["u = [f_1, f_2, …, f_N]"],"type":"node"},", and they output a vector of sampled derivatives ",{"attributes":{},"tag":"code","children":["du ≈ [f'(x_1), f'(x_2), …, f'(x_N)]"],"type":"node"},", or a higher-order derivative as requested."],"type":"node"},{"attributes":{},"tag":"p","children":["A numerical derivative operator ",{"attributes":{},"tag":"code","children":["D"],"type":"node"}," of order ",{"attributes":{},"tag":"code","children":["m"],"type":"node"}," can be constructed for this grid with ",{"attributes":{},"tag":"code","children":["D = CenteredDifference(1, m, h, n)"],"type":"node"},". The argument ",{"attributes":{},"tag":"code","children":["1"],"type":"node"}," indicates that this is the first derivative. Order ",{"attributes":{},"tag":"code","children":["m"],"type":"node"}," means that the operator is exact up to rounding when ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," is a polynomial of degree ",{"attributes":{},"tag":"code","children":["m"],"type":"node"}," or lower."],"type":"node"},{"attributes":{},"tag":"p","children":["The derivative operator ",{"attributes":{},"tag":"code","children":["D"],"type":"node"}," is used along with a boundary condition operator ",{"attributes":{},"tag":"code","children":["Q"],"type":"node"}," to compute derivatives at the interior points of the grid. A simple boundary condition ",{"attributes":{},"tag":"code","children":["f(x_0) = f(x_n+1) = 0"],"type":"node"}," is constructed with ",{"attributes":{},"tag":"code","children":["Q = Dirichlet0BC(eltype(u))"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["Given these definitions, the derivatives are calculated as if the operators ",{"attributes":{},"tag":"code","children":["D"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["Q"],"type":"node"}," were matrices, ",{"attributes":{},"tag":"code","children":["du = D*Q*u"],"type":"node"},". This is an abuse of notation! The particular ",{"attributes":{},"tag":"code","children":["Q"],"type":"node"}," in this example is a linear operator but, in general, boundary conditions are affine operators. They have the form ",{"attributes":{},"tag":"code","children":["Q(x) = M*x + c"],"type":"node"},", where ",{"attributes":{},"tag":"code","children":["M"],"type":"node"}," is a matrix and ",{"attributes":{},"tag":"code","children":["c"],"type":"node"}," is a constant vector. As a consequence, ",{"attributes":{},"tag":"code","children":["Q"],"type":"node"}," cannot be concretized to a matrix."],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{"src":"https://github.com/SciML/DiffEqOperators.jl/raw/master/action.svg","alt":""},"tag":"img","children":["Actions of DiffEqOperators on interior points and ghost points"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The operator ",{"attributes":{},"tag":"code","children":["D"],"type":"node"}," works by interpolating a polynomial of degree ",{"attributes":{},"tag":"code","children":["m"],"type":"node"}," through ",{"attributes":{},"tag":"code","children":["m+1"],"type":"node"}," adjacent points on the grid. Near the middle of the grid, the derivative is approximated at ",{"attributes":{},"tag":"code","children":["x_j"],"type":"node"}," by interpolating a polynomial of order ",{"attributes":{},"tag":"code","children":["m"],"type":"node"}," with ",{"attributes":{},"tag":"code","children":["x_j"],"type":"node"}," at its centre. To define an order-",{"attributes":{},"tag":"code","children":["m"],"type":"node"}," polynomial, values are required at ",{"attributes":{},"tag":"code","children":["m+1"],"type":"node"}," points. When ",{"attributes":{},"tag":"code","children":["x_j"],"type":"node"}," is too close to the boundary for that to fit, the polynomial is interpolated through the leftmost or rightmost ",{"attributes":{},"tag":"code","children":["m+1"],"type":"node"}," points, including two “ghost” points that ",{"attributes":{},"tag":"code","children":["Q"],"type":"node"}," appends on the boundaries. The numerical derivatives are linear combinations of the values through which the polynomials are interpolated. The vectors of the coefficients in these linear combinations are called “stencils”. Because ",{"attributes":{},"tag":"code","children":["D"],"type":"node"}," takes values at the ghost points and returns values at the interior points, it is an ",{"attributes":{},"tag":"code","children":["n×(n+2)"],"type":"node"}," matrix."],"type":"node"},{"attributes":{},"tag":"p","children":["The boundary condition operator ",{"attributes":{},"tag":"code","children":["Q"],"type":"node"}," acts as an ",{"attributes":{},"tag":"code","children":["(n+2)×n"],"type":"node"}," matrix. The output ",{"attributes":{},"tag":"code","children":["Q*u"],"type":"node"}," is a vector of values on the ",{"attributes":{},"tag":"code","children":["n"],"type":"node"}," interior and the 2 boundary points, ",{"attributes":{},"tag":"code","children":["[a, f(x_1), …, f(x_N), b]"],"type":"node"},". The interior points take the values of ",{"attributes":{},"tag":"code","children":["u"],"type":"node"},". The values ",{"attributes":{},"tag":"code","children":["a"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["b"],"type":"node"}," are samples at “ghost” points on the grid boundaries. As shown, these values are assigned so that an interpolated polynomial ",{"attributes":{},"tag":"code","children":["P(x)"],"type":"node"}," satisfies the left hand boundary condition, and ",{"attributes":{},"tag":"code","children":["Q(x)"],"type":"node"}," satisfies the right-hand boundary condition. The boundary conditions provided by the library are precisely those for which the values ",{"attributes":{},"tag":"code","children":["a"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["b"],"type":"node"}," are affine functions of the interior values ",{"attributes":{},"tag":"code","children":["f_j"],"type":"node"},", so that ",{"attributes":{},"tag":"code","children":["Q"],"type":"node"}," is an affine operator."],"type":"node"},{"attributes":{},"tag":"h2","children":["Higher dimensions"],"type":"node"},{"attributes":{},"tag":"p","children":["In one dimension, ",{"attributes":{},"tag":"code","children":["u"],"type":"node"}," is naturally stored as a ",{"attributes":{},"tag":"code","children":["Vector"],"type":"node"},", and the derivative and boundary condition operators are similar to matrices."],"type":"node"},{"attributes":{},"tag":"p","children":["In two dimensions, the values ",{"attributes":{},"tag":"code","children":["f(x_j)"],"type":"node"}," are naturally stored as a matrix. Taking derivatives along the downwards axis is easy, because matrices act columnwise. Horizontal derivatives can be taken by transposing the matrices. The derivative along the rightward axis is ",{"attributes":{},"tag":"code","children":["(D*F')' = F*D' "],"type":"node"},". This is easy to code, but less easy to read for those who haven't seen it before."],"type":"node"},{"attributes":{},"tag":"p","children":["When a function has three or more arguments, its values are naturally stored in a higher-dimensional array. Julia's multiplication operator is only defined for ",{"attributes":{},"tag":"code","children":["Vector"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["Matrix"],"type":"node"},", so applying an operator matrix to these arrays would require a complicated and error prone series of ",{"attributes":{},"tag":"code","children":["reshape"],"type":"node"}," and axis permutation functions."],"type":"node"},{"attributes":{},"tag":"p","children":["Therefore the types of derivative and boundary condition operators are parameterised by the axis along which the operator acts. With derivative operators, the axis is supplied as a type parameter. The simple case ",{"attributes":{},"tag":"code","children":["CenteredDifference(…)"],"type":"node"}," is equivalent to ",{"attributes":{},"tag":"code","children":["CenteredDifference{1}(…)"],"type":"node"},", row-wise derivatives are taken by ",{"attributes":{},"tag":"code","children":["CenteredDifference{2}(…)"],"type":"node"},", sheet-wise by ",{"attributes":{},"tag":"code","children":["CenteredDifference{3}(…)"],"type":"node"},", and along the ",{"attributes":{},"tag":"code","children":["N"],"type":"node"},"th axis by ",{"attributes":{},"tag":"code","children":["CenteredDifference{N}(…)"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["Boundary conditions are more complicated. See ",{"attributes":{},"tag":"code","children":["@doc MultiDimBC"],"type":"node"}," for how they are supposed to work in multiple dimensions. They don't currently work that way."],"type":"node"},{"attributes":{},"tag":"h2","children":["Constructors"],"type":"node"},{"attributes":{},"tag":"p","children":["The constructors are as follows:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"CURLY","children":[{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.CenteredDifference"},"tag":"reference","children":["CenteredDifference"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["N"],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["derivative_order"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["Int"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                      "],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["approximation_order"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["Int"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["dx"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                      "],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["len"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["Int"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["coeff_func"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"CURLY","children":[{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.UpwindDifference"},"tag":"reference","children":["UpwindDifference"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["N"],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["derivative_order"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["Int"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                    "],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["approximation_order"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["Int"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["dx"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                    "],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["len"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["Int"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["coeff_func"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"PARAMETERS","children":[{"attributes":{},"tag":"SEMICOLON","children":[";"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["offside"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["Int"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["0"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The arguments are:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["N"],"type":"node"},": The directional dimension of the discretization. If ",{"attributes":{},"tag":"code","children":["N"],"type":"node"}," is not given, it is assumed to be 1, i.e., differencing occurs along columns."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["derivative_order"],"type":"node"},": the order of the derivative to discretize."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["approximation_order"],"type":"node"},": the order of the discretization in terms of O(dx^order)."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["dx"],"type":"node"},": the spacing of the discretization. If ",{"attributes":{},"tag":"code","children":["dx"],"type":"node"}," is a ",{"attributes":{},"tag":"code","children":["Number"],"type":"node"},", the operator is a uniform discretization. If ",{"attributes":{},"tag":"code","children":["dx"],"type":"node"}," is an array, then the operator is a non-uniform discretization. Its type needs to match the one from the Array to be differentiated."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["len"],"type":"node"},": the length of the discretization in the direction of the operator."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["coeff_func"],"type":"node"},": An operational argument for a coefficient function ",{"attributes":{},"tag":"code","children":["f(du,u,p,t)"],"type":"node"}," which sets the coefficients of the operator. If ",{"attributes":{},"tag":"code","children":["coeff_func"],"type":"node"}," is a ",{"attributes":{},"tag":"code","children":["Number"],"type":"node"},", then the coefficients are set to be constant with that number. If ",{"attributes":{},"tag":"code","children":["coeff_func"],"type":"node"}," is an ",{"attributes":{},"tag":"code","children":["AbstractArray"],"type":"node"}," with length matching ",{"attributes":{},"tag":"code","children":["len"],"type":"node"},", then the coefficients are constant but spatially dependent."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["offside"],"type":"node"},": A keyword argument for ",{"attributes":{},"tag":"code","children":["UpwindDifference"],"type":"node"}," which sets the number of offside points against the primary wind direction allowing it to have some bias/offset. Number of points used for approximation remain same. By default its ",{"attributes":{},"tag":"code","children":["0"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["N"],"type":"node"},"-dimensional derivative operators need to act against a value of at least ",{"attributes":{},"tag":"code","children":["N"],"type":"node"}," dimensions."],"type":"node"},{"attributes":{},"tag":"h3","children":["Derivative Operator Actions"],"type":"node"},{"attributes":{},"tag":"p","children":["These operators are lazy, meaning the memory is not allocated. Similarly, the operator actions ",{"attributes":{},"tag":"code","children":["*"],"type":"node"}," can be performed without ever building the operator matrices. Additionally, ",{"attributes":{},"tag":"code","children":["mul!(y,L,x)"],"type":"node"}," can be performed for non-allocating applications of the operator."],"type":"node"},{"attributes":{},"tag":"h3","children":["Concretizations"],"type":"node"},{"attributes":{},"tag":"p","children":["The following concretizations are provided:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["Array"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["SparseMatrixCSC"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["BandedMatrix"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["BlockBandedMatrix"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Additionally, the function ",{"attributes":{},"tag":"code","children":["sparse"],"type":"node"}," is overloaded to give the most efficient matrix type for a given operator. For one-dimensional derivatives this is a ",{"attributes":{},"tag":"code","children":["BandedMatrix"],"type":"node"},", while for higher-dimensional operators this is a ",{"attributes":{},"tag":"code","children":["BlockBandedMatrix"],"type":"node"},". The concretizations are made to act on ",{"attributes":{},"tag":"code","children":["vec(u)"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["A contraction operator concretizes to an ordinary matrix, no matter which dimension the contraction acts along, by doing the Kronecker product formulation. I.e., the action of the built matrix will match the action on ",{"attributes":{},"tag":"code","children":["vec(u)"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h2","children":["Boundary Condition Operators"],"type":"node"},{"attributes":{},"tag":"p","children":["Boundary conditions are implemented through a ghost node approach. The discretized values ",{"attributes":{},"tag":"code","children":["u"],"type":"node"}," should be the interior of the domain so that, for the boundary value operator ",{"attributes":{},"tag":"code","children":["Q"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["Q*u"],"type":"node"}," is the discretization on the closure of the domain. By using it like this, ",{"attributes":{},"tag":"code","children":["L*Q*u"],"type":"node"}," is the ",{"attributes":{},"tag":"code","children":["NxN"],"type":"node"}," operator which satisfies the boundary conditions."],"type":"node"},{"attributes":{},"tag":"h3","children":["Periodic Boundary Conditions"],"type":"node"},{"attributes":{},"tag":"p","children":["The constructor ",{"attributes":{},"tag":"code","children":["PeriodicBC"],"type":"node"}," provides the periodic boundary condition operator."],"type":"node"},{"attributes":{},"tag":"h3","children":["Robin Boundary Conditions"],"type":"node"},{"attributes":{},"tag":"p","children":["The variables in l are ",{"attributes":{},"tag":"code","children":["[αl, βl, γl]"],"type":"node"},", and correspond to a BC of the form ",{"attributes":{},"tag":"code","children":["al*u(0) + bl*u'(0) = cl"],"type":"node"},", and similarly ",{"attributes":{},"tag":"code","children":["r"],"type":"node"}," for the right boundary ",{"attributes":{},"tag":"code","children":["ar*u(N) + br*u'(N) = cl"],"type":"node"},"."],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.RobinBC"},"tag":"reference","children":["RobinBC"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["l"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"CURLY","children":[{"attributes":{},"tag":"IDENTIFIER","children":["AbstractArray"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["T"],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["r"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"CURLY","children":[{"attributes":{},"tag":"IDENTIFIER","children":["AbstractArray"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["T"],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["dx"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"CURLY","children":[{"attributes":{},"tag":"IDENTIFIER","children":["AbstractArray"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["T"],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["order"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["one"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["T"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Additionally, the following helpers exist for the Neumann ",{"attributes":{},"tag":"code","children":["u'(0) = α"],"type":"node"}," and Dirichlet ",{"attributes":{},"tag":"code","children":["u(0) = α"],"type":"node"}," cases."],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.DirichletBC"},"tag":"reference","children":["DirichletBC"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["αl"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["T"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["αr"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["T"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.Dirichlet0BC"},"tag":"reference","children":["Dirichlet0BC"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["T"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["Type"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.DirichletBC"},"tag":"reference","children":["DirichletBC"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["zero"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["T"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["zero"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["T"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["This fixes ",{"attributes":{},"tag":"code","children":["u = αl"],"type":"node"}," at the first point of the grid, and ",{"attributes":{},"tag":"code","children":["u = αr"],"type":"node"}," at the last point."],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.Neumann0BC"},"tag":"reference","children":["Neumann0BC"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["dx"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"CURLY","children":[{"attributes":{},"tag":"IDENTIFIER","children":["Union"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"CURLY","children":[{"attributes":{},"tag":"IDENTIFIER","children":["AbstractVector"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["T"],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["T"],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["order"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["1"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.NeumannBC"},"tag":"reference","children":["NeumannBC"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["α"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"CURLY","children":[{"attributes":{},"tag":"IDENTIFIER","children":["AbstractVector"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["T"],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["dx"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"CURLY","children":[{"attributes":{},"tag":"IDENTIFIER","children":["AbstractVector"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["T"],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["order"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["1"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h3","children":["General Boundary Conditions"],"type":"node"},{"attributes":{},"tag":"p","children":["Implements a generalization of the Robin boundary condition, where α is a vector of coefficients. Represents a condition of the form α[1] + α[2]u[0] + α[3]u'[0] + α[4]u''[0]+... = 0"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.GeneralBC"},"tag":"reference","children":["GeneralBC"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["αl"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"CURLY","children":[{"attributes":{},"tag":"IDENTIFIER","children":["AbstractArray"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["T"],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["αr"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"CURLY","children":[{"attributes":{},"tag":"IDENTIFIER","children":["AbstractArray"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["T"],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["dx"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"CURLY","children":[{"attributes":{},"tag":"IDENTIFIER","children":["AbstractArray"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["T"],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["order"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["1"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h3","children":["Operator Actions"],"type":"node"},{"attributes":{},"tag":"p","children":["The boundary condition operators act lazily by appending the appropriate values to the end of the array, building the ghost-point extended version for the derivative operator to act on. This utilizes special array types to not require copying the interior data."],"type":"node"},{"attributes":{},"tag":"h3","children":["Concretizations"],"type":"node"},{"attributes":{},"tag":"p","children":["The following concretizations are provided:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["Array"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["SparseMatrixCSC"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Additionally, the function ",{"attributes":{},"tag":"code","children":["sparse"],"type":"node"}," is overloaded to give the most efficient matrix type for a given operator. For these operators it's ",{"attributes":{},"tag":"code","children":["SparseMatrixCSC"],"type":"node"},". The concretizations are made to act on ",{"attributes":{},"tag":"code","children":["vec(u)"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h2","children":["GhostDerivative Operators"],"type":"node"},{"attributes":{},"tag":"p","children":["When ",{"attributes":{},"tag":"code","children":["L"],"type":"node"}," is a ",{"attributes":{},"tag":"code","children":["DerivativeOperator"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["Q"],"type":"node"}," is a boundary condition operator, ",{"attributes":{},"tag":"code","children":["L*Q"],"type":"node"}," produces a ",{"attributes":{},"tag":"code","children":["GhostDerivative"],"type":"node"}," operator which is the composition of the two operations."],"type":"node"},{"attributes":{},"tag":"h3","children":["Concretizations"],"type":"node"},{"attributes":{},"tag":"p","children":["The following concretizations are provided:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["Array"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["SparseMatrixCSC"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["BandedMatrix"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Additionally, the function ",{"attributes":{},"tag":"code","children":["sparse"],"type":"node"}," is overloaded to give the most efficient matrix type for a given operator. For these operators it's ",{"attributes":{},"tag":"code","children":["BandedMatrix"],"type":"node"}," unless the boundary conditions are ",{"attributes":{},"tag":"code","children":["PeriodicBC"],"type":"node"},", in which case it's ",{"attributes":{},"tag":"code","children":["SparseMatrixCSC"],"type":"node"},". The concretizations are made to act on ",{"attributes":{},"tag":"code","children":["vec(u)"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"}