[{"doctype":"documentation","id":"references/SciMLBase.responsible_map","title":"responsible_map","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractReactionNetwork","title":"AbstractReactionNetwork","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.get_timestep","title":"get_timestep","text":""},{"doctype":"documentation","id":"references/SciMLBase.TwoPointBVPFunction","title":"TwoPointBVPFunction","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.reinit!","title":"reinit!","text":"The reinit function lets you restart the integration at a new value Arguments u0  Value of  u  to start at Default value is  integrator.sol.prob.u0 Keyword Arguments t0  Starting timepoint Default value is  integrator.sol.prob.tspan[1 tf  Ending timepoint Default value is  integrator.sol.prob.tspan[2 erase_sol=true  Whether to start with no other values in the solution or keep the previous solution tstops   d_discontinuities    saveat  Cache where these are stored Default is the original cache reset_dt  Set whether to reset the current value of  dt  using the automatic  dt  determination algorithm Default is  integrator.dtcache  zero(integrator.dt  integrator.opts.adaptive reinit_callbacks  Set whether to run the callback initializations again and  initialize_save  is for that Default is  true  reinit_cache  Set whether to re-run the cache initialization function i.e resetting FSAL not allocating vectors which should usually be true for correctness Default is  true  Additionally once can access  auto_dt_reset  which will run the auto  dt  initialization algorithm"},{"doctype":"documentation","id":"references/NonlinearSolve.SciMLSolution","title":"SciMLSolution","text":""},{"doctype":"documentation","id":"references/SciMLBase.SciMLAlgorithm","title":"SciMLAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.get_du","title":"get_du","text":"Returns the derivative at  t "},{"doctype":"documentation","id":"references/SciMLBase.addsteps!","title":"addsteps!","text":""},{"doctype":"documentation","id":"references/SciMLBase.UJacobianWrapper","title":"UJacobianWrapper","text":""},{"doctype":"documentation","id":"references/SciMLBase.num_types_in_tuple","title":"num_types_in_tuple","text":"DocStringExtensions.MethodSignatures Get the number of parameters of a Tuple type i.e the number of fields"},{"doctype":"documentation","id":"references/SciMLBase.ContinuousCallback","title":"ContinuousCallback","text":"condition affect! affect_neg! initialize finalize idxs nothing rootfind save_positions interp_points abstol eps reltol repeat_nudge Contains a single callback whose  condition  is a continuous function The callback is triggered when this function evaluates to 0 Arguments condition  This is a function  condition(u,t,integrator  for declaring when the callback should be used A callback is initiated if the condition hits  0  within the time interval See the Integrator Interface  integrator documentation for information about  integrator  affect  This is the function  affect!(integrator  where one is allowed to modify the current state of the integrator If you do not pass an  affect_neg  function it is called when  condition  is found to be  0  at a root and the cross is either an upcrossing from negative to positive or a downcrossing from positive to negative You need to explicitly pass  nothing  as the  affect_neg  argument if it should only be called at upcrossings e.g  ContinuousCallback(condition affect nothing  For more information on what can be done see the Integrator Interface  integrator manual page Modifications to  u  are safe in this function affect_neg!=affect  This is the function  affect_neg!(integrator  where one is allowed to modify the current state of the integrator This is called when  condition  is found to be  0  at a root and the cross is an downcrossing from positive to negative For more information on what can be done see the Integrator Interface  integrator manual page Modifications to  u  are safe in this function rootfind=LeftRootFind  This is a flag to specify the type of rootfinding to do for finding event location If this is set to  LeftRootfind  the solution will be backtracked to the point where  condition==0  and if the solution isn't exact the left limit of root is used If set to  RightRootFind  the solution would be set to the right limit of the root Otherwise the systems and the  affect  will occur at  t+dt  Note that these enums are not exported and thus one needs to reference them as  SciMLBase.LeftRootFind   SciMLBase.RightRootFind  or  SciMLBase.NoRootFind  interp_points=10  The number of interpolated points to check the condition The condition is found by checking whether any interpolation point  endpoint has a different sign If  interp_points=0  then conditions will only be noticed if the sign of  condition  is different at  t  than at  t+dt  This behavior is not robust when the solution is oscillatory and thus it's recommended that one use some interpolation points they're cheap to compute  0  within the time interval save_positions=(true,true  Boolean tuple for whether to save before and after the  affect  This saving will occur just before and after the event only at event times and does not depend on options like  saveat   save_everystep  etc i.e if  saveat=[1.0,2.0,3.0  this can still add a save point at  2.1  if true For discontinuous changes like a modification to  u  to be handled correctly without error one should set  save_positions=(true,true  idxs=nothing  The components which will be interpolated into the condition Defaults to  nothing  which means  u  will be all components initialize  This is a function  c,u,t,integrator  which can be used to initialize the state of the callback  c  It should modify the argument  c  and the return is ignored finalize  This is a function  c,u,t,integrator  which can be used to finalize the state of the callback  c  It can modify the argument  c  and the return is ignored abstol=1e-14    reltol=0  These are used to specify a tolerance from zero for the rootfinder if the starting condition is less than the tolerance from zero then no root will be detected This is to stop repeat events happening just after a previously rootfound event repeat_nudge  1//100  This is used to set the next testing point after a previously found zero Defaults to 1//100 which means after a callback the next sign check will take place at t  dt*1//100 instead of at t to avoid repeats"},{"doctype":"documentation","id":"references/SciMLBase.AbstractNonlinearProblem","title":"AbstractNonlinearProblem","text":"DocStringExtensions.TypeDefinition Base for types which define nonlinear solve problems f(u)=0"},{"doctype":"documentation","id":"references/SciMLBase.NullParameters","title":"NullParameters","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractODESolution","title":"AbstractODESolution","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.AbstractQuadratureProblem","title":"AbstractQuadratureProblem","text":""},{"doctype":"documentation","id":"references/SciMLBase.RightRootFind","title":"RightRootFind","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractIntegralProblem","title":"AbstractIntegralProblem","text":"DocStringExtensions.TypeDefinition Base for types which define integrals suitable for quadrature"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timeseries_point_weighted_meancov","title":"timeseries_point_weighted_meancov","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractDDESolution","title":"AbstractDDESolution","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.diffeq_to_arrays","title":"diffeq_to_arrays","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractNonlinearFunction","title":"AbstractNonlinearFunction","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/LinearSolve.AbstractKrylovSubspaceMethod","title":"AbstractKrylovSubspaceMethod","text":""},{"doctype":"documentation","id":"references/SciMLBase.promote_tspan","title":"promote_tspan","text":"Convert the  tspan  field of a  DEProblem  to a  tmin tmax  tuple where both elements are of the same type If  tspan  is a function returns it as-is"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleTestSolution","title":"EnsembleTestSolution","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.user_cache","title":"user_cache","text":""},{"doctype":"documentation","id":"references/SciMLBase.is_diagonal_noise","title":"is_diagonal_noise","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timeseries_point_meancov","title":"timeseries_point_meancov","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractOptimizationFunction","title":"AbstractOptimizationFunction","text":"DocStringExtensions.TypeDefinition Base for types defining optimization functions"},{"doctype":"documentation","id":"references/SciMLBase.AbstractDDEIntegrator","title":"AbstractDDEIntegrator","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.componentwise_meancor","title":"componentwise_meancor","text":""},{"doctype":"documentation","id":"references/SciMLBase.has_expmv","title":"has_expmv","text":""},{"doctype":"documentation","id":"references/SciMLBase.has_expmv!","title":"has_expmv!","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractNoTimeSolution","title":"AbstractNoTimeSolution","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.AbstractSDEAlgorithm","title":"AbstractSDEAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.DiscreteProblem","title":"DiscreteProblem","text":"Defines a discrete dynamical system problem Documentation Page https://diffeq.sciml.ai/stable/types/discrete_types Mathematical Specification of a Discrete Problem To define an Discrete Problem you simply need to give the function  f  and the initial condition  u_0  which define a function map u_{n+1  f(u_{n},p,t_{n+1 f  should be specified as  f(un,p,t  or in-place as  f(unp1,un,p,t  and  u_0  should be an AbstractArray or number whose geometry matches the desired geometry of  u  Note that we are not limited to numbers or vectors for  u₀  one is allowed to provide  u₀  as arbitrary matrices  higher dimension tensors as well  u_{n+1  only depends on the previous iteration  u_{n  and  t_{n+1  The default  t_{n+1  of  FunctionMap  is  t_n  t_0  n*dt  with  dt=1  being the default For continuous-time Markov chains this is the time at which the change is occuring Note that if the discrete solver is set to have  scale_by_time=true  then the problem is interpreted as the map u_{n+1  u_n  dt f(u_{n},p,t_{n+1 Problem Type Constructors DiscreteProblem{isinplace}(f::ODEFunction,u0,tspan,p=NullParameters();kwargs   Defines the discrete problem with the specified functions DiscreteProblem{isinplace}(f,u0,tspan,p=NullParameters();kwargs   Defines the discrete problem with the specified functions DiscreteProblem{isinplace}(u0,tspan,p=NullParameters();kwargs   Defines the discrete problem with the identity map Parameters are optional and if not given then a  NullParameters  singleton will be used which will throw nice errors if you try to index non-existent parameters Any extra keyword arguments are passed on to the solvers For example if you set a  callback  in the problem then that  callback  will be added in every solve call For specifying Jacobians and mass matrices see the DiffEqFunctions  performance_overloads page Fields f  The function in the map u0  The initial condition tspan  The timespan for the problem p  The parameters for the problem Defaults to  NullParameters kwargs  The keyword arguments passed onto the solves Note About Timing Note that if no  dt  and not  tstops  is given it's assumed that  dt=1  and thus  tspan=(0,n  will solve for  n  iterations If in the solver  dt  is given then the number of iterations will change And if  tstops  is not empty the solver will revert to the standard behavior of fixed timestep methods which is step to each tstop Defines a discrete problem with the specified functions DocStringExtensions.MethodSignatures Define a discrete problem with the identity map"},{"doctype":"documentation","id":"references/LinearSolve.LUSolver","title":"LUSolver","text":""},{"doctype":"documentation","id":"references/SciMLBase.u_modified!","title":"u_modified!","text":"Sets  bool  which states whether a change to  u  occurred allowing the solver to handle the discontinuity By default this is assumed to be true if a callback is used This will result in the re-calculation of the derivative at  t+dt  which is not necessary if the algorithm is FSAL and  u  does not experience a discontinuous change at the end of the interval Thus if  u  is unmodified in a callback a single call to the derivative calculation can be eliminated by  u_modified!(integrator,false "},{"doctype":"documentation","id":"references/LinearSolve.IterativeSolversJL_CG","title":"IterativeSolversJL_CG","text":""},{"doctype":"documentation","id":"references/SciMLBase.expmv","title":"expmv","text":""},{"doctype":"documentation","id":"references/SciMLBase.expmv!","title":"expmv!","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractDiffEqFunction","title":"AbstractDiffEqFunction","text":"DocStringExtensions.TypeDefinition Base for types defining differential equation functions"},{"doctype":"documentation","id":"references/SciMLBase.DiffEqScalar","title":"DiffEqScalar","text":"Represents a time-dependent scalar/scaling operator The update function is called by  update_coefficients  and is assumed to have the following signature"},{"doctype":"documentation","id":"references/SciMLBase.NoInit","title":"NoInit","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.DEElement","title":"DEElement","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.AbstractDAESolution","title":"AbstractDAESolution","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.__has_syms","title":"__has_syms","text":""},{"doctype":"documentation","id":"references/SciMLBase.initialize_dae!","title":"initialize_dae!","text":"initialize_dae!(integrator::DEIntegrator,initializealg  integrator.initializealg Runs the DAE initialization to find a consistent state vector The optional argument  initializealg  can be used to specify a different initialization algorithm to use"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timepoint_median","title":"timepoint_median","text":""},{"doctype":"documentation","id":"references/SciMLBase.ODEProblem","title":"ODEProblem","text":"DiffEqProblemLibrary ODEProblemLibrary ODEProblemLibrary importodeproblems prob ODEProblemLibrary prob_ode_linear sol solve prob Defines an ordinary differential equation ODE problem Documentation Page https://diffeq.sciml.ai/stable/types/ode_types Mathematical Specification of an ODE Problem To define an ODE Problem you simply need to give the function  f  and the initial condition  u_0  which define an ODE M frac{du}{dt  f(u,p,t There are two different ways of specifying  f  f(du,u,p,t  in-place Memory-efficient when avoiding allocations Best option for most cases unless mutation is not allowed f(u,p,t  returning  du  Less memory-efficient way particularly suitable when mutation is not allowed e.g with certain automatic differentiation packages such as Zygote u₀  should be an AbstractArray or number whose geometry matches the desired geometry of  u  Note that we are not limited to numbers or vectors for  u₀  one is allowed to provide  u₀  as arbitrary matrices  higher dimension tensors as well For the mass matrix  M  see the documentation of  ODEFunction  Problem Type Constructors ODEProblem  can be constructed by first building an  ODEFunction  or by simply passing the ODE right-hand side to the constructor The constructors are ODEProblem(f::ODEFunction,u0,tspan,p=NullParameters();kwargs ODEProblem{isinplace}(f,u0,tspan,p=NullParameters();kwargs   Defines the ODE with the specified functions  isinplace  optionally sets whether the function is inplace or not This is determined automatically but not inferred Parameters are optional and if not given then a  NullParameters  singleton will be used which will throw nice errors if you try to index non-existent parameters Any extra keyword arguments are passed on to the solvers For example if you set a  callback  in the problem then that  callback  will be added in every solve call For specifying Jacobians and mass matrices see the  ODEFunction  documentation Fields f  The function in the ODE u0  The initial condition tspan  The timespan for the problem p  The parameters kwargs  The keyword arguments passed onto the solves Example Problems Example problems can be found in  DiffEqProblemLibrary.jl  To use a sample problem such as  prob_ode_linear  you can do something like Define an ODE problem from an  ODEFunction "},{"doctype":"documentation","id":"references/NonlinearSolve.add_kwonly","title":"add_kwonly","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.DEFAULT_LINSOLVE","title":"DEFAULT_LINSOLVE","text":""},{"doctype":"document","id":"SciMLBase/interfaces/SciMLFunctions.md","title":"[SciMLFunctions (Jacobians, Sparsity, Etc.)]( scimlfunctions)","text":"f iip f iip f LinearAlgebra f du u p t du t u jac J u p t J t J t J jp Diagonal zeros fun f jac jac jac_prototype jp SciMLFunctions Jacobians Sparsity Etc  scimlfunctions The SciML ecosystem provides an extensive interface for declaring extra functions associated with the differential equation's data In traditional libraries there is usually only one option the Jacobian However we allow for a large array of pre-computed functions to speed up the calculations This is offered via the  SciMLFunction  types which can be passed to the problems Definition of the AbstractSciMLFunction Interface The following standard principles should be adhered to across all  AbstractSciMLFunction  instantiations Common Function Choice Definitions The full interface available to the solvers is as follows jac  The Jacobian of the differential equation with respect to the state variable  u  at a time  t  with parameters  p  paramjac  The Jacobian of the differential equation with respect to  p  at state  u  at time  t  analytic  Defines an analytical solution using  u0  at time  t  with  p  which will cause the solvers to return errors Used for testing syms  Allows you to name your variables for automatic names in plots and other output jac_prototype  Defines the type to be used for any internal Jacobians within the solvers sparsity  Defines the sparsity pattern to be used for the sparse differentiation schemes By default this is equal to  jac_prototype  See the sparsity handling portion of this page for more information colorvec  The coloring pattern used by the sparse differentiator See the sparsity handling portion of this page for more information observed  A function which allows for generating other observables from a solution Each function type additionally has some specific arguments refer to their documentation for details In-place Specification and No-Recompile Mode Each SciMLFunction type can be called with an is inplace iip choice which is a boolean for whether the function is in the inplace form mutating to change the first value This is automatically determined using the methods table but note that for full type-inferrability of the  SciMLProblem  this iip-ness should be specified Additionally the functions are fully specialized to reduce the runtimes If one would instead like to not specialize on the functions to reduce compile time then one can set  recompile  to false This makes the ODE solver compilation independent of the function and so changing the function will not cause recompilation One can change the default value by changing the  const RECOMPILE_BY_DEFAULT  true  to false in the SciMLBase.jl source code Specifying Jacobian Types The  jac  field of an inplace style  SciMLFunction  has the signature  jac(J,u,p,t  which updates the jacobian  J  in-place The intended type for  J  can sometimes be inferred e.g when it is just a dense  Matrix  but not in general To supply the type information you can provide a  jac_prototype  in the function's constructor The following example creates an inplace  ODEFunction  whose jacobian is a  Diagonal  Note that the integrators will always make a deep copy of  fun.jac_prototype  so there's no worry of aliasing In general the jacobian prototype can be anything that has  mul  defined in particular sparse matrices or custom lazy types that support  mul  A special case is when the  jac_prototype  is a  AbstractDiffEqLinearOperator  in which case you do not need to supply  jac  as it is automatically set to  update_coefficients  Refer to the  DiffEqOperators  section for more information on setting up time/parameter dependent operators Sparsity Handling The solver libraries internally use packages such as  FiniteDiff.jl  and  SparseDiffTools.jl  for high performance calculation of sparse Jacobians and Hessians along with matrix-free calculations of Jacobian-Vector products J*v vector-Jacobian products v J   and Hessian-vector products H v The SciML interface gives users the ability to control these connections in order to allow for top notch performance The key arguments in the SciMLFunction is the  prototype  which is an object that will be used as the underlying Jacobian/Hessian Thus if one wants to use a sparse Jacobian one should specify  jac_prototype  to be a sparse matrix The sparsity pattern used in the differentiation scheme is defined by  sparsity  By default  sparsity=jac_prototype  meaning that the sparse automatic differentiation scheme should specialize on the sparsity pattern given by the actual sparsity pattern This can be overridden to say perform partial matrix coloring approximations Additionally the color vector for the sparse differentiation directions can be specified directly via  colorvec  For more information on how these arguments control the differentiation process see the aforementioned differentiation library documentations Traits AbstractSciMLFunction API Abstract SciML Functions Concrete SciML Functions"},{"doctype":"documentation","id":"references/SciMLBase.build_linear_solution","title":"build_linear_solution","text":""},{"doctype":"documentation","id":"references/SciMLBase.IntegralProblem","title":"IntegralProblem","text":"Defines an integral problem Documentation Page https://github.com/SciML/Integrals.jl Mathematical Specification of a Integral Problem Integral problems are multi-dimensional integrals defined as int_{lb}^{ub f(u,p du where  p  are parameters  u  is a  Number  or  AbstractArray  whose geometry matches the space being integrated Problem Type Constructors IntegralProblem(f,lb,ub,p=NullParameters                   nout=1 batch  0 kwargs f the integrand  dx=f(x,p  for out-of-place or  f(dx,x,p  for in-place lb Either a number or vector of lower bounds ub Either a number or vector of upper bounds p The parameters associated with the problem nout The output size of the function f Defaults to 1 i.e a scalar integral output batch The preferred number of points to batch This allows user-side parallelization  of the integrand If batch  0 then each x[:,i is a different point of the integral  to calculate and the output should be nout x batchsize Note that batch is a suggestion  for the number of points and it is not necessarily true that batch is the same as  batchsize in all algorithms kwargs Keyword arguments copied to the solvers Additionally we can supply iip like IntegralProblem as true or false to declare at  compile time whether the integrator function is in-place Fields The fields match the names of the constructor arguments"},{"doctype":"documentation","id":"references/SciMLBase.has_reinit","title":"has_reinit","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSteadyStateSolution","title":"AbstractSteadyStateSolution","text":"DocStringExtensions.TypeDefinition"},{"doctype":"document","id":"LinearSolve/basics/Preconditioners.md","title":"[Preconditioners]( prec)","text":"LinearAlgebra s rand n Pl Diagonal s A rand n n b rand n prob A b sol solve prob IterativeSolvers_GMRES Pl Pl Preconditioners  prec Many linear solvers can be accelerated by using what is known as a  preconditioner  an approximation to the matrix inverse action which is cheap to evaluate These can improve the numerical conditioning of the solver process and in turn improve the performance LinearSolve.jl provides an interface for the definition of preconditioners which works with the wrapped packages Using Preconditioners Mathematical Definition Preconditioners are specified in the keyword arguments of  init  or  solve  The right preconditioner  Pr  transforms the linear system  Au  b  into the form AP_r^{-1}(Pu  AP_r^{-1}y  b to add the solving step  P_r u  y  The left preconditioner  Pl  transforms the linear system into the form P_l^{-1}(Au  b  0 A two-sided preconditioned system is of the form P_l A P_r^{-1 P_r u  P_l b By default if no preconditioner is given the preconditioner is assumed to be the identity  I  Using Preconditioners In the following we will use the  DiagonalPreconditioner  to define a two-sided preconditioned system which first divides by some random numbers and then multiplies by the same values This is commonly used in the case where if instead of random  s  is an approximation to the eigenvalues of a system Preconditioner Interface To define a new preconditioner you define a Julia type which satisfies the following interface Base.eltype(::Preconditioner  Required only for Krylov.jl LinearAlgebra.ldiv!(::AbstractVector,::Preconditioner,::AbstractVector  and  LinearAlgebra.ldiv!(::Preconditioner,::AbstractVector Curated List of Pre-Defined Preconditioners The following preconditioners match the interface of LinearSolve.jl LinearSolve.ComposePreconditioner(prec1,prec2  composes the preconditioners to apply  prec1  before  prec2  LinearSolve.InvPreconditioner(prec  inverts  mul  and  ldiv  in a preconditioner definition as a lazy inverse LinearAlgera.Diagonal(s::Union{Number,AbstractVector  the lazy Diagonal matrix type of Base.LinearAlgebra Used for efficient construction of a diagonal preconditioner Other  Base.LinearAlgera  types all define the full Preconditioner interface IncompleteLU.ilu  an implementation of the incomplete LU-factorization preconditioner This requires  A  as a  SparseMatrixCSC  Preconditioners.CholeskyPreconditioner(A i  An incomplete Cholesky preconditioner with cut-off level  i  Requires  A  as a  AbstractMatrix  and positive semi-definite AlgebraicMultiGrid  Implementations of the algebraic multigrid method Must be converted to a preconditioner via  AlgebraicMultiGrid.aspreconditioner(AlgebraicMultiGrid.precmethod(A  Requires  A  as a  AbstractMatrix  Provides the following methods AlgebraicMultiGrid.ruge_stuben(A AlgebraicMultiGrid.smoothed_aggregation(A PyAMG  Implementations of the algebraic multigrid method Must be converted to a preconditioner via  PyAMG.aspreconditioner(PyAMG.precmethod(A  Requires  A  as a  AbstractMatrix  Provides the following methods PyAMG.RugeStubenSolver(A PyAMG.SmoothedAggregationSolver(A ILUZero.ILU0Precon(A::SparseMatrixCSC  b_type  T  An incomplete LU implementation Requires  A  as a  SparseMatrixCSC  LimitedLDLFactorizations.lldl  A limited-memory LDLᵀ factorization for symmetric matrices Requires  A  as a  SparseMatrixCSC  Applying  F  lldl(A F.D  abs.(F.D  before usage as a preconditioner makes the preconditioner symmetric postive definite and thus is required for Krylov methods which are specialized for symmetric linear systems RandomizedPreconditioners.NystromPreconditioner  A randomized sketching method for positive semidefinite matrices  A  Builds a preconditioner  P ≈ A  μ*I  for the system  A  μ*I)x  b"},{"doctype":"document","id":"LinearSolve/tutorials/linear.md","title":"Solving Linear Systems in Julia","text":"A rand b rand prob A b sol solve prob sol u sol solve prob Solving Linear Systems in Julia A linear system Au=b is specified by defining an  AbstractMatrix   A  or by providing a matrix-free operator for performing  A*x  operations via the function  A(u,p,t  out-of-place and  A(du,u,p,t  for in-place For the sake of simplicity this tutorial will only showcase concrete matrices The following defines a matrix and a  LinearProblem  which is subsequently solved by the default linear solver Note that  solve(prob  is equivalent to  solve(prob,nothing  where  nothing  denotes the choice of the default linear solver This is equivalent to the Julia built-in  A\\b  where the solution is recovered via  sol.u  The power of this package comes into play when changing the algorithms For example  IterativeSolvers.jl  has some nice methods like GMRES which can be faster in some cases With LinearSolve.jl there is one interface and changing linear solvers is simply the switch of the algorithm choice Thus a package which uses LinearSolve.jl simply needs to allow the user to pass in an algorithm struct and all wrapped linear solvers are immediately available as tweaks to the general algorithm"},{"doctype":"document","id":"SciMLBase/interfaces/Differentiation.md","title":"[Automatic Differentiation and Sensitivity Algorithms (Adjoints)]( sensealg)","text":"solve prob args sensealg nothing u0 nothing p nothing kwargs u0 u0 nothing u0 prob u0 p p nothing p prob p sensealg nothing haskey prob kwargs sensealg sensealg prob kwargs sensealg solve_up prob sensealg u0 p args kwargs ChainRulesCore frule typeof solve_up prob sensealg Union Nothing u0 p args kwargs _solve_forward prob sensealg u0 p args kwargs ChainRulesCore rrule typeof solve_up prob sensealg Union Nothing u0 p args kwargs _solve_adjoint prob sensealg u0 p args kwargs _concrete_solve_adjoint args kwargs error _concrete_solve_forward args kwargs error Automatic Differentiation and Sensitivity Algorithms Adjoints  sensealg Automatic differentiation control is done through the  sensealg  keyword argument Hooks exist in the high level interfaces for  solve  which shuttle the definitions of automatic differentiation overloads to dispatches defined in DiffEqSensitivity.jl should be renamed SciMLSensitivity.jl as it expands This is done by first entering a top-level  solve  definition for example solve_up  then drops down the differentiable arguments as positional arguments which is required for the  ChainRules.jl  interface Then the  ChainRules  overloads are written on the  solve_up  calls like Default definitions then exist to throw an informative error if the sensitivity mechanism is not added The sensitivity mechanism is kept in a separate package because of the high dependency and load time cost introduced by the automatic differentiation libraries Different choices of automatic differentiation are then selected by the  sensealg  keyword argument in  solve  which is made into a positional argument in the  solve_adjoint  and other functions in order to allow dispatch SensitivityADPassThrough The special sensitivity algorithm  SensitivityADPassThrough  is used to ignore the internal sensitivity dispatches and instead do automatic differentiation directly through the solver Generally this  sensealg  is only used internally Note about ForwardDiff ForwardDiff does not use ChainRules.jl and thus it completely ignores the special handling"},{"doctype":"documentation","id":"references/LinearSolve.set_b","title":"set_b","text":"DocStringExtensions.MethodSignatures"},{"doctype":"documentation","id":"references/SciMLBase.RootfindOpt","title":"RootfindOpt","text":""},{"doctype":"documentation","id":"references/SciMLBase.isconstant","title":"isconstant","text":""},{"doctype":"document","id":"NonlinearSolve/solvers/BracketingSolvers.md","title":"Bracketing Solvers","text":"Bracketing Solvers solve(prob::NonlinearProblem,alg;kwargs Solves for  f(u)=0  in the problem defined by  prob  using the algorithm  alg  If no algorithm is given a default algorithm will be chosen This page is solely focused on the bracketing methods for scalar nonlinear equations Recommended Methods Falsi  can have a faster convergence and is discretely differentiable but is less stable than  Bisection  Full List of Methods NonlinearSolve.jl Falsi  A non-allocating regula falsi method Bisection  A common bisection method"},{"doctype":"documentation","id":"references/SciMLBase.RODEProblem","title":"RODEProblem","text":"Defines a random ordinary differential equation RODE problem Documentation Page https://diffeq.sciml.ai/stable/types/rode_types Mathematical Specification of a RODE Problem To define a RODE Problem you simply need to give the function  f  and the initial condition  u_0  which define an ODE frac{du}{dt  f(u,p,t,W(t where  W(t  is a random process  f  should be specified as  f(u,p,t,W  or in-place as  f(du,u,p,t,W  and  u₀  should be an AbstractArray or number whose geometry matches the desired geometry of  u  Note that we are not limited to numbers or vectors for  u₀  one is allowed to provide  u₀  as arbitrary matrices  higher dimension tensors as well Constructors RODEProblem(f::RODEFunction,u0,tspan,p=NullParameters();noise=WHITE_NOISE,rand_prototype=nothing,callback=nothing RODEProblem{isinplace}(f,u0,tspan,p=NullParameters();noise=WHITE_NOISE,rand_prototype=nothing,callback=nothing,mass_matrix=I   Defines the RODE with the specified functions The default noise is  WHITE_NOISE   isinplace  optionally sets whether the function is inplace or not This is determined automatically but not inferred Parameters are optional and if not given then a  NullParameters  singleton will be used which will throw nice errors if you try to index non-existent parameters Any extra keyword arguments are passed on to the solvers For example if you set a  callback  in the problem then that  callback  will be added in every solve call For specifying Jacobians and mass matrices see the DiffEqFunctions  performance_overloads page Fields f  The drift function in the SDE u0  The initial condition tspan  The timespan for the problem p  The optional parameters for the problem Defaults to  NullParameters  noise  The noise process applied to the noise upon generation Defaults to Gaussian white noise For information on defining different noise processes see the noise process documentation page  noise_process rand_prototype  A prototype type instance for the noise vector It defaults to  nothing  which means the problem should be interpreted as having a noise vector whose size matches  u0  kwargs  The keyword arguments passed onto the solves"},{"doctype":"documentation","id":"references/NonlinearSolve.mic_check","title":"mic_check","text":"mic_check(solver::AbstractImmutableNonlinearSolver mic_check!(solver::AbstractNonlinearSolver Checks before running main solving iterations"},{"doctype":"documentation","id":"references/SciMLBase.AbstractSDDEProblem","title":"AbstractSDDEProblem","text":"DocStringExtensions.TypeDefinition Base for types which define SDDE problems"},{"doctype":"documentation","id":"references/SciMLBase.AbstractEnsembleEstimator","title":"AbstractEnsembleEstimator","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.HermiteInterpolation","title":"HermiteInterpolation","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/NonlinearSolve.jacobian!","title":"jacobian!","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSteadyStateProblem","title":"AbstractSteadyStateProblem","text":""},{"doctype":"documentation","id":"references/SciMLBase.calculate_ensemble_errors","title":"calculate_ensemble_errors","text":""},{"doctype":"documentation","id":"references/LinearSolve.get_KrylovJL_solver","title":"get_KrylovJL_solver","text":""},{"doctype":"documentation","id":"references/LinearSolve.simplelu_solve!","title":"simplelu_solve!","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSciMLOperator","title":"AbstractSciMLOperator","text":"DocStringExtensions.TypeDefinition"},{"doctype":"document","id":"SciMLBase/interfaces/Solutions.md","title":"SciMLSolutions","text":"sol j sol t j sol i j sol i k j sol i SciMLSolutions Definition of the SciMLSolution Interface All  SciMLSolution  types are a subset of some  AbstractArray  Types with time series like  ODESolution  are subtypes of  RecursiveArrayTools.AbstractVectorOfArray  and  RecursiveArrayTools.AbstractDiffEqArray  where appropriate Types without a time series like  OptimizationSolution  are directly subsets of  AbstractArray  Array Interface Instead of working on the  Vector{uType  directly we can use the provided array interface to access the value at timestep  j  if the timeseries was saved and to access the value of  t  at timestep  j  For multi-dimensional systems this will address first by component and lastly by time and thus will be the  i th component at timestep  j  Hence  sol[j][i  sol[i j  This is done because Julia is column-major so the leading dimension should be contiguous in memory If the independent variables had shape for example was a matrix then  i  is the linear index We can also access solutions with shape gives the  i,k  component of the system at timestep  j  The colon operator is supported meaning that gives the timeseries for the  i th component Common Field Names u  the solution values t  the independent variable values matching the length of the solution if applicable resid  the residual of the solution if applicable original  the solution object from the original solver if it's a wrapper algorithm retcode  see the documentation section on return codes prob  the problem that was solved alg  the algorithm used to solve the problem Return Codes RetCodes  retcodes The solution types have a  retcode  field which returns a symbol signifying the error state of the solution The retcodes are as follows Default  The solver did not set retcodes Success  The integration completed without erroring or the steady state solver from  SteadyStateDiffEq  found the steady state Terminated  The integration is terminated with  terminate!(integrator  Note that this may occur by using  TerminateSteadyState  from the callback library  DiffEqCallbacks  MaxIters  The integration exited early because it reached its maximum number of iterations DtLessThanMin  The timestep method chose a stepsize which is smaller than the allowed minimum timestep and exited early Unstable  The solver detected that the solution was unstable and exited early InitialFailure  The DAE solver could not find consistent initial conditions ConvergenceFailure  The internal implicit solvers failed to converge Failure  General uncategorized failures or errors Traits SciMLSolution API Abstract SciML Solutions Concrete SciML Solutions"},{"doctype":"documentation","id":"references/SciMLBase.has_colorvec","title":"has_colorvec","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.Bisection","title":"Bisection","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSteadyStateIntegrator","title":"AbstractSteadyStateIntegrator","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/NonlinearSolve.alg_cache","title":"alg_cache","text":""},{"doctype":"documentation","id":"references/SciMLBase.SplitSDEFunction","title":"SplitSDEFunction","text":"iip recompile f1 f2 g mass_matrix I analytic nothing tgrad nothing jac nothing jvp nothing vjp nothing ggprime nothing jac_prototype nothing sparsity jac_prototype paramjac nothing syms nothing indepsym nothing colorvec nothing SplitSDEFunction  AbstractSDEFunction A representation of a split SDE function  f  defined by M frac{du}{dt  f_1(u,p,t  f_2(u,p,t  g(u,p,t dW and all of its related functions such as the Jacobian of  f  its gradient with respect to time and more For all cases  u0  is the initial condition  p  are the parameters and  t  is the independent variable Generally for SDE integrators the  f_1  portion should be considered the stiff portion of the model with larger time scale separation while the  f_2  portion should be considered the non-stiff portion This interpretation is directly used in integrators like IMEX implicit-explicit integrators and exponential integrators Constructor Note that only the function  f  itself is required All of the remaining functions are optional for improving or accelerating the usage of  f  These include mass_matrix  the mass matrix  M  represented in the SDE function Can be used to determine that the equation is actually a stochastic differential-algebraic equation SDAE if  M  is singular Note that in this case special solvers are required see the DAE solver page for more details https://diffeq.sciml.ai/stable/solvers/sdae_solve Must be an AbstractArray or an AbstractSciMLOperator analytic(u0,p,t  used to pass an analytical solution function for the analytical  solution of the ODE Generally only used for testing and development of the solvers tgrad(dT,u,p,t  or dT=tgrad(u,p,t returns  frac{\\partial f_1(u,p,t)}{\\partial t jac(J,u,p,t  or  J=jac(u,p,t  returns  frac{df_1}{du jvp(Jv,v,u,p,t  or  Jv=jvp(v,u,p,t  returns the directional derivative frac{df_1}{du v vjp(Jv,v,u,p,t  or  Jv=vjp(v,u,p,t  returns the adjoint derivative frac{df_1}{du}^\\ast v ggprime(J,u,p,t  or  J  ggprime(u,p,t  returns the Milstein derivative   frac{dg(u,p,t)}{du g(u,p,t jac_prototype  a prototype matrix matching the type that matches the Jacobian For example if the Jacobian is tridiagonal then an appropriately sized  Tridiagonal  matrix can be used as the prototype and integrators will specialize on this structure where possible Non-structured sparsity patterns should use a  SparseMatrixCSC  with a correct sparsity pattern for the Jacobian The default is  nothing  which means a dense Jacobian paramjac(pJ,u,p,t  returns the parameter Jacobian  frac{df_1}{dp  syms  the symbol names for the elements of the equation This should match  u0  in size For example if  u0  0.0,1.0  and  syms  x y  this will apply a canonical naming to the values allowing  sol[:x  in the solution and automatically naming values in plots indepsym  the canonical naming for the independent variable Defaults to nothing which internally uses  t  as the representation in any plots colorvec  a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the  jac_prototype  This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern Defaults to  nothing  which means a color vector will be internally computed on demand when required The cost of this operation is highly dependent on the sparsity pattern Note on the Derivative Definition The derivatives such as the Jacobian are only defined on the  f1  portion of the split ODE This is used to treat the  f1  implicit while keeping the  f2  portion explicit iip In-Place vs Out-Of-Place For more details on this argument see the ODEFunction documentation recompile Controlling Compilation and Specialization For more details on this argument see the ODEFunction documentation Fields The fields of the SplitSDEFunction type directly match the names of the inputs"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timeseries_steps_quantile","title":"timeseries_steps_quantile","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.@add_kwonly","title":"@add_kwonly","text":"Define keyword-only version of the  function_definition  expands to"},{"doctype":"documentation","id":"references/SciMLBase.DISCRETE_INPLACE_DEFAULT","title":"DISCRETE_INPLACE_DEFAULT","text":""},{"doctype":"documentation","id":"references/SciMLBase.SecondOrderODEProblem","title":"SecondOrderODEProblem","text":"f du0 u0 tspan callback Defines a second order ordinary differential equation ODE problem Documentation Page https://diffeq.sciml.ai/stable/types/dynamical_types Mathematical Specification of a 2nd Order ODE Problem To define a 2nd Order ODE Problem you simply need to give the function  f  and the initial condition  u_0  which define an ODE u  f(u',u,p,t f  should be specified as  f(du,u,p,t  or in-place as  f(ddu,du,u,p,t  and  u₀  should be an AbstractArray or number whose geometry matches the desired geometry of  u  Note that we are not limited to numbers or vectors for  u₀  one is allowed to provide  u₀  as arbitrary matrices  higher dimension tensors as well From this form a dynamical ODE v  f(v,u,p,t \nu  v  is generated Constructors Defines the ODE with the specified functions Fields f  The function for the second derivative du0  The initial derivative u0  The initial condition tspan  The timespan for the problem callback  A callback to be applied to every solver which uses the problem Defaults to nothing"},{"doctype":"documentation","id":"references/SciMLBase.has_vjp","title":"has_vjp","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timepoint_mean","title":"timepoint_mean","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractDiffEqInterpolation","title":"AbstractDiffEqInterpolation","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/LinearSolve.InvPreconditioner","title":"InvPreconditioner","text":""},{"doctype":"documentation","id":"references/SciMLBase.SplitODEProblem","title":"SplitODEProblem","text":"f u0 tspan p kwargs f1 f2 u0 tspan p kwargs Defines a split ordinary differential equation ODE problem Documentation Page https://diffeq.sciml.ai/stable/types/split ode types Mathematical Specification of a Split ODE Problem To define a  SplitODEProblem  you simply need to give a two functions   f_1  and  f_2  along with an initial condition  u_0  which define an ODE frac{du}{dt   f_1(u,p,t  f_2(u,p,t f  should be specified as  f(u,p,t  or in-place as  f(du,u,p,t  and  u₀  should be an AbstractArray or number whose geometry matches the desired geometry of  u  Note that we are not limited to numbers or vectors for  u₀  one is allowed to provide  u₀  as arbitrary matrices  higher dimension tensors as well Many splits are at least partially linear That is the equation frac{du}{dt   Au  f_2(u,p,t For how to define a linear function  A  see the documentation for the  DiffEqOperators  Constructors The  isinplace  parameter can be omitted and will be determined using the signature of  f2  Note that both  f1  and  f2  should support the in-place style if  isinplace  is  true  or they should both support the out-of-place style if  isinplace  is  false  You cannot mix up the two styles Parameters are optional and if not given then a  NullParameters  singleton will be used which will throw nice errors if you try to index non-existent parameters Any extra keyword arguments are passed on to the solvers For example if you set a  callback  in the problem then that  callback  will be added in every solve call Under the hood a  SplitODEProblem  is just a regular  ODEProblem  whose  f  is a  SplitFunction  Therefore you can solve a  SplitODEProblem  using the same solvers for  ODEProblem  For solvers dedicated to split problems see Split ODE Solvers  split_ode_solve For specifying Jacobians and mass matrices see the DiffEqFunctions  performance_overloads page Fields f1   f2  The functions in the ODE u0  The initial condition tspan  The timespan for the problem p  The parameters for the problem Defaults to  NullParameters kwargs  The keyword arguments passed onto the solves DocStringExtensions.MethodSignatures Define a split ODE problem from a  SplitFunction "},{"doctype":"documentation","id":"references/SciMLBase.NoiseProblem","title":"NoiseProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.LeftRootFind","title":"LeftRootFind","text":""},{"doctype":"documentation","id":"references/SciMLBase.IntegralSolution","title":"IntegralSolution","text":"DocStringExtensions.TypeDefinition Representation of the solution to an quadrature integral_lb^ub f(x dx defined by a IntegralProblem Fields u  the representation of the optimization's solution resid  the residual of the solver alg  the algorithm type used by the solver retcode  the return code from the solver Used to determine whether the solver solved successfully  sol.retcode  Success  whether it terminated due to a user-defined callback  sol.retcode  Terminated  or whether it exited due to an error For more details see the return code section of the DifferentialEquations.jl documentation chi  the variance estimate of the estimator from Monte Carlo quadrature methods"},{"doctype":"document","id":"NonlinearSolve/basics/NonlinearProblem.md","title":"Nonlinear Problems","text":"Nonlinear Problems"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timeseries_steps_weighted_meancov","title":"timeseries_steps_weighted_meancov","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractEnsembleSolution","title":"AbstractEnsembleSolution","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.AbstractDynamicalODEProblem","title":"AbstractDynamicalODEProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.BVProblem","title":"BVProblem","text":"f bc! u0 tspan p kwargs f bc! u0 tspan p kwargs bc! residual u p t Defines an BVP problem Documentation Page https://diffeq.sciml.ai/stable/types/bvp_types Mathematical Specification of a BVP Problem To define a BVP Problem you simply need to give the function  f  and the initial condition  u_0  which define an ODE frac{du}{dt  f(u,p,t along with an implicit function  bc  which defines the residual equation where bc(u,p,t  0 is the manifold on which the solution must live A common form for this is the two-point  BVProblem  where the manifold defines the solution at two points u(t_0  a\nu(t_f  b Problem Type Constructors For any BVP problem type  bc  is the inplace function where  residual  computed from the current  u   u  is an array of solution values where  u[i  is at time  t[i  while  p  are the parameters For a  TwoPointBVProblem   t  tspan  For the more general  BVProblem   u  can be all of the internal time points and for shooting type methods  u=sol  the ODE solution Note that all features of the  ODESolution  are present in this form In both cases the size of the residual matches the size of the initial condition Parameters are optional and if not given then a  NullParameters  singleton will be used which will throw nice errors if you try to index non-existent parameters Any extra keyword arguments are passed on to the solvers For example if you set a  callback  in the problem then that  callback  will be added in every solve call Fields f  The function for the ODE bc  The boundary condition function u0  The initial condition Either the initial condition for the ODE as an initial value problem or a  Vector  of values for  u(t_i  for collocation methods tspan  The timespan for the problem p  The parameters for the problem Defaults to  NullParameters kwargs  The keyword arguments passed onto the solves"},{"doctype":"documentation","id":"references/SciMLBase.QuadratureSolution","title":"QuadratureSolution","text":""},{"doctype":"documentation","id":"references/SciMLBase.LinearInterpolation","title":"LinearInterpolation","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.AbstractTimeseriesSolution","title":"AbstractTimeseriesSolution","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/NonlinearSolve.DEFAULT_NORM","title":"DEFAULT_NORM","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.BisectionCache","title":"BisectionCache","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timeseries_steps_meancov","title":"timeseries_steps_meancov","text":""},{"doctype":"documentation","id":"references/SciMLBase.__has_indepsym","title":"__has_indepsym","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.Falsi","title":"Falsi","text":""},{"doctype":"documentation","id":"references/SciMLBase.isautodifferentiable","title":"isautodifferentiable","text":"isautodifferentiable(alg::DEAlgorithm Trait declaration for whether an algorithm is compatible with direct automatic differentiation i.e can have algorithms like ForwardDiff or ReverseDiff attempt to differentiate directly through the solver Defaults to false as only pure-Julia algorithms can have this be true"},{"doctype":"documentation","id":"references/NonlinearSolve.Retcode","title":"Retcode","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timepoint_meancov","title":"timepoint_meancov","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.get_timepoint","title":"get_timepoint","text":""},{"doctype":"documentation","id":"references/SciMLBase.augment","title":"augment","text":""},{"doctype":"document","id":"NonlinearSolve/solvers/NonlinearSystemSolvers.md","title":"[Nonlinear System Solvers]( nonlinearsystemsolvers)","text":"NLSolveJL method trust_region autodiff central store_trace extended_trace linesearch LineSearches Static linsolve x A b copyto! x A b factor one Float64 autoscale m beta one Float64 show_trace KINSOL linear_solver Dense jac_upper jac_lower userdata nothing Nonlinear System Solvers  nonlinearsystemsolvers solve(prob::NonlinearProblem,alg;kwargs Solves for  f(u)=0  in the problem defined by  prob  using the algorithm  alg  If no algorithm is given a default algorithm will be chosen This page is solely focused on the methods for nonlinear systems Recommended Methods NewtonRaphson  is a good choice for most problems It is non-allocating on static arrays and thus really well-optimized for small systems while for large systems it can make use of sparsity patterns for sparse automatic differentiation and sparse linear solving of very large systems That said as a classic Newton method its stability region can be smaller than other methods  NLSolveJL s  trust_region  method can be a good choice for high stability along with  CMINPACK  For a system which is very non-stiff i.e the condition number of the Jacobian is small or the eigenvalues of the Jacobian are within a few orders of magnitude then  NLSolveJL s  anderson  can be a good choice Full List of Methods NonlinearSolve.jl These are the core solvers NewtonRaphson(;autodiff=true,chunk_size=12,diff_type=Val{:forward},linsolve=DEFAULT_LINSOLVE  A Newton-Raphson method with swappable nonlinear solvers and autodiff methods for high performance on large and sparse systems When used on objects like static arrays this method is non-allocating SciMLNLSolve.jl This is a wrapper package for importing solvers from other packages into this interface Note that these solvers do not come by default and thus one needs to install the package before using these solvers CMINPACK  A wrapper for using the classic MINPACK method through  MINPACK.jl NLSolveJL  A wrapper for  NLsolve.jl Choices for methods in  NLSolveJL  fixedpoint  Fixed-point iteration anderson  Anderson-accelerated fixed-point iteration newton  Classical Newton method with an optional line search trust_region  Trust region Newton method the default choice For more information on these arguments consult the  NLsolve.jl documentation  Sundials.jl This is a wrapper package for the SUNDIALS C library specifically the KINSOL nonlinear solver included in that ecosystem Note that these solvers do not come by default and thus one needs to install the package before using these solvers KINSOL  The KINSOL method of the SUNDIALS C library The choices for the linear solver are Dense  A dense linear solver Band  A solver specialized for banded Jacobians If used you must set the position of the upper and lower non-zero diagonals via  jac_upper  and  jac_lower  LapackDense  A version of the dense linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations This will be faster than  Dense  on larger systems but has noticeable overhead on smaller 100 ODE systems LapackBand  A version of the banded linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations This will be faster than  Band  on larger systems but has noticeable overhead on smaller 100 ODE systems Diagonal  This method is specialized for diagonal Jacobians GMRES  A GMRES method Recommended first choice Krylov method BCG  A biconjugate gradient method PCG  A preconditioned conjugate gradient method Only for symmetric linear systems TFQMR  A TFQMR method KLU  A sparse factorization method Requires that the user specify a Jacobian The Jacobian must be set as a sparse matrix in the  ODEProblem  type"},{"doctype":"documentation","id":"references/SciMLBase.rerun_warn","title":"rerun_warn","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSDDEAlgorithm","title":"AbstractSDDEAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.has_observed","title":"has_observed","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractDiscreteProblem","title":"AbstractDiscreteProblem","text":"DocStringExtensions.TypeDefinition Base for types which define discrete problems"},{"doctype":"documentation","id":"references/SciMLBase.AbstractRODEFunction","title":"AbstractRODEFunction","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.componentwise_meancov","title":"componentwise_meancov","text":""},{"doctype":"documentation","id":"references/SciMLBase.get_tmp_cache","title":"get_tmp_cache","text":"Returns a tuple of internal cache vectors which are safe to use as temporary arrays This should be used for integrator interface and callbacks which need arrays to write into in order to be non-allocating The length of the tuple is dependent on the method"},{"doctype":"documentation","id":"references/LinearSolve.KrylovKitJL_GMRES","title":"KrylovKitJL_GMRES","text":""},{"doctype":"documentation","id":"references/SciMLBase.check_error!","title":"check_error!","text":"Same as  check_error  but also set solution's return code  integrator.sol.retcode  and run  postamble "},{"doctype":"documentation","id":"references/SciMLBase.u_cache","title":"u_cache","text":""},{"doctype":"documentation","id":"references/SciMLBase.wrapfun_oop","title":"wrapfun_oop","text":""},{"doctype":"documentation","id":"references/SciMLBase.set_t!","title":"set_t!","text":"Set current time point of the  integrator  to  t "},{"doctype":"documentation","id":"references/SciMLBase.plot_indices","title":"plot_indices","text":""},{"doctype":"documentation","id":"references/LinearSolve.defaultalg","title":"defaultalg","text":""},{"doctype":"documentation","id":"references/SciMLBase","title":"SciMLBase","text":""},{"doctype":"documentation","id":"references/LinearSolve.AbstractSolveFunction","title":"AbstractSolveFunction","text":""},{"doctype":"documentation","id":"references/SciMLBase.DEFAULT_OBSERVED","title":"DEFAULT_OBSERVED","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.AbstractBracketingAlgorithm","title":"AbstractBracketingAlgorithm","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSecondOrderODEAlgorithm","title":"AbstractSecondOrderODEAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.has_indepsym","title":"has_indepsym","text":""},{"doctype":"document","id":"LinearSolve/advanced/custom.md","title":"Passing in a Custom Linear Solver","text":"LinearAlgebra my_linsolve A b u p newA Pl Pr solverdata verbose kwargs verbose println u A b u prob Diagonal rand rand alg my_linsolve sol solve prob alg my_linsolve! A b u p newA Pl Pr solverdata verbose kwargs verbose println u A b u alg my_linsolve! sol solve prob alg Passing in a Custom Linear Solver Julia users are building a wide variety of applications in the SciML ecosystem often requiring problem-specific handling of their linear solves As existing solvers in  LinearSolve.jl  may not be optimally suited for novel applications it is essential for the linear solve interface to be easily extendable by users To that end the linear solve algorithm  LinearSolveFunction  accepts a user-defined function for handling the solve A user can pass in their custom linear solve function say  my_linsolve  to  LinearSolveFunction  A contrived example of solving a linear system with a custom solver is below The inputs to the function are as follows A  the linear operator b  the right-hand-side u  the solution initialized as  zero(b  p  a set of parameters newA  a  Bool  which is  true  if  A  has been modified since last solve Pl  left-preconditioner Pr  right-preconditioner solverdata  solver cache set to  nothing  if solver hasn't been initialized kwargs  standard SciML keyword arguments such as  verbose   maxiters   abstol   reltol The function  my_linsolve  must accept the above specified arguments and return the solution  u  As memory for  u  is already allocated the user may choose to modify  u  in place as follows"},{"doctype":"documentation","id":"references/SciMLBase.cleansyms","title":"cleansyms","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.EXACT_SOLUTION_LEFT","title":"EXACT_SOLUTION_LEFT","text":""},{"doctype":"documentation","id":"references/SciMLBase.set_proposed_dt!","title":"set_proposed_dt!","text":"Sets the proposed  dt  for the next timestep If second argument isa  DEIntegrator  then it sets the timestepping of first argument to match that of second one Note that due to PI control and step acceleration this is more than matching the factors in most cases"},{"doctype":"documentation","id":"references/SciMLBase.SplitSDEProblem","title":"SplitSDEProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.AbstractRODEIntegrator","title":"AbstractRODEIntegrator","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/LinearSolve.KrylovJL_GMRES","title":"KrylovJL_GMRES","text":""},{"doctype":"documentation","id":"references/SciMLBase.add_labels!","title":"add_labels!","text":""},{"doctype":"documentation","id":"references/SciMLBase.ratenoise_cache","title":"ratenoise_cache","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timestep_meancov","title":"timestep_meancov","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractBVProblem","title":"AbstractBVProblem","text":"DocStringExtensions.TypeDefinition Base for types which define BVP problems"},{"doctype":"documentation","id":"references/SciMLBase.AbstractODEIntegrator","title":"AbstractODEIntegrator","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/NonlinearSolve.value","title":"value","text":""},{"doctype":"documentation","id":"references/SciMLBase.OptimizationFunction","title":"OptimizationFunction","text":"f AutoZygote OptimizationFunction  AbstractOptimizationFunction A representation of an optimization of an objective function  f  defined by min_{u f(u,p and all of its related functions such as the gradient of  f  its Hessian and more For all cases  u  is the state and  p  are the parameters Constructor OptimizationFunction(f,adtype::AbstractADType=NoAD grad=nothing,hess=nothing,hv=nothing cons=nothing cons_j=nothing,cons_h=nothing hess_prototype=nothing,cons_jac_prototype=nothing cons_hess_prototype  nothing syms  nothing hess_colorvec  nothing cons_jac_colorvec  nothing cons_hess_colorvec  nothing adtype  see the section Defining Optimization Functions via AD grad(G,u,p  or  G=grad(u,p  the gradient of  f  with respect to  u hess(H,u,p  or  H=hess(u,p  the Hessian of  f  with respect to  u hv(Hv,u,v,p  or  Hv=hv(u,v,p  the Hessian-vector product  rac{d^2 f}{du^2 v  cons(res,x,p  or  res=cons(x,p  the equality constraints vector where the constraints are satisfied when  res  0  cons_j(res,x,p  or  res=cons_j(x,p  the Jacobian of the equality constraints cons_h(res,x,p  or  res=cons_h(x,p  the Hessian of the equality constratins provided as and array of Hessians with  res[i  being the Hessian with respect to the  i th output on  cons  paramjac(pJ,u,p  returns the parameter Jacobian  rac{df}{dp  hess_prototype  a prototype matrix matching the type that matches the Hessian For example if the Hessian is tridiagonal then an appropriately sized  Hessian  matrix can be used as the prototype and integrators will specialize on this structure where possible Non-structured sparsity patterns should use a  SparseMatrixCSC  with a correct sparsity pattern for the Hessian The default is  nothing  which means a dense Hessian cons_jac_prototype  a prototype matrix matching the type that matches the constraint Jacobian The default is  nothing  which means a dense constraint Jacobian cons_hess_prototype  a prototype matrix matching the type that matches the constraint Hessian This is defined as an array of matrices where  hess[i  is the Hessian w.r.t the  i th output For example if the Hessian is sparse then  hess  is a  Vector{SparseMatrixCSC  The default is  nothing  which means a dense constraint Hessian syms  the symbol names for the elements of the equation This should match  u0  in size For example if  u  0.0,1.0  and  syms  x y  this will apply a canonical naming to the values allowing  sol[:x  in the solution and automatically naming values in plots hess_colorvec  a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the  hess_prototype  This specializes the Hessian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern Defaults to  nothing  which means a color vector will be internally computed on demand when required The cost of this operation is highly dependent on the sparsity pattern cons_jac_colorvec  a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the  cons_jac_prototype  cons_hess_colorvec  an array of color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the  cons_hess_prototype  Defining Optimization Functions Via AD While using the keyword arguments gives the user control over defining all of the possible functions the simplest way to handle the generation of an  OptimizationFunction  is by specifying an AD type By doing so this will automatically fill in all of the extra functions For example will use  Zygote.jl  to define all of the necessary functions Note that if any functions are defined directly the auto-AD definition does not overwrite the user's choice Each of the AD-based constructors are documented separately via their own dispatches iip In-Place vs Out-Of-Place For more details on this argument see the ODEFunction documentation recompile Controlling Compilation and Specialization For more details on this argument see the ODEFunction documentation Fields The fields of the OptimizationFunction type directly match the names of the inputs"},{"doctype":"document","id":"LinearSolve/basics/CachingAPI.md","title":"Caching Interface API Functions","text":"Caching Interface API Functions"},{"doctype":"documentation","id":"references/SciMLBase.INITIALIZE_DEFAULT","title":"INITIALIZE_DEFAULT","text":""},{"doctype":"documentation","id":"references/SciMLBase.PDEProblem","title":"PDEProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.add_kwonly","title":"add_kwonly","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.value_derivative","title":"value_derivative","text":"value_derivative(f x Compute  f(x d/dx f(x  in the most efficient way"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timestep_meanvar","title":"timestep_meanvar","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractAnalyticalSolution","title":"AbstractAnalyticalSolution","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.sym_to_index","title":"sym_to_index","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractQuadratureAlgorithm","title":"AbstractQuadratureAlgorithm","text":""},{"doctype":"documentation","id":"references/SciMLBase.AnalyticalProblem","title":"AnalyticalProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.update_coefficients","title":"update_coefficients","text":""},{"doctype":"documentation","id":"references/SciMLBase.SDEFunction","title":"SDEFunction","text":"iip recompile f g mass_matrix I analytic nothing tgrad nothing jac nothing jvp nothing vjp nothing ggprime nothing jac_prototype nothing sparsity jac_prototype paramjac nothing syms nothing indepsym nothing colorvec nothing SDEFunction  AbstractSDEFunction A representation of an SDE function  f  defined by M du  f(u,p,t)dt  g(u,p,t dW and all of its related functions such as the Jacobian of  f  its gradient with respect to time and more For all cases  u0  is the initial condition  p  are the parameters and  t  is the independent variable Constructor Note that only the function  f  itself is required This function should be given as  f!(du,u,p,t  or  du  f(u,p,t  See the section on  iip  for more details on in-place vs out-of-place handling All of the remaining functions are optional for improving or accelerating  the usage of  f  These include mass_matrix  the mass matrix  M  represented in the ODE function Can be used to determine that the equation is actually a differential-algebraic equation DAE if  M  is singular Note that in this case special solvers are required see the DAE solver page for more details https://diffeq.sciml.ai/stable/solvers/dae_solve Must be an AbstractArray or an AbstractSciMLOperator analytic(u0,p,t  used to pass an analytical solution function for the analytical  solution of the ODE Generally only used for testing and development of the solvers tgrad(dT,u,p,t  or dT=tgrad(u,p,t returns  frac{\\partial f(u,p,t)}{\\partial t jac(J,u,p,t  or  J=jac(u,p,t  returns  frac{df}{du jvp(Jv,v,u,p,t  or  Jv=jvp(v,u,p,t  returns the directional derivative frac{df}{du v vjp(Jv,v,u,p,t  or  Jv=vjp(v,u,p,t  returns the adjoint derivative frac{df}{du}^\\ast v ggprime(J,u,p,t  or  J  ggprime(u,p,t  returns the Milstein derivative   frac{dg(u,p,t)}{du g(u,p,t jac_prototype  a prototype matrix matching the type that matches the Jacobian For example if the Jacobian is tridiagonal then an appropriately sized  Tridiagonal  matrix can be used as the prototype and integrators will specialize on this structure where possible Non-structured sparsity patterns should use a  SparseMatrixCSC  with a correct sparsity pattern for the Jacobian The default is  nothing  which means a dense Jacobian paramjac(pJ,u,p,t  returns the parameter Jacobian  frac{df}{dp  syms  the symbol names for the elements of the equation This should match  u0  in size For example if  u0  0.0,1.0  and  syms  x y  this will apply a canonical naming to the values allowing  sol[:x  in the solution and automatically naming values in plots indepsym  the canonical naming for the independent variable Defaults to nothing which internally uses  t  as the representation in any plots colorvec  a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the  jac_prototype  This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern Defaults to  nothing  which means a color vector will be internally computed on demand when required The cost of this operation is highly dependent on the sparsity pattern iip In-Place vs Out-Of-Place For more details on this argument see the ODEFunction documentation recompile Controlling Compilation and Specialization For more details on this argument see the ODEFunction documentation Fields The fields of the ODEFunction type directly match the names of the inputs"},{"doctype":"documentation","id":"references/LinearSolve.SciMLSolution","title":"SciMLSolution","text":""},{"doctype":"documentation","id":"references/SciMLBase.DynamicalODEFunction","title":"DynamicalODEFunction","text":"iip recompile f1 f2 mass_matrix I analytic nothing tgrad nothing jac nothing jvp nothing vjp nothing jac_prototype nothing sparsity jac_prototype paramjac nothing syms nothing indepsym nothing colorvec nothing DynamicalODEFunction  AbstractODEFunction A representation of an ODE function  f  defined by M frac{du}{dt  f(u,p,t as a partitioned ODE M_1 frac{du}{dt  f_1(u,p,t)\nM_2 frac{du}{dt  f_2(u,p,t and all of its related functions such as the Jacobian of  f  its gradient with respect to time and more For all cases  u0  is the initial condition  p  are the parameters and  t  is the independent variable Constructor Note that only the functions  f_i  themselves are required These functions should be given as  f_i!(du,u,p,t  or  du  f_i(u,p,t  See the section on  iip  for more details on in-place vs out-of-place handling All of the remaining functions are optional for improving or accelerating  the usage of  f  These include mass_matrix  the mass matrix  M_i  represented in the ODE function Can be used to determine that the equation is actually a differential-algebraic equation DAE if  M  is singular Note that in this case special solvers are required see the DAE solver page for more details https://diffeq.sciml.ai/stable/solvers/dae*solve Must be an AbstractArray or an AbstractSciMLOperator Should be given as a tuple of mass matrices i.e  M*1 M_2  for the mass matrices of equations 1 and 2 respectively analytic(u0,p,t  used to pass an analytical solution function for the analytical  solution of the ODE Generally only used for testing and development of the solvers tgrad(dT,u,p,t  or dT=tgrad(u,p,t returns  frac{\\partial f(u,p,t)}{\\partial t jac(J,u,p,t  or  J=jac(u,p,t  returns  frac{df}{du jvp(Jv,v,u,p,t  or  Jv=jvp(v,u,p,t  returns the directional derivative frac{df}{du v vjp(Jv,v,u,p,t  or  Jv=vjp(v,u,p,t  returns the adjoint derivative frac{df}{du}^\\ast v jac_prototype  a prototype matrix matching the type that matches the Jacobian For example if the Jacobian is tridiagonal then an appropriately sized  Tridiagonal  matrix can be used as the prototype and integrators will specialize on this structure where possible Non-structured sparsity patterns should use a  SparseMatrixCSC  with a correct sparsity pattern for the Jacobian The default is  nothing  which means a dense Jacobian paramjac(pJ,u,p,t  returns the parameter Jacobian  frac{df}{dp  syms  the symbol names for the elements of the equation This should match  u0  in size For example if  u0  0.0,1.0  and  syms  x y  this will apply a canonical naming to the values allowing  sol[:x  in the solution and automatically naming values in plots indepsym  the canonical naming for the independent variable Defaults to nothing which internally uses  t  as the representation in any plots colorvec  a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the  jac_prototype  This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern Defaults to  nothing  which means a color vector will be internally computed on demand when required The cost of this operation is highly dependent on the sparsity pattern iip In-Place vs Out-Of-Place For more details on this argument see the ODEFunction documentation recompile Controlling Compilation and Specialization For more details on this argument see the ODEFunction documentation Fields The fields of the DynamicalODEFunction type directly match the names of the inputs"},{"doctype":"documentation","id":"references/LinearSolve.set_A","title":"set_A","text":"DocStringExtensions.MethodSignatures"},{"doctype":"documentation","id":"references/SciMLBase.SplitFunction","title":"SplitFunction","text":"iip recompile f1 f2 mass_matrix I analytic nothing tgrad nothing jac nothing jvp nothing vjp nothing jac_prototype nothing sparsity jac_prototype paramjac nothing syms nothing indepsym nothing colorvec nothing SplitFunction  AbstractODEFunction A representation of a split ODE function  f  defined by M frac{du}{dt  f_1(u,p,t  f_2(u,p,t and all of its related functions such as the Jacobian of  f  its gradient with respect to time and more For all cases  u0  is the initial condition  p  are the parameters and  t  is the independent variable Generally for ODE integrators the  f_1  portion should be considered the stiff portion of the model with larger time scale separation while the  f_2  portion should be considered the non-stiff portion This interpretation is directly used in integrators like IMEX implicit-explicit integrators and exponential integrators Constructor Note that only the functions  f_i  themselves are required These functions should be given as  f_i!(du,u,p,t  or  du  f_i(u,p,t  See the section on  iip  for more details on in-place vs out-of-place handling All of the remaining functions are optional for improving or accelerating  the usage of  f  These include mass_matrix  the mass matrix  M  represented in the ODE function Can be used to determine that the equation is actually a differential-algebraic equation DAE if  M  is singular Note that in this case special solvers are required see the DAE solver page for more details https://diffeq.sciml.ai/stable/solvers/dae_solve Must be an AbstractArray or an AbstractSciMLOperator analytic(u0,p,t  used to pass an analytical solution function for the analytical  solution of the ODE Generally only used for testing and development of the solvers tgrad(dT,u,p,t  or dT=tgrad(u,p,t returns  frac{\\partial f_1(u,p,t)}{\\partial t jac(J,u,p,t  or  J=jac(u,p,t  returns  frac{df_1}{du jvp(Jv,v,u,p,t  or  Jv=jvp(v,u,p,t  returns the directional derivative frac{df_1}{du v vjp(Jv,v,u,p,t  or  Jv=vjp(v,u,p,t  returns the adjoint derivative frac{df_1}{du}^\\ast v jac_prototype  a prototype matrix matching the type that matches the Jacobian For example if the Jacobian is tridiagonal then an appropriately sized  Tridiagonal  matrix can be used as the prototype and integrators will specialize on this structure where possible Non-structured sparsity patterns should use a  SparseMatrixCSC  with a correct sparsity pattern for the Jacobian The default is  nothing  which means a dense Jacobian paramjac(pJ,u,p,t  returns the parameter Jacobian  frac{df_1}{dp  syms  the symbol names for the elements of the equation This should match  u0  in size For example if  u0  0.0,1.0  and  syms  x y  this will apply a canonical naming to the values allowing  sol[:x  in the solution and automatically naming values in plots indepsym  the canonical naming for the independent variable Defaults to nothing which internally uses  t  as the representation in any plots colorvec  a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the  jac_prototype  This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern Defaults to  nothing  which means a color vector will be internally computed on demand when required The cost of this operation is highly dependent on the sparsity pattern Note on the Derivative Definition The derivatives such as the Jacobian are only defined on the  f1  portion of the split ODE This is used to treat the  f1  implicit while keeping the  f2  portion explicit iip In-Place vs Out-Of-Place For more details on this argument see the ODEFunction documentation recompile Controlling Compilation and Specialization For more details on this argument see the ODEFunction documentation Fields The fields of the SplitFunction type directly match the names of the inputs Symbolically Generating the Functions See the  modelingtoolkitize  function from  ModelingToolkit.jl  for automatically symbolically generating the Jacobian and more from the  numerically-defined functions See  ModelingToolkit.SplitODEProblem  for information on generating the SplitFunction from this symbolic engine"},{"doctype":"documentation","id":"references/SciMLBase.AbstractTimeseriesSolutionRow","title":"AbstractTimeseriesSolutionRow","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleSummary","title":"EnsembleSummary","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.islinear","title":"islinear","text":""},{"doctype":"documentation","id":"references/SciMLBase.full_cache","title":"full_cache","text":"Returns an iterator over the cache arrays of the method This can be used to change internal values as needed"},{"doctype":"documentation","id":"references/SciMLBase.has_exp","title":"has_exp","text":""},{"doctype":"documentation","id":"references/SciMLBase.solution_slice","title":"solution_slice","text":""},{"doctype":"documentation","id":"references/SciMLBase.interp_summary","title":"interp_summary","text":""},{"doctype":"documentation","id":"references/SciMLBase.DEFAULT_PROB_FUNC","title":"DEFAULT_PROB_FUNC","text":""},{"doctype":"documentation","id":"references/LinearSolve.LinearCache","title":"LinearCache","text":""},{"doctype":"documentation","id":"references/SciMLBase.DynamicalDDEFunction","title":"DynamicalDDEFunction","text":"iip recompile f1 f2 mass_matrix I analytic nothing tgrad nothing jac nothing jvp nothing vjp nothing jac_prototype nothing sparsity jac_prototype paramjac nothing syms nothing indepsym nothing colorvec nothing DynamicalDDEFunction  AbstractDDEFunction A representation of a DDE function  f  defined by M frac{du}{dt  f(u,h,p,t as a partitioned ODE M_1 frac{du}{dt  f_1(u,h,p,t)\nM_2 frac{du}{dt  f_2(u,h,p,t and all of its related functions such as the Jacobian of  f  its gradient with respect to time and more For all cases  u0  is the initial condition  p  are the parameters and  t  is the independent variable Constructor Note that only the functions  f_i  themselves are required These functions should be given as  f_i!(du,u,h,p,t  or  du  f_i(u,h,p,t  See the section on  iip  for more details on in-place vs out-of-place handling The histroy function  h  acts as an interpolator over time i.e  h(t  with options matching the solution interface i.e  h(t save_idxs  2  All of the remaining functions are optional for improving or accelerating  the usage of  f  These include mass_matrix  the mass matrix  M_i  represented in the ODE function Can be used to determine that the equation is actually a differential-algebraic equation DAE if  M  is singular Note that in this case special solvers are required see the DAE solver page for more details https://diffeq.sciml.ai/stable/solvers/dae*solve Must be an AbstractArray or an AbstractSciMLOperator Should be given as a tuple of mass matrices i.e  M*1 M_2  for the mass matrices of equations 1 and 2 respectively analytic(u0,h,p,t  used to pass an analytical solution function for the analytical  solution of the ODE Generally only used for testing and development of the solvers tgrad(dT,u,h,p,t  or dT=tgrad(u,h,p,t returns  frac{\\partial f(u,p,t)}{\\partial t jac(J,u,h,p,t  or  J=jac(u,h,p,t  returns  frac{df}{du jvp(Jv,v,u,h,p,t  or  Jv=jvp(v,u,h,p,t  returns the directional derivative frac{df}{du v vjp(Jv,v,u,h,p,t  or  Jv=vjp(v,u,h,p,t  returns the adjoint derivative frac{df}{du}^\\ast v jac_prototype  a prototype matrix matching the type that matches the Jacobian For example if the Jacobian is tridiagonal then an appropriately sized  Tridiagonal  matrix can be used as the prototype and integrators will specialize on this structure where possible Non-structured sparsity patterns should use a  SparseMatrixCSC  with a correct sparsity pattern for the Jacobian The default is  nothing  which means a dense Jacobian paramjac(pJ,u,h,p,t  returns the parameter Jacobian  frac{df}{dp  syms  the symbol names for the elements of the equation This should match  u0  in size For example if  u0  0.0,1.0  and  syms  x y  this will apply a canonical naming to the values allowing  sol[:x  in the solution and automatically naming values in plots indepsym  the canonical naming for the independent variable Defaults to nothing which internally uses  t  as the representation in any plots colorvec  a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the  jac_prototype  This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern Defaults to  nothing  which means a color vector will be internally computed on demand when required The cost of this operation is highly dependent on the sparsity pattern iip In-Place vs Out-Of-Place For more details on this argument see the ODEFunction documentation recompile Controlling Compilation and Specialization For more details on this argument see the ODEFunction documentation Fields The fields of the DynamicalDDEFunction type directly match the names of the inputs"},{"doctype":"documentation","id":"references/SciMLBase.rand_cache","title":"rand_cache","text":""},{"doctype":"documentation","id":"references/SciMLBase.savevalues!","title":"savevalues!","text":"Try to save the state and time variables at the current time point or the  saveat  point by using interpolation when appropriate It returns a tuple that is  saved savedexactly  If  savevalues  saved value then  saved  is true and if  savevalues  saved at the current time point then  savedexactly  is true The saving priority/order is as follows save_on saveat force_save save_everystep"},{"doctype":"documentation","id":"references/SciMLBase.__has_Wfact","title":"__has_Wfact","text":""},{"doctype":"documentation","id":"references/SciMLBase.OptimizationSolution","title":"OptimizationSolution","text":"DocStringExtensions.TypeDefinition Representation of the solution to an nonlinear optimization defined by an OptimizationProblem Fields u  the representation of the optimization's solution prob  the original NonlinearProblem/SteadyStateProblem that was solved alg  the algorithm type used by the solver original  if the solver is wrapped from an alternative solver ecosystem such as Optim.jl then this is the original return from said solver library retcode  the return code from the solver Used to determine whether the solver solved successfully  sol.retcode  Success  whether it terminated due to a user-defined callback  sol.retcode  Terminated  or whether it exited due to an error For more details see the return code section of the DifferentialEquations.jl documentation"},{"doctype":"documentation","id":"references/SciMLBase.AbstractODEFunction","title":"AbstractODEFunction","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.AbstractDAEFunction","title":"AbstractDAEFunction","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/LinearSolve.QRFactorization","title":"QRFactorization","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractAnalyticalProblem","title":"AbstractAnalyticalProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.@def","title":"@def","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractOptimizationAlgorithm","title":"AbstractOptimizationAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleSplitThreads","title":"EnsembleSplitThreads","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.DDEProblem","title":"DDEProblem","text":"DiffEqProblemLibrary ODEProblemLibrary ODEProblemLibrary importodeproblems prob ODEProblemLibrary prob_ode_linear sol solve prob Defines a delay differential equation DDE problem Documentation Page https://diffeq.sciml.ai/stable/types/dde_types Mathematical Specification of a DDE Problem To define a DDE Problem you simply need to give the function  f  the initial condition  u_0  at time point  t_0  and the history function  h  which together define a DDE frac{du}{dt  f(u,h,p,t qquad t geq t_0 u(t_0  u_0 u(t  h(t qquad t  t_0 f  should be specified as  f(u h p t  or in-place as  f(du u h p t   u_0  should be an AbstractArray or number whose geometry matches the desired geometry of  u  and  h  should be specified as described below The history function  h  is accessed for all delayed values Note that we are not limited to numbers or vectors for  u_0  one is allowed to provide  u_0  as arbitrary matrices  higher dimension tensors as well Functional Forms of the History Function The history function  h  can be called in the following ways h(p t  out-of-place calculation h(out p t  in-place calculation h(p t deriv::Type{Val{i  out-of-place calculation of the  i th derivative h(out p t deriv::Type{Val{i  in-place calculation of the  i th derivative h(args idxs  calculation of  h(args  for indices  idxs Note that a dispatch for the supplied history function of matching form is required for whichever function forms are used in the user derivative function  f  Declaring Lags Lags are declared separately from their use One can use any lag by simply using the interpolant of  h  at that point However one should use caution in order to achieve the best accuracy When lags are declared the solvers can more efficiently be more accurate and thus this is recommended Neutral and Retarded Delay Differential Equations Note that the history function specification can be used to specify general retarded arguments i.e  h(p,α(u,t  Neutral delay differential equations can be specified by using the  deriv  value in the history interpolation For example  h(p,t-τ Val{1  returns the first derivative of the history values at time  t-τ  Note that algebraic equations can be specified by using a singular mass matrix Problem Type Constructors Parameter  isinplace  optionally sets whether the function is inplace or not This is determined automatically but not inferred Parameters are optional and if not given then a  NullParameters  singleton will be used which will throw nice errors if you try to index non-existent parameters Any extra keyword arguments are passed on to the solvers For example if you set a  callback  in the problem then that  callback  will be added in every solve call For specifying Jacobians and mass matrices see the DiffEqFunctions  performance_overloads page Arguments f  The function in the DDE u0  The initial condition Defaults to the value  h(p first(tspan  of the history function evaluated at the initial time point h  The history function for the DDE before  t0  tspan  The timespan for the problem p  The parameters with which function  f  is called Defaults to  NullParameters  constant_lags  A collection of constant lags used by the history function  h  Defaults to    dependent_lags  A tuple of functions  u p t  lag  for the state-dependent lags used by the history function  h  Defaults to    neutral  If the DDE is neutral i.e if delays appear in derivative terms order_discontinuity_t0  The order of the discontinuity at the initial time point Defaults to  0  if an initial condition  u0  is provided Otherwise it is forced to be greater or equal than  1  kwargs  The keyword arguments passed onto the solves Dynamical Delay Differential Equations Much like Dynamical ODEs  dynamical_prob a Dynamical DDE is a Partitioned DDE of the form frac{dv}{dt  f_1(u,t,h \n\\frac{du}{dt  f_2(v,h  Constructors Parameter  isinplace  optionally sets whether the function is inplace or not This is determined automatically but not inferred Arguments f  The function in the DDE v0  and  u0  The initial condition Defaults to the values  h(p first(tspan  of the history function evaluated at the initial time point h  The history function for the DDE before  t0  Must return an object with the indices 1 and 2 with the values of  v  and  u  respectively tspan  The timespan for the problem p  The parameters with which function  f  is called Defaults to  NullParameters  constant_lags  A collection of constant lags used by the history function  h  Defaults to    dependent_lags  A tuple of functions  v u p t  lag  for the state-dependent lags used by the history function  h  Defaults to    neutral  If the DDE is neutral i.e if delays appear in derivative terms order_discontinuity_t0  The order of the discontinuity at the initial time point Defaults to  0  if an initial condition  u0  is provided Otherwise it is forced to be greater or equal than  1  kwargs  The keyword arguments passed onto the solves The for dynamical and second order DDEs the history function will return an object with the indicies 1 and 2 defined where  h(p t_prev)[1  is the value of  f_2(v u h p t_{\\mathrm{prev  and  h(p t_prev)[2  is the value of  f_1(v u h p t_{\\mathrm{prev  this is for consistency with the ordering of the intitial conditions in the constructor The supplied history function must also return such a 2-index object which can be accomplished with a tuple  v,u  or vector  v,u  2nd Order Delay Differential Equations To define a 2nd Order DDE Problem you simply need to give the function  f  and the initial condition  u_0  which define an DDE u  f(u',u,h,p,t f  should be specified as  f(du,u,p,t  or in-place as  f(ddu,du,u,p,t  and  u₀  should be an AbstractArray or number whose geometry matches the desired geometry of  u  Note that we are not limited to numbers or vectors for  u₀  one is allowed to provide  u₀  as arbitrary matrices  higher dimension tensors as well From this form a dynamical ODE v  f(v,u,h,p,t \nu  v  Constructors Parameter  isinplace  optionally sets whether the function is inplace or not This is determined automatically but not inferred Arguments f  The function in the DDE du0  and  u0  The initial condition Defaults to the values  h(p first(tspan  of the history function evaluated at the initial time point h  The history function for the DDE before  t0  Must return an object with the indices 1 and 2 with the values of  v  and  u  respectively tspan  The timespan for the problem p  The parameters with which function  f  is called Defaults to  NullParameters  constant_lags  A collection of constant lags used by the history function  h  Defaults to    dependent_lags  A tuple of functions  v u p t  lag  for the state-dependent lags used by the history function  h  Defaults to    neutral  If the DDE is neutral i.e if delays appear in derivative terms order_discontinuity_t0  The order of the discontinuity at the initial time point Defaults to  0  if an initial condition  u0  is provided Otherwise it is forced to be greater or equal than  1  kwargs  The keyword arguments passed onto the solves As above the history function will return an object with indices 1 and 2 with the values of  du  and  u  respectively The supplied history function must also match this return type e.g by returning a 2-element tuple or vector Example Problems Example problems can be found in  DiffEqProblemLibrary.jl  To use a sample problem such as  prob_ode_linear  you can do something like"},{"doctype":"documentation","id":"references/NonlinearSolve.AbstractImmutableNonlinearSolver","title":"AbstractImmutableNonlinearSolver","text":""},{"doctype":"documentation","id":"references/LinearSolve._ldiv!","title":"_ldiv!","text":""},{"doctype":"documentation","id":"references/LinearSolve.isopenblas","title":"isopenblas","text":""},{"doctype":"documentation","id":"references/SciMLBase.__has_Wfact_t","title":"__has_Wfact_t","text":""},{"doctype":"document","id":"SciMLBase/interfaces/PDE.md","title":"The PDE Definition Interface","text":"t t x UnitDisk v w x y z VectorUnitBall The PDE Definition Interface While ODEs  u  f(u,p,t  can be defined by a user-function  f  for PDEs the function form can be different for every PDE How many functions and how many inputs This can always change The SciML ecosystem solves this problem by using  ModelingToolkit.jl  to define  PDESystem  a high-level symbolic description of the PDE to be consumed by other packages The vision for the common PDE interface is that a user should only have to specify their PDE once mathematically and have instant access to everything as simple as a finite difference method with constant grid spacing to something as complex as a distributed multi-GPU discontinuous Galerkin method The key to the common PDE interface is a separation of the symbolic handling from the numerical world All of the discretizers should not solve the PDE but instead be a conversion of the mathematical specification to a numerical problem Preferably the transformation should be to another ModelingToolkit.jl  AbstractSystem  via a  symbolic_discretize  dispatch but in some cases this cannot be done or will not be performant Thus in some cases only a  discretize  definition is given to a  SciMLProblem  with  symbolic_discretize  simply providing diagnostic or lower level information about the construction process These elementary problems such as solving linear systems  Ax=b  solving nonlinear systems  f(x)=0  ODEs etc are all defined by SciMLBase.jl which then numerical solvers can all target these common forms Thus someone who works on linear solvers doesn't necessarily need to be working on a Discontinuous Galerkin or finite element library but instead linear solvers that are good for matrices A with properties  which are then accessible by every other discretization method in the common PDE interface Similar to the rest of the  AbstractSystem  types transformation and analyses functions will allow for simplifying the PDE before solving it and constructing block symbolic functions like Jacobians Constructors Domains WIP Domains are specifying by saying  indepvar in domain  where  indepvar  is a single or a collection of independent variables and  domain  is the chosen domain type A 2-tuple can be used to indicate an  Interval  Thus forms for the  indepvar  can be like Domain Types WIP Interval(a,b  Defines the domain of an interval from  a  to  b  requires explicit import from  DomainSets.jl  but a 2-tuple can be used instead discretize  and  symbolic_discretize The only functions which act on a PDESystem are the following discretize(sys,discretizer  produces the outputted  AbstractSystem  or  SciMLProblem  symbolic_discretize(sys,discretizer  produces a debugging symbolic description of the discretized problem Boundary Conditions WIP Transformations Analyses Discretizer Ecosystem NeuralPDE.jl PhysicsInformedNN NeuralPDE.jl  defines the  PhysicsInformedNN  discretizer which uses a  DiffEqFlux.jl  neural network to solve the differential equation MethodOfLines.jl MOLFiniteDifference WIP MethodOfLines.jl  defines the  MOLFiniteDifference  discretizer which performs a finite difference discretization using the DiffEqOperators.jl stencils These stencils make use of NNLib.jl for fast operations on semi-linear domains"},{"doctype":"documentation","id":"references/SciMLBase.SciMLProblem","title":"SciMLProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timeseries_steps_mean","title":"timeseries_steps_mean","text":""},{"doctype":"documentation","id":"references/SciMLBase.BasicEnsembleAlgorithm","title":"BasicEnsembleAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.AbstractDiscreteFunction","title":"AbstractDiscreteFunction","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.__has_observed","title":"__has_observed","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSensitivitySolution","title":"AbstractSensitivitySolution","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.intervals","title":"intervals","text":""},{"doctype":"document","id":"LinearSolve/basics/FAQ.md","title":"Frequently Asked Questions","text":"LinearAlgebra Pl Diagonal weights Pr Diagonal weights A rand n n b rand n prob A b sol solve prob IterativeSolvers_GMRES Pl Pl Pr Pr LinearAlgebra Pl ComposePreconitioner Diagonal weights realprec Pr Diagonal weights A rand n n b rand n prob A b sol solve prob IterativeSolvers_GMRES Pl Pl Pr Pr Frequently Asked Questions Ask more questions How do I use IterativeSolvers solvers with a weighted tolerance vector IterativeSolvers.jl computes the norm after the application of the left precondtioner  Pl  Thus in order to use a vector tolerance  weights  one can mathematically hack the system via the following formulation If you want to use a real preconditioner under the norm  weights  then one can use  ComposePreconditioner  to apply the preconditioner after the application of the weights like as follows"},{"doctype":"documentation","id":"references/NonlinearSolve.AbstractNewtonAlgorithm","title":"AbstractNewtonAlgorithm","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.max_tdir","title":"max_tdir","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.JacobianWrapper","title":"JacobianWrapper","text":""},{"doctype":"documentation","id":"references/SciMLBase.ConstantInterpolation","title":"ConstantInterpolation","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/NonlinearSolve.BracketingImmutableSolver","title":"BracketingImmutableSolver","text":""},{"doctype":"documentation","id":"references/SciMLBase.DynamicalDDEProblem","title":"DynamicalDDEProblem","text":"DocStringExtensions.TypeDefinition Define a dynamical DDE problem from a  DynamicalDDEFunction  Define a dynamical DDE problem from the two functions  f1  and  f2  Arguments f1  and  f2  The functions in the DDE v0  and  u0  The initial conditions h  The initial history function tspan  The timespan for the problem p  Parameter values for  f1  and  f2  callback  A callback to be applied to every solver which uses the problem Defaults to nothing isinplace  optionally sets whether the function is inplace or not This is determined automatically but not inferred"},{"doctype":"documentation","id":"references/SciMLBase.AbstractTimeseriesSolutionRows","title":"AbstractTimeseriesSolutionRows","text":""},{"doctype":"document","id":"LinearSolve/basics/common_solver_opts.md","title":"Common Solver Options (Keyword Arguments for Solve)","text":"Common Solver Options Keyword Arguments for Solve While many algorithms have specific arguments within their constructor the keyword arguments for  solve  are common across all of the algorithms in order to give composability These are also the options taken at  init  time The following are the options these algorithms take along with their defaults General Controls alias_A  Whether to alias the matrix  A  or use a copy by default When true algorithms like LU-factorization can be faster by reusing the memory via  lu  but care must be taken as the original input will be modified Default is  false  alias_b  Whether to alias the matrix  b  or use a copy by default When true algorithms can write and change  b  upon usage Care must be taken as the original input will be modified Default is  false  verbose  Whether to print extra information Defaults to  false  Iterative Solver Controls Error controls are not used by all algorithms Specifically direct solves always solve completely Error controls only apply to iterative solvers abstol  The absolute tolerance Defaults to  √(eps(eltype(A reltol  The relative tolerance Defaults to  √(eps(eltype(A maxiters  The number of iterations allowed Defaults to  length(prob.b Pl,Pr  The left and right preconditioners respectively For more information see the Preconditioners page  prec"},{"doctype":"documentation","id":"references/SciMLBase.is_constant","title":"is_constant","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.FLOATING_POINT_LIMIT","title":"FLOATING_POINT_LIMIT","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSplitODEProblem","title":"AbstractSplitODEProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.warn_compat","title":"warn_compat","text":"DocStringExtensions.MethodSignatures Emit a warning with a link to the solver compatibility chart in the documentation"},{"doctype":"documentation","id":"references/SciMLBase.undefined_exports","title":"undefined_exports","text":"DocStringExtensions.MethodSignatures List symbols  export ed but not actually defined"},{"doctype":"documentation","id":"references/SciMLBase.addat_non_user_cache!","title":"addat_non_user_cache!","text":"addat s the non-user facing caches at indices  idxs  This includes resizing Jacobian caches Note In many cases  addat  simply  addat s  full_cache  variables and then calls this function This finer control is required for some  AbstractArray  operations"},{"doctype":"documentation","id":"references/LinearSolve.GenericFactorization","title":"GenericFactorization","text":""},{"doctype":"documentation","id":"references/SciMLBase.remake","title":"remake","text":"Re-construct  thing  with new field values specified by the keyword arguments"},{"doctype":"documentation","id":"references/SciMLBase.__has_jac","title":"__has_jac","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractConstantLagSDDEProblem","title":"AbstractConstantLagSDDEProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.DiscreteCallback","title":"DiscreteCallback","text":"condition affect! initialize finalize save_positions Arguments condition  This is a function  condition(u,t,integrator  for declaring when the callback should be used A callback is initiated if the condition evaluates to  true  See the Integrator Interface  integrator documentation for information about  integrator  affect  This is the function  affect!(integrator  where one is allowed to modify the current state of the integrator For more information on what can be done see the Integrator Interface  integrator manual page save_positions  Boolean tuple for whether to save before and after the  affect  This saving will occur just before and after the event only at event times and does not depend on options like  saveat   save_everystep  etc i.e if  saveat=[1.0,2.0,3.0  this can still add a save point at  2.1  if true For discontinuous changes like a modification to  u  to be handled correctly without error one should set  save_positions=(true,true  initialize  This is a function  c,u,t,integrator  which can be used to initialize the state of the callback  c  It should modify the argument  c  and the return is ignored finalize  This is a function  c,u,t,integrator  which can be used to finalize the state of the callback  c  It should can the argument  c  and the return is ignored"},{"doctype":"documentation","id":"references/SciMLBase.auto_dt_reset!","title":"auto_dt_reset!","text":"Run the auto  dt  initialization algorithm"},{"doctype":"documentation","id":"references/SciMLBase.StandardSDEProblem","title":"StandardSDEProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.has_ldiv!","title":"has_ldiv!","text":""},{"doctype":"documentation","id":"references/SciMLBase.solution_new_tslocation","title":"solution_new_tslocation","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractDAEProblem","title":"AbstractDAEProblem","text":"DocStringExtensions.TypeDefinition Base for types which define DAE problems"},{"doctype":"documentation","id":"references/SciMLBase.has_paramjac","title":"has_paramjac","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractJumpProblem","title":"AbstractJumpProblem","text":"DocStringExtensions.TypeDefinition Base for types which define jump problems"},{"doctype":"documentation","id":"references/SciMLBase.set_abstol!","title":"set_abstol!","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timepoint_weighted_meancov","title":"timepoint_weighted_meancov","text":""},{"doctype":"documentation","id":"references/SciMLBase.add_saveat!","title":"add_saveat!","text":"Adds a  saveat  time point at  t "},{"doctype":"documentation","id":"references/SciMLBase.du_cache","title":"du_cache","text":""},{"doctype":"document","id":"SciMLBase/interfaces/Algorithms.md","title":"SciMLAlgorithms","text":"CommonSolve solve prob alg kwargs SciMLAlgorithms Definition of the SciMLAlgorithm Interface SciMLAlgorithms  are defined as types which have dispatches to the function signature Algorithm-Specific Arguments Note that because the keyword arguments of  solve  are designed to be common across the whole problem type algorithms should have the algorithm-specific keyword arguments defined as part of the algorithm constructor For example  Rodas5  has a choice of  autodiff::Bool  which is not common across all ODE solvers and thus  autodiff  is a algorithm-specific keyword argument handled via  Rodas5(autodiff=true  Remake Note that  remake  is applicable to  SciMLAlgorithm  types but this is not used in the public API It's used for solvers to swap out components like ForwardDiff chunk sizes Common Algorithm Keyword Arguments Commonly used algorithm keyword arguments are Traits Abstract SciML Algorithms Concrete SciML Algorithms The concrete SciML algorithms are found in the respective solver documentations"},{"doctype":"documentation","id":"references/SciMLBase.__parameterless_type","title":"__parameterless_type","text":""},{"doctype":"documentation","id":"references/SciMLBase.has_tstop","title":"has_tstop","text":"Checks if integrator has any stopping times defined"},{"doctype":"documentation","id":"references/SciMLBase.interpolant","title":"interpolant","text":"Hairer Norsett Wanner Solving Ordinary Differential Equations I  Nonstiff Problems Page 190 Hermite Interpolation Hermite Interpolation Hermite Interpolation Hermite Interpolation Linear Interpolation Constant Interpolation"},{"doctype":"documentation","id":"references/SciMLBase.interpolation","title":"interpolation","text":"DocStringExtensions.MethodSignatures Get the value at tval where the solution is known at the times t sorted with values u and derivatives ks"},{"doctype":"documentation","id":"references/SciMLBase.LinearProblem","title":"LinearProblem","text":"A x p u0 nothing kwargs f u0 p u0 nothing kwargs Defines a linear system problem Documentation Page http://linearsolve.sciml.ai/dev/basics/LinearProblem Mathematical Specification of a Linear Problem Concrete LinearProblem To define a  LinearProblem  you simply need to give the  AbstractMatrix   A  and an  AbstractVector   b  which defines the linear system Au  b Matrix-Free LinearProblem For matrix-free versions the specification of the problem is given by an operator  A(u,p,t  which computes  A*u  or in-place as  A(du,u,p,t  These are specified via the  AbstractSciMLOperator  interface For more details see the  SciMLBase Documentation  Note that matrix-free versions of LinearProblem definitions are not compatible with all solvers To check a solver for compatibility use the function xxxxx Problem Type Constructors Optionally an initial guess  u₀  can be supplied which is used for iterative methods isinplace  optionally sets whether the function is in-place or not i.e whether the solvers are allowed to mutate By default this is true for  AbstractMatrix  and for  AbstractSciMLOperator s it matches the choice of the operator definition Parameters are optional and if not given then a  NullParameters  singleton will be used which will throw nice errors if you try to index non-existent parameters Any extra keyword arguments are passed on to the solvers Fields A  The representation of the linear operator b  The right-hand side of the linear system p  The parameters for the problem Defaults to  NullParameters  Currently unused u0  The initial condition used by iterative solvers kwargs  The keyword arguments passed on to the solvers"},{"doctype":"documentation","id":"references/SciMLBase.get_du!","title":"get_du!","text":"Write the current derivative at  t  into  out "},{"doctype":"documentation","id":"references/SciMLBase.DiffEqArrayOperator","title":"DiffEqArrayOperator","text":"Represents a time-dependent linear operator given by an AbstractMatrix The update function is called by  update_coefficients  and is assumed to have the following signature"},{"doctype":"documentation","id":"references/SciMLBase.interpolation!","title":"interpolation!","text":"DocStringExtensions.MethodSignatures Get the value at tvals where the solution is known at the times t sorted with values u and derivatives ks DocStringExtensions.MethodSignatures Get the value at tval where the solution is known at the times t sorted with values u and derivatives ks"},{"doctype":"documentation","id":"references/SciMLBase.AbstractContinuousCallback","title":"AbstractContinuousCallback","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.AbstractNoiseProblem","title":"AbstractNoiseProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.tmap","title":"tmap","text":""},{"doctype":"documentation","id":"references/SciMLBase.terminate!","title":"terminate!","text":"Terminates the integrator by emptying  tstops  This can be used in events and callbacks to immediately end the solution process  Optionally  retcode  may be specified see Return Codes RetCodes  retcodes"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timeseries_point_meancor","title":"timeseries_point_meancor","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis","title":"EnsembleAnalysis","text":""},{"doctype":"documentation","id":"references/SciMLBase.allows_arbitrary_number_types","title":"allows_arbitrary_number_types","text":"allows_arbitrary_number_types(alg::DEAlgorithm Trait declaration for whether an algorithm is compatible with direct automatic differentiation i.e can have algorithms like ForwardDiff or ReverseDiff attempt to differentiate directly through the solver Defaults to false as only pure-Julia algorithms can have this be true"},{"doctype":"documentation","id":"references/SciMLBase.cleansym","title":"cleansym","text":""},{"doctype":"documentation","id":"references/SciMLBase.add_tstop!","title":"add_tstop!","text":"Adds a  tstop  at time  t "},{"doctype":"document","id":"SciMLBase/fundamentals/FAQ.md","title":"Frequently Asked Questions","text":"Frequently Asked Questions What are the code styling rules for SciML All SciML libraries are supposed to follow  SciMLStyle  Any deviation from that style is something to be fixed Where do I find more information on the internals of some packages The  SciML Developer Documentation  describes the internals of some of the larger solver libraries at length What are the community practices that SciML developers should use See  ColPrac Contributor's Guide on Collaborative Practices for Community Packages Are there developer programs to help fund parties interested in helping develop SciML Yes See  the SciML Developer Programs  webpage"},{"doctype":"documentation","id":"references/NonlinearSolve.DESolution","title":"DESolution","text":""},{"doctype":"documentation","id":"references/SciMLBase.__has_analytic","title":"__has_analytic","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractLinearProblem","title":"AbstractLinearProblem","text":"DocStringExtensions.TypeDefinition Base for types which define linear systems"},{"doctype":"documentation","id":"references/SciMLBase.SDDEFunction","title":"SDDEFunction","text":"iip recompile f g mass_matrix I analytic nothing tgrad nothing jac nothing jvp nothing vjp nothing jac_prototype nothing sparsity jac_prototype paramjac nothing syms nothing indepsym nothing colorvec nothing SDDEFunction  AbstractSDDEFunction A representation of a SDDE function  f  defined by M du  f(u,h,p,t dt  g(u,h,p,t dW_t and all of its related functions such as the Jacobian of  f  its gradient with respect to time and more For all cases  u0  is the initial condition  p  are the parameters and  t  is the independent variable Constructor Note that only the function  f  itself is required This function should be given as  f!(du,u,h,p,t  or  du  f(u,h,p,t  See the section on  iip  for more details on in-place vs out-of-place handling The histroy function  h  acts as an interpolator over time i.e  h(t  with options matching the solution interface i.e  h(t save_idxs  2  All of the remaining functions are optional for improving or accelerating  the usage of  f  These include mass_matrix  the mass matrix  M  represented in the ODE function Can be used to determine that the equation is actually a differential-algebraic equation DAE if  M  is singular Note that in this case special solvers are required see the DAE solver page for more details https://diffeq.sciml.ai/stable/solvers/dae_solve Must be an AbstractArray or an AbstractSciMLOperator analytic(u0,p,t  used to pass an analytical solution function for the analytical  solution of the ODE Generally only used for testing and development of the solvers tgrad(dT,u,h,p,t  or dT=tgrad(u,p,t returns  frac{\\partial f(u,p,t)}{\\partial t jac(J,u,h,p,t  or  J=jac(u,p,t  returns  frac{df}{du jvp(Jv,v,h,u,p,t  or  Jv=jvp(v,u,p,t  returns the directional derivative frac{df}{du v vjp(Jv,v,h,u,p,t  or  Jv=vjp(v,u,p,t  returns the adjoint derivative frac{df}{du}^\\ast v jac_prototype  a prototype matrix matching the type that matches the Jacobian For example if the Jacobian is tridiagonal then an appropriately sized  Tridiagonal  matrix can be used as the prototype and integrators will specialize on this structure where possible Non-structured sparsity patterns should use a  SparseMatrixCSC  with a correct sparsity pattern for the Jacobian The default is  nothing  which means a dense Jacobian paramjac(pJ,h,u,p,t  returns the parameter Jacobian  frac{df}{dp  syms  the symbol names for the elements of the equation This should match  u0  in size For example if  u0  0.0,1.0  and  syms  x y  this will apply a canonical naming to the values allowing  sol[:x  in the solution and automatically naming values in plots indepsym  the canonical naming for the independent variable Defaults to nothing which internally uses  t  as the representation in any plots colorvec  a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the  jac_prototype  This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern Defaults to  nothing  which means a color vector will be internally computed on demand when required The cost of this operation is highly dependent on the sparsity pattern iip In-Place vs Out-Of-Place For more details on this argument see the ODEFunction documentation recompile Controlling Compilation and Specialization For more details on this argument see the ODEFunction documentation Fields The fields of the DDEFunction type directly match the names of the inputs"},{"doctype":"documentation","id":"references/LinearSolve.set_u","title":"set_u","text":"DocStringExtensions.MethodSignatures"},{"doctype":"documentation","id":"references/SciMLBase.last_step_failed","title":"last_step_failed","text":""},{"doctype":"document","id":"NonlinearSolve/tutorials/nonlinear.md","title":"Solving Nonlinear Systems","text":"StaticArrays f u p u u p u0 p probN f u0 p solver solve probN tol f u p u u u0 probB f u0 sol solve probB Solving Nonlinear Systems A nonlinear system f(u  0 is specified by defining a function  f(u,p  where  p  are the parameters of the system For example the following solves the vector equation f(u  u^2  p for a vector of equations where  u0  is the initial condition for the rootfind Native NonlinearSolve.jl solvers use the given type of  u0  to determine the type used within the solver and the return Note that the parameters  p  can be any type but most are an AbstractArray for automatic differentiation Using Bracketing Methods For scalar rootfinding problems bracketing methods exist In this case one passes a bracket instead of an initial condition for example"},{"doctype":"documentation","id":"references/SciMLBase.DESensitivity","title":"DESensitivity","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.NonlinearFunction","title":"NonlinearFunction","text":"iip recompile f analytic nothing jac nothing jvp nothing vjp nothing jac_prototype nothing sparsity jac_prototype paramjac nothing syms nothing indepsym nothing colorvec nothing NonlinearFunction  AbstractNonlinearFunction A representation of an nonlinear system of equations  f  defined by 0  f(u,p and all of its related functions such as the Jacobian of  f  its gradient with respect to time and more For all cases  u0  is the initial condition  p  are the parameters and  t  is the independent variable Constructor Note that only the function  f  itself is required This function should be given as  f!(du,u,p  or  du  f(u,p  See the section on  iip  for more details on in-place vs out-of-place handling All of the remaining functions are optional for improving or accelerating  the usage of  f  These include analytic(u0,p  used to pass an analytical solution function for the analytical  solution of the ODE Generally only used for testing and development of the solvers jac(J,u,p  or  J=jac(u,p  returns  frac{df}{du jvp(Jv,v,u,p  or  Jv=jvp(v,u,p  returns the directional derivative frac{df}{du v vjp(Jv,v,u,p  or  Jv=vjp(v,u,p  returns the adjoint derivative frac{df}{du}^\\ast v jac_prototype  a prototype matrix matching the type that matches the Jacobian For example if the Jacobian is tridiagonal then an appropriately sized  Tridiagonal  matrix can be used as the prototype and integrators will specialize on this structure where possible Non-structured sparsity patterns should use a  SparseMatrixCSC  with a correct sparsity pattern for the Jacobian The default is  nothing  which means a dense Jacobian paramjac(pJ,u,p  returns the parameter Jacobian  frac{df}{dp  syms  the symbol names for the elements of the equation This should match  u0  in size For example if  u0  0.0,1.0  and  syms  x y  this will apply a canonical naming to the values allowing  sol[:x  in the solution and automatically naming values in plots indepsym  the canonical naming for the independent variable Defaults to nothing which internally uses  t  as the representation in any plots colorvec  a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the  jac_prototype  This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern Defaults to  nothing  which means a color vector will be internally computed on demand when required The cost of this operation is highly dependent on the sparsity pattern iip In-Place vs Out-Of-Place For more details on this argument see the ODEFunction documentation recompile Controlling Compilation and Specialization For more details on this argument see the ODEFunction documentation Fields The fields of the NonlinearFunction type directly match the names of the inputs"},{"doctype":"documentation","id":"references/SciMLBase.u_n","title":"u_n","text":""},{"doctype":"documentation","id":"references/SciMLBase.has_jvp","title":"has_jvp","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.num_types_in_tuple","title":"num_types_in_tuple","text":""},{"doctype":"document","id":"NonlinearSolve/basics/FAQ.md","title":"Frequently Asked Questions","text":"Frequently Asked Questions Ask more questions"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleSerial","title":"EnsembleSerial","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.allowscomplex","title":"allowscomplex","text":"allowscomplex(alg::DEAlgorithm Trait declaration for whether an algorithm is compatible with having complex numbers as the state variables Defaults to false"},{"doctype":"documentation","id":"references/LinearSolve.ComposePreconditioner","title":"ComposePreconditioner","text":""},{"doctype":"documentation","id":"references/SciMLBase.DAEFunction","title":"DAEFunction","text":"iip recompile f analytic nothing jac nothing jvp nothing vjp nothing jac_prototype nothing sparsity jac_prototype syms nothing indepsym nothing colorvec nothing f J du u p gamma t testjac res du u p t res du u u u res du u u u testjac J du u p gamma t J gamma u J u J u J gamma u nothing DAEFunction  AbstractDAEFunction A representation of an implicit DAE function  f  defined by 0  f(\\frac{du}{dt},u,p,t and all of its related functions such as the Jacobian of  f  its gradient with respect to time and more For all cases  u0  is the initial condition  p  are the parameters and  t  is the independent variable Constructor Note that only the function  f  itself is required This function should be given as  f!(out,du,u,p,t  or  out  f(du,u,p,t  See the section on  iip  for more details on in-place vs out-of-place handling All of the remaining functions are optional for improving or accelerating  the usage of  f  These include analytic(u0,p,t  used to pass an analytical solution function for the analytical  solution of the ODE Generally only used for testing and development of the solvers jac(J,du,u,p,gamma,t  or  J=jac(du,u,p,gamma,t  returns the implicit DAE Jacobian defined as  gamma frac{dG}{d(du  frac{dG}{du jvp(Jv,v,du,u,p,gamma,t  or  Jv=jvp(v,du,u,p,gamma,t  returns the directional  derivative frac{df}{du v vjp(Jv,v,du,u,p,gamma,t  or  Jv=vjp(v,du,u,p,gamma,t  returns the adjoint  derivative frac{df}{du}^\\ast v jac_prototype  a prototype matrix matching the type that matches the Jacobian For example if the Jacobian is tridiagonal then an appropriately sized  Tridiagonal  matrix can be used as the prototype and integrators will specialize on this structure where possible Non-structured sparsity patterns should use a  SparseMatrixCSC  with a correct sparsity pattern for the Jacobian The default is  nothing  which means a dense Jacobian syms  the symbol names for the elements of the equation This should match  u0  in size For example if  u0  0.0,1.0  and  syms  x y  this will apply a canonical naming to the values allowing  sol[:x  in the solution and automatically naming values in plots indepsym  the canonical naming for the independent variable Defaults to nothing which internally uses  t  as the representation in any plots colorvec  a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the  jac_prototype  This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern Defaults to  nothing  which means a color vector will be internally computed on demand when required The cost of this operation is highly dependent on the sparsity pattern iip In-Place vs Out-Of-Place For more details on this argument see the ODEFunction documentation recompile Controlling Compilation and Specialization For more details on this argument see the ODEFunction documentation Fields The fields of the DAEFunction type directly match the names of the inputs Examples Declaring Explicit Jacobians for DAEs For fully implicit ODEs  DAEProblem s a slightly different Jacobian function is necessary For the DAE G(du,u,p,t  res The Jacobian should be given in the form  gamma*dG/d(du  dG/du  where  gamma  is given by the solver This means that the signature is For example for the equation we would define the Jacobian as Symbolically Generating the Functions See the  modelingtoolkitize  function from  ModelingToolkit.jl  for automatically symbolically generating the Jacobian and more from the  numerically-defined functions"},{"doctype":"documentation","id":"references/SciMLBase.__has_vjp","title":"__has_vjp","text":""},{"doctype":"documentation","id":"references/SciMLBase.TYPE_COLOR","title":"TYPE_COLOR","text":""},{"doctype":"documentation","id":"references/SciMLBase.solplot_vecs_and_labels","title":"solplot_vecs_and_labels","text":""},{"doctype":"documentation","id":"references/SciMLBase.DiscreteFunction","title":"DiscreteFunction","text":"iip recompile f analytic nothing syms nothing DiscreteFunction  AbstractDiscreteFunction A representation of an discrete dynamical system  f  defined by u_{n+1  f(u,p,t_{n+1 and all of its related functions such as the Jacobian of  f  its gradient with respect to time and more For all cases  u0  is the initial condition  p  are the parameters and  t  is the independent variable Constructor Note that only the function  f  itself is required This function should be given as  f!(du,u,p,t  or  du  f(u,p,t  See the section on  iip  for more details on in-place vs out-of-place handling All of the remaining functions are optional for improving or accelerating  the usage of  f  These include analytic(u0,p,t  used to pass an analytical solution function for the analytical  solution of the ODE Generally only used for testing and development of the solvers syms  the symbol names for the elements of the equation This should match  u0  in size For example if  u0  0.0,1.0  and  syms  x y  this will apply a canonical naming to the values allowing  sol[:x  in the solution and automatically naming values in plots iip In-Place vs Out-Of-Place For more details on this argument see the ODEFunction documentation recompile Controlling Compilation and Specialization For more details on this argument see the ODEFunction documentation Fields The fields of the DiscreteFunction type directly match the names of the inputs"},{"doctype":"documentation","id":"references/SciMLBase.AbstractDDEFunction","title":"AbstractDDEFunction","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.TimeGradientWrapper","title":"TimeGradientWrapper","text":""},{"doctype":"documentation","id":"references/SciMLBase.update_coefficients!","title":"update_coefficients!","text":""},{"doctype":"documentation","id":"references/SciMLBase.split_callbacks","title":"split_callbacks","text":"Split comma seperated callbacks into sets of continous and discrete callbacks"},{"doctype":"documentation","id":"references/SciMLBase.AbstractDDEProblem","title":"AbstractDDEProblem","text":"DocStringExtensions.TypeDefinition Base for types which define DDE problems"},{"doctype":"documentation","id":"references/SciMLBase.ODESolution","title":"ODESolution","text":"DocStringExtensions.TypeDefinition Representation of the solution to an ordinary differential equation defined by an ODEProblem DESolution Interface For more information on interacting with  DESolution  types check out the Solution Handling page of the DifferentialEquations.jl documentation https://diffeq.sciml.ai/stable/basics/solution Fields u  the representation of the ODE solution Given as an array of solutions where  u[i  corresponds to the solution at time  t[i  It is recommended in most cases one does not access  sol.u  directly and instead use the array interface described in the Solution Handling page of the DifferentialEquations.jl documentation t  the time points corresponding to the saved values of the ODE solution prob  the original ODEProblem that was solved alg  the algorithm type used by the solver destats  statistics of the solver such as the number of function evaluations required number of Jacobians computed and more retcode  the return code from the solver Used to determine whether the solver solved successfully  sol.retcode  Success  whether it terminated due to a user-defined callback  sol.retcode  Terminated  or whether it exited due to an error For more details see the return code section of the DifferentialEquations.jl documentation"},{"doctype":"documentation","id":"references/SciMLBase.AbstractIntegralAlgorithm","title":"AbstractIntegralAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.deleteat_non_user_cache!","title":"deleteat_non_user_cache!","text":"deleteat s the non-user facing caches at indices  idxs  This includes resizing Jacobian caches Note In many cases  deleteat  simply  deleteat s  full_cache  variables and then calls this function This finer control is required for some  AbstractArray  operations"},{"doctype":"documentation","id":"references/SciMLBase.AbstractIncrementingODEProblem","title":"AbstractIncrementingODEProblem","text":""},{"doctype":"documentation","id":"references/SciMLBase.NO_COLOR","title":"NO_COLOR","text":""},{"doctype":"documentation","id":"references/SciMLBase.tighten_container_eltype","title":"tighten_container_eltype","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractDynamicalDDEProblem","title":"AbstractDynamicalDDEProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.StandardDDEProblem","title":"StandardDDEProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.TwoPointBVProblem","title":"TwoPointBVProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.SDDEProblem","title":"SDDEProblem","text":"Defines a stochastic delay differential equation SDDE problem Documentation Page https://diffeq.sciml.ai/stable/types/sdde_types Mathematical Specification of a Stochastic Delay Differential Equation SDDE Problem To define a SDDE Problem you simply need to give the drift function  f  the diffusion function  g  the initial condition  u_0  at time point  t_0  and the history function  h  which together define a SDDE du  f(u,h,p,t)dt  g(u,h,p,t)dW_t qquad t geq t_0 u(t_0  u_0 u(t  h(t qquad t  t_0 f  should be specified as  f(u h p t  or in-place as  f(du u h p t  and  g  should match  u_0  should be an AbstractArray or number whose geometry matches the desired geometry of  u  and  h  should be specified as described below The history function  h  is accessed for all delayed values Note that we are not limited to numbers or vectors for  u_0  one is allowed to provide  u_0  as arbitrary matrices  higher dimension tensors as well Note that this functionality should be considered experimental Functional Forms of the History Function The history function  h  can be called in the following ways h(p t  out-of-place calculation h(out p t  in-place calculation h(p t deriv::Type{Val{i  out-of-place calculation of the  i th derivative h(out p t deriv::Type{Val{i  in-place calculation of the  i th derivative h(args idxs  calculation of  h(args  for indices  idxs Note that a dispatch for the supplied history function of matching form is required for whichever function forms are used in the user derivative function  f  Declaring Lags Lags are declared separately from their use One can use any lag by simply using the interpolant of  h  at that point However one should use caution in order to achieve the best accuracy When lags are declared the solvers can more efficiently be more accurate and thus this is recommended Neutral Retarded and Algebraic Stochastic Delay Differential Equations Note that the history function specification can be used to specify general retarded arguments i.e  h(p,α(u,t  Neutral delay differential equations can be specified by using the  deriv  value in the history interpolation For example  h(p,t-τ Val{1  returns the first derivative of the history values at time  t-τ  Note that algebraic equations can be specified by using a singular mass matrix Problem Type Constructors Parameter  isinplace  optionally sets whether the function is inplace or not This is determined automatically but not inferred Parameters are optional and if not given then a  NullParameters  singleton will be used which will throw nice errors if you try to index non-existent parameters Any extra keyword arguments are passed on to the solvers For example if you set a  callback  in the problem then that  callback  will be added in every solve call For specifying Jacobians and mass matrices see the DiffEqFunctions  performance_overloads page Arguments f  The drift function in the SDDE g  The diffusion function in the SDDE u0  The initial condition Defaults to the value  h(p first(tspan  of the history function evaluated at the initial time point h  The history function for the DDE before  t0  tspan  The timespan for the problem p  The parameters with which function  f  is called Defaults to  NullParameters  constant_lags  A collection of constant lags used by the history function  h  Defaults to    dependent_lags  A tuple of functions  u p t  lag  for the state-dependent lags used by the history function  h  Defaults to    neutral  If the DDE is neutral i.e if delays appear in derivative terms order_discontinuity_t0  The order of the discontinuity at the initial time point Defaults to  0  if an initial condition  u0  is provided Otherwise it is forced to be greater or equal than  1  kwargs  The keyword arguments passed onto the solves"},{"doctype":"documentation","id":"references/NonlinearSolve.DefaultLinSolve","title":"DefaultLinSolve","text":""},{"doctype":"documentation","id":"references/SciMLBase.getindepsym","title":"getindepsym","text":""},{"doctype":"document","id":"SciMLBase/interfaces/Init_Solve.md","title":"The SciML init and solve Functions","text":"solve args kwargs solve! init args kwargs init ProblemType args kwargs IteratorType solve! SolverType SolutionType init AbstractVector AlgorithmType The SciML init and solve Functions solve  function has the default definition The interface for the three functions is as follows where  ProblemType   IteratorType  and  SolutionType  are the types defined in your package To avoid method ambiguity the first argument of  solve   solve  and  init   must  be dispatched on the type defined in your package  For example do  not  define a method such as init  and the Iterator Interface init s return gives an  IteratorType  which is designed to allow the user to have more direct handling over the internal solving process Because of this internal nature the  IteratorType  has a less unified interface across problem types than other portions like  ProblemType  and  SolutionType  For example for differential equations this is the  Integrator Interface  designed for mutating solutions in a manner for callback implementation which is distinctly different from the  LinearSolve init interface  which is designed for caching efficiency with reusing factorizations solve and High-Level Handling While  init  and  solve  are the common entry point for users solver packages will mostly define dispatches on  SciMLBase.__init  and  SciMLBase.__solve  The reason is because this allows for  SciMLBase.init  and  SciMLBase.solve  to have common implementations across all solvers for doing things such as checking for common errors and throwing high level messages Solvers can opt-out of the high level error handling by directly defining  SciMLBase.init  and  SciMLBase.solve  instead though this is not recommended in order to allow for uniformity of the error messages"},{"doctype":"documentation","id":"references/SciMLBase.set_u!","title":"set_u!","text":"Set current state of the  integrator  to  u "},{"doctype":"documentation","id":"references/SciMLBase.AbstractODEAlgorithm","title":"AbstractODEAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timeseries_steps_median","title":"timeseries_steps_median","text":""},{"doctype":"document","id":"LinearSolve/index.md","title":"LinearSolve.jl: High-Performance Unified Linear Solvers","text":"Pkg Pkg add LinearSolve.jl High-Performance Unified Linear Solvers LinearSolve.jl is a unified interface for the linear solving packages of Julia It interfaces with other packages of the Julia ecosystem to make it easy to test alternative solver packages and pass small types to control algorithm swapping It also interfaces with the  ModelingToolkit.jl  world of symbolic modeling to allow for automatically generating high-performance code Performance is key the current methods are made to be highly performant on scalar and statically sized small problems with options for large-scale systems If you run into any performance issues please file an issue Installation To install LinearSolve.jl use the Julia package manager Contributing Please refer to the  SciML ColPrac Contributor's Guide on Collaborative Practices for Community Packages  for guidance on PRs issues and other matters relating to contributing to ModelingToolkit There are a few community forums the diffeq-bridged channel in the  Julia Slack JuliaDiffEq  on Gitter on the  Julia Discourse forums see also  SciML Community page Roadmap Wrappers for every linear solver in the Julia language is on the roadmap If there are any important ones that are missing that you would like to see added please open an issue The current algorithms should support automatic differentiation Pre-defined preconditioners would be a welcome addition"},{"doctype":"documentation","id":"references/LinearSolve.purge_history!","title":"purge_history!","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timeseries_steps_meanvar","title":"timeseries_steps_meanvar","text":""},{"doctype":"document","id":"LinearSolve/basics/LinearProblem.md","title":"Linear Problems","text":"Linear Problems"},{"doctype":"documentation","id":"references/SciMLBase.AbstractRODESolution","title":"AbstractRODESolution","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/NonlinearSolve.UNITLESS_ABS2","title":"UNITLESS_ABS2","text":""},{"doctype":"documentation","id":"references/SciMLBase.resize_non_user_cache!","title":"resize_non_user_cache!","text":"Resizes the non-user facing caches to be compatible with a DE of size  k  This includes resizing Jacobian caches Note In many cases  resize  simply resizes  full_cache  variables and then calls this function This finer control is required for some  AbstractArray  operations"},{"doctype":"documentation","id":"references/SciMLBase.has_adjoint","title":"has_adjoint","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSteadyStateAlgorithm","title":"AbstractSteadyStateAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.OptimizationProblem","title":"OptimizationProblem","text":"iip f x p lb nothing ub nothing lcons nothing ucons nothing sense nothing kwargs Defines a optimization problem Documentation Page https://galacticoptim.sciml.ai/dev/API/optimization_problem Mathematical Specification of a Optimization Problem To define an Optimization Problem you simply need to give the function  f  which defines the cost function to minimize min_u f(u,p  0 u₀  is an initial guess of the minimum  f  should be specified as  f(u,p  and  u₀  should be an AbstractArray or number whose geometry matches the  desired geometry of  u  Note that we are not limited to numbers or vectors  for  u₀  one is allowed to provide  u₀  as arbitrary matrices   higher-dimension tensors as well Problem Type Constructors isinplace  optionally sets whether the function is in-place or not This is determined automatically but not inferred Note that for OptimizationProblem in-place only refers to the Jacobian and Hessian functions and thus by default if the  OptimizationFunction  is not defined directly then  iip  true  is done by default Parameters are optional and if not given then a  NullParameters  singleton will be used which will throw nice errors if you try to index non-existent parameters Any extra keyword arguments are passed on to the solvers For example if you set a  callback  in the problem then that  callback  will be added in every solve call lb  and  ub  are the upper and lower bounds for box constraints on the optimization They should be an  AbstractArray  matching the geometry of  u  where  lb[I],ub[I  is the box constraint lower and upper bounds for  u[I  lcons  and  ucons  are the upper and lower bounds for equality constraints on the optimization They should be an  AbstractArray  matching the geometry of  u  where  lcons[I],ucons[I  is the constraint lower and upper bounds for  cons[I  If  f  is a standard Julia function it is automatically converted into an  OptimizationFunction  with  NoAD  i.e no automatic generation of the derivative functions Any extra keyword arguments are captured to be sent to the optimizers Fields f  The function in the problem u0  The initial guess for the optima p  The parameters for the problem Defaults to  NullParameters  lb  the lower bounds for the optimization of  u  ub  the upper bounds for the optimization of  u  lcons  ucons  sense  kwargs  The keyword arguments passed on to the solvers"},{"doctype":"documentation","id":"references/SciMLBase.DAEProblem","title":"DAEProblem","text":"DiffEqProblemLibrary DAEProblemLibrary DAEProblemLibrary importdaeproblems prob DAEProblemLibrary prob_dae_resrob sol solve prob IDA Defines an implicit ordinary differential equation ODE or  differential-algebraic equation DAE problem Documentation Page https://diffeq.sciml.ai/stable/types/dae_types Mathematical Specification of an DAE Problem To define a DAE Problem you simply need to give the function  f  and the initial condition  u_0  which define an ODE 0  f(du,u,p,t f  should be specified as  f(du,u,p,t  or in-place as  f(resid,du,u,p,t  Note that we are not limited to numbers or vectors for  u₀  one is allowed to provide  u₀  as arbitrary matrices  higher dimension tensors as well Problem Type Constructors DAEProblem(f::DAEFunction,du0,u0,tspan,p=NullParameters();kwargs DAEProblem{isinplace}(f,du0,u0,tspan,p=NullParameters();kwargs   Defines the DAE with the specified functions  isinplace  optionally sets whether the function is inplace or not This is determined automatically but not inferred Parameters are optional and if not given then a  NullParameters  singleton will be used which will throw nice errors if you try to index non-existent parameters Any extra keyword arguments are passed on to the solvers For example if you set a  callback  in the problem then that  callback  will be added in every solve call For specifying Jacobians and mass matrices see the DiffEqFunctions  performance_overloads page Fields f  The function in the ODE du0  The initial condition for the derivative u0  The initial condition tspan  The timespan for the problem differential_vars  A logical array which declares which variables are the differential non algebraic vars i.e  du  is in the equations for this variable Defaults to nothing Some solvers may require this be set if an initial condition needs to be determined p  The parameters for the problem Defaults to  NullParameters kwargs  The keyword arguments passed onto the solves Example Problems Examples problems can be found in  DiffEqProblemLibrary.jl  To use a sample problem such as  prob_dae_resrob  you can do something like"},{"doctype":"documentation","id":"references/SciMLBase.__solve","title":"__solve","text":""},{"doctype":"documentation","id":"references/LinearSolve.SciMLLinearSolveAlgorithm","title":"SciMLLinearSolveAlgorithm","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.sync_residuals!","title":"sync_residuals!","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractNonlinearSolution","title":"AbstractNonlinearSolution","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timepoint_quantile","title":"timepoint_quantile","text":""},{"doctype":"documentation","id":"references/SciMLBase.QuadratureProblem","title":"QuadratureProblem","text":""},{"doctype":"documentation","id":"references/SciMLBase.IntegratorTuples","title":"IntegratorTuples","text":""},{"doctype":"document","id":"SciMLBase/interfaces/Problems.md","title":"SciMLProblems","text":"f u0 tspan p iip f u0 tspan p SciMLProblems The cornerstone of the SciML common interface is the problem type definition These definitions are the encoding of mathematical problems into a numerically computable form Note About Symbolics and ModelingToolkit The symbolic analog to the problem interface is the ModelingToolkit  AbstractSystem  For example  ODESystem  is the symbolic analog to  ODEProblem  Each of these system types have a method for constructing the associated problem and function types Definition of the SciMLProblem Interface The following standard principles should be adhered to across all  SciMLProblem  instantiations In-place Specification Each  SciMLProblem  type can be called with an is inplace iip choice For example which is a boolean for whether the function is in the inplace form mutating to change the first value This is automatically determined using the methods table but note that for full type-inferrability of the  SciMLProblem  this iip-ness should be specified Additionally the functions are fully specialized to reduce the runtimes If one would instead like to not specialize on the functions to reduce compile time then one can set  recompile  to false Default Parameters By default  SciMLProblem  types use the  SciMLBase.NullParameters  singleton to define the absence of parameters by default The reason is because this throws an informative error if the parameter is used or accessed within the user's function for example  p[1  will throw an informative error about forgetting to pass parameters Keyword Argument Splatting All  SciMLProblem  types allow for passing keyword arguments that would get forwarded to the solver The reason for this is that in many cases like in  EnsembleProblem  usage a  SciMLProblem  might be associated with some solver configuration such as a callback or tolerance Thus for flexibility the extra keyword arguments to the  SciMLProblem  are carried to the solver problem_type SciMLProblem  types include a non-public API definition of  problem_type  which holds a trait type corresponding to the way the  SciMLProblem  was constructed For example if a  SecondOrderODEProblem  constructor is used the returned problem is simply a  ODEProblem  for interopability with any  ODEProblem  algorithm However in this case the  problem_type  will be populated with the  SecondOrderODEProblem  type indicating the original definition and extra structure Remake Problem Traits SciMLProblem API Abstract SciMLProblems Concrete SciMLProblems"},{"doctype":"documentation","id":"references/SciMLBase.__init","title":"__init","text":""},{"doctype":"documentation","id":"references/SciMLBase.pop_tstop!","title":"pop_tstop!","text":"Pops the last stopping time from the integrator"},{"doctype":"documentation","id":"references/SciMLBase.symbolic_discretize","title":"symbolic_discretize","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.ImmutableJacobianWrapper","title":"ImmutableJacobianWrapper","text":""},{"doctype":"documentation","id":"references/SciMLBase.AffineDiffEqOperator","title":"AffineDiffEqOperator","text":"AffineDiffEqOperator  AbstractDiffEqOperator Ex A₁(t    Aₙ(t))*u  B₁(t    Bₘ(t AffineDiffEqOperator(As,Bs,du_cache=nothing Takes in two tuples for split Affine DiffEqs update_coefficients works by updating the coefficients of the component operators Function calls L(u p t and L(du u p t are fallbacks interpretted in this form This will allow them to work directly in the nonlinear ODE solvers without modification f(du u p t is only allowed if a du_cache is given B(t can be Union in which case they are constants Otherwise they are interpreted they are functions v=B(t and B(v,t Solvers will see this operator from integrator.f and can interpret it by checking the internals of As and Bs For example it can check isconstant(As[1 etc"},{"doctype":"documentation","id":"references/SciMLBase.DEFAULT_OUTPUT_FUNC","title":"DEFAULT_OUTPUT_FUNC","text":""},{"doctype":"documentation","id":"references/SciMLBase.CallbackSet","title":"CallbackSet","text":"DocStringExtensions.TypeDefinition Multiple callbacks can be chained together to form a  CallbackSet  A  CallbackSet  is constructed by passing the constructor  ContinuousCallback   DiscreteCallback   VectorContinuousCallback  or other  CallbackSet  instances You can pass as many callbacks as you like When the solvers encounter multiple callbacks the following rules apply ContinuousCallback s and  VectorContinuousCallback s are applied before  DiscreteCallback s This is because they often implement event-finding that will backtrack the timestep to smaller than  dt  For  ContinuousCallback s and  VectorContinuousCallback s the event times are found by rootfinding and only the first  ContinuousCallback  or  VectorContinuousCallback  affect is applied The  DiscreteCallback s are then applied in order Note that the ordering only matters for the conditions if a previous callback modifies  u  in such a way that the next callback no longer evaluates condition to  true  its  affect  will not be applied"},{"doctype":"documentation","id":"references/LinearSolve.GenericLUFactorization","title":"GenericLUFactorization","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSciMLFunction","title":"AbstractSciMLFunction","text":"DocStringExtensions.TypeDefinition Base for types defining SciML functions"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timestep_weighted_meancov","title":"timestep_weighted_meancov","text":""},{"doctype":"documentation","id":"references/SciMLBase.DISCRETE_OUTOFPLACE_DEFAULT","title":"DISCRETE_OUTOFPLACE_DEFAULT","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.calc_J!","title":"calc_J!","text":""},{"doctype":"documentation","id":"references/SciMLBase.reeval_internals_due_to_modification!","title":"reeval_internals_due_to_modification!","text":"Recalculate interpolation data and update ODE integrator after changes by callbacks"},{"doctype":"documentation","id":"references/SciMLBase.getobserved","title":"getobserved","text":""},{"doctype":"documentation","id":"references/SciMLBase.SensitivityInterpolation","title":"SensitivityInterpolation","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/LinearSolve.AbstractFactorization","title":"AbstractFactorization","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSDDEIntegrator","title":"AbstractSDDEIntegrator","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.DynamicalSDEProblem","title":"DynamicalSDEProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.unwrap_cache","title":"unwrap_cache","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleProblem","title":"EnsembleProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/LinearSolve.init_cacheval","title":"init_cacheval","text":""},{"doctype":"documentation","id":"references/SciMLBase.NonlinearSolution","title":"NonlinearSolution","text":"DocStringExtensions.TypeDefinition Representation of the solution to an nonlinear equation defined by an NonlinearProblem or the steady state solution to a differential equation defined by a SteadyStateProblem Fields u  the representation of the nonlinear equation's solution resid  the residual of the solution prob  the original NonlinearProblem/SteadyStateProblem that was solved alg  the algorithm type used by the solver original  if the solver is wrapped from an alternative solver ecosystem such as NLsolve.jl then this is the original return from said solver library retcode  the return code from the solver Used to determine whether the solver solved successfully  sol.retcode  Success  whether it terminated due to a user-defined callback  sol.retcode  Terminated  or whether it exited due to an error For more details see the return code section of the DifferentialEquations.jl documentation left  if the solver is bracketing method this is the final left bracket value right  if the solver is bracketing method this is the final right bracket value"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timestep_meancor","title":"timestep_meancor","text":""},{"doctype":"documentation","id":"references/SciMLBase.remaker_of","title":"remaker_of","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.DEFAULT","title":"DEFAULT","text":""},{"doctype":"documentation","id":"references/LinearSolve.KLUFactorization","title":"KLUFactorization","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timeseries_point_meanvar","title":"timeseries_point_meanvar","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timeseries_steps_meancor","title":"timeseries_steps_meancor","text":""},{"doctype":"documentation","id":"references/SciMLBase.VectorContinuousCallback","title":"VectorContinuousCallback","text":"condition affect! affect_neg! len initialize finalize idxs nothing rootfind save_positions interp_points abstol eps reltol repeat_nudge condition affect! len initialize finalize idxs nothing rootfind save_positions affect_neg! affect! interp_points abstol eps reltol repeat_nudge This is also a subtype of  AbstractContinuousCallback   CallbackSet  is not feasible when you have a large number of callbacks as it doesn't scale well For this reason we have  VectorContinuousCallback   it allows you to have a single callback for multiple events Arguments condition  This is a function  condition(out u t integrator  which should save the condition value in the array  out  at the right index Maximum index of  out  should be specified in the  len  property of callback So this way you can have a chain of  len  events which would cause the  i th event to trigger when  out[i  0  affect  This is a function  affect!(integrator event_index  which lets you modify  integrator  and it tells you about which event occured using  event_idx  i.e gives you index  i  for which  out[i  came out to be zero len  Number of callbacks chained This is compulsory to be specified Rest of the arguments have the same meaning as in  ContinuousCallback "},{"doctype":"documentation","id":"references/LinearSolve.IS_OPENBLAS","title":"IS_OPENBLAS","text":""},{"doctype":"document","id":"LinearSolve/solvers/solvers.md","title":"[Linear System Solvers]( linearsystemsolvers)","text":"MKLPardisoFactorize kwargs PardisoJL fact_phase Pardiso NUM_FACT solve_phase Pardiso SOLVE_ITERATIVE_REFINE kwargs MKLPardisoIterate kwargs PardisoJL solve_phase Pardiso NUM_FACT_SOLVE_REFINE kwargs Base PardisoJL nprocs Union Int Nothing nothing solver_type Union Int Pardiso Solver Nothing nothing matrix_type Union Int Pardiso MatrixType Nothing nothing fact_phase Union Int Pardiso Phase Nothing nothing solve_phase Union Int Pardiso Phase Nothing nothing release_phase Union Int Nothing nothing iparm Union Vector Tuple Int Int Nothing nothing dparm Union Vector Tuple Int Int Nothing nothing args generate_iterator IterativeSolvers gmres_iterable! Pl nothing Pr nothing gmres_restart kwargs args KrylovAlg Krylov gmres! Pl nothing Pr nothing gmres_restart window kwargs Linear System Solvers  linearsystemsolvers solve(prob::LinearProlem,alg;kwargs Solves for  Au=b  in the problem defined by  prob  using the algorithm  alg  If no algorithm is given a default algorithm will be chosen Recommended Methods The default algorithm  nothing  is good for choosing an algorithm that will work but one may need to change this to receive more performance or precision If more precision is necessary  QRFactorization  and  SVDFactorization  are the best choices with SVD being the slowest but most precise For efficiency  RFLUFactorization  is the fastest for dense LU-factorizations For sparse LU-factorizations  KLUFactorization  if there is less structure to the sparsity pattern and  UMFPACKFactorization  if there is more structure Pardiso.jl's methods are also known to be very efficient sparse linear solvers As sparse matrices get larger iterative solvers tend to get more efficient than factorization methods if a lower tolerance of the solution is required IterativeSolvers.jl uses a low-rank Q update in its GMRES so it tends to be faster than Krylov.jl for CPU-based arrays but it's only compatible with CPU-based arrays while Krylov.jl is more general and will support accelerators like CUDA Krylov.jl works with CPUs and GPUs and tends to be more efficient than other Krylov-based methods Finally a user can pass a custom function for handling the linear solve using  LinearSolveFunction  if existing solvers are not optimally suited for their application The interface is detailed  here Full List of Methods RecursiveFactorization.jl RFLUFactorization  a fast pure Julia LU-factorization implementation using RecursiveFactorization.jl This is by far the fastest LU-factorization implementation usually outperforming OpenBLAS and MKL but generally optimized only for Base  Array  with  Float32   Float64   ComplexF32  and  ComplexF64  Base.LinearAlgebra These overloads tend to work for many array types such as  CuArrays  for GPU-accelerated solving using the overloads provided by the respective packages Given that this can be customized per-package details given below describe a subset of important arrays  Matrix   SparseMatrixCSC   CuMatrix  etc LUFactorization(pivot=LinearAlgebra.RowMaximum  Julia's built in  lu  On dense matrices this uses the current BLAS implementation of the user's computer which by default is OpenBLAS but will use MKL if the user does  using MKL  in their system On sparse matrices this will use UMFPACK from SuiteSparse Note that this will not cache the symbolic factorization On CuMatrix it will use a CUDA-accelerated LU from CuSolver On BandedMatrix and BlockBandedMatrix it will use a banded LU QRFactorization(pivot=LinearAlgebra.NoPivot(),blocksize=16  Julia's built in  qr  On dense matrices this uses the current BLAS implementation of the user's computer which by default is OpenBLAS but will use MKL if the user does  using MKL  in their system On sparse matrices this will use SPQR from SuiteSparse On CuMatrix it will use a CUDA-accelerated QR from CuSolver On BandedMatrix and BlockBandedMatrix it will use a banded QR SVDFactorization(full=false,alg=LinearAlgebra.DivideAndConquer  Julia's built in  svd  On dense matrices this uses the current BLAS implementation of the user's computer which by default is OpenBLAS but will use MKL if the user does  using MKL  in their system GenericFactorization(fact_alg  Constructs a linear solver from a generic factorization algorithm  fact_alg  which complies with the Base.LinearAlgebra factorization API Quoting from Base If  A  is upper or lower triangular or diagonal no factorization of  A  is required and the system is solved with either forward or backward substitution For non-triangular square matrices an LU factorization is used For rectangular  A  the result is the minimum-norm least squares solution computed by a pivoted QR factorization of  A  and a rank estimate of  A  based on the R factor When  A  is sparse a similar polyalgorithm is used For indefinite matrices the  LDLt  factorization does not use pivoting during the numerical factorization and therefore the procedure can fail even for invertible matrices LinearSolve.jl LinearSolve.jl contains some linear solvers built in SimpleLUFactorization  a simple LU-factorization implementation without BLAS Fast for small matrices SuiteSparse.jl By default the SuiteSparse.jl are implemented for efficiency by caching the symbolic factorization I.e if  set_A  is used it is expected that the new  A  has the same sparsity pattern as the previous  A  If this algorithm is to be used in a context where that assumption does not hold set  reuse_symbolic=false  KLUFactorization(;reuse_symbolic=true  A fast sparse LU-factorization which specializes on sparsity patterns with less structure UMFPACKFactorization(;reuse_symbolic=true  A fast sparse multithreaded LU-factorization which specializes on sparsity patterns that are more structured Pardiso.jl Note Using this solver requires adding the package LinearSolvePardiso.jl The following algorithms are pre-specified MKLPardisoFactorize(;kwargs  A sparse factorization method MKLPardisoIterate(;kwargs  A mixed factorization+iterative method Those algorithms are defined via The full set of keyword arguments for  PardisoJL  are CUDA.jl Note that  CuArrays  are supported by  GenericFactorization  in the normal way The following are non-standard GPU factorization routines Note Using this solver requires adding the package LinearSolveCUDA.jl CudaOffloadFactorization  An offloading technique used to GPU-accelerate CPU-based computations Requires a sufficiently large  A  to overcome the data transfer costs IterativeSolvers.jl IterativeSolversJL_CG(args...;kwargs  A generic CG implementation IterativeSolversJL_GMRES(args...;kwargs  A generic GMRES implementation IterativeSolversJL_BICGSTAB(args...;kwargs  A generic BICGSTAB implementation IterativeSolversJL_MINRES(args...;kwargs  A generic MINRES implementation The general algorithm is Krylov.jl KrylovJL_CG(args...;kwargs  A generic CG implementation KrylovJL_GMRES(args...;kwargs  A generic GMRES implementation KrylovJL_BICGSTAB(args...;kwargs  A generic BICGSTAB implementation KrylovJL_MINRES(args...;kwargs  A generic MINRES implementation The general algorithm is KrylovKit.jl KrylovKitJL_CG(args...;kwargs  A generic CG implementation KrylovKitJL_GMRES(args...;kwargs  A generic GMRES implementation The general algorithm is"},{"doctype":"documentation","id":"references/SciMLBase.AbstractDAEAlgorithm","title":"AbstractDAEAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/NonlinearSolve.NewtonImmutableSolver","title":"NewtonImmutableSolver","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.jacobian","title":"jacobian","text":""},{"doctype":"documentation","id":"references/SciMLBase.IncrementingODEFunction","title":"IncrementingODEFunction","text":""},{"doctype":"documentation","id":"references/SciMLBase.solve_batch","title":"solve_batch","text":""},{"doctype":"documentation","id":"references/LinearSolve","title":"LinearSolve","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractNoiseProcess","title":"AbstractNoiseProcess","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.DAEInitializationAlgorithm","title":"DAEInitializationAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAlgorithm","title":"EnsembleAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.TimeDerivativeWrapper","title":"TimeDerivativeWrapper","text":""},{"doctype":"documentation","id":"references/SciMLBase.__has_colorvec","title":"__has_colorvec","text":""},{"doctype":"documentation","id":"references/LinearSolve.KrylovJL_MINRES","title":"KrylovJL_MINRES","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractDDEAlgorithm","title":"AbstractDDEAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.RODEFunction","title":"RODEFunction","text":"iip recompile f mass_matrix I analytic nothing tgrad nothing jac nothing jvp nothing vjp nothing jac_prototype nothing sparsity jac_prototype paramjac nothing syms nothing indepsym nothing colorvec nothing RODEFunction  AbstractRODEFunction A representation of an RODE function  f  defined by M frac{du}{dt  f(u,p,t,W)dt and all of its related functions such as the Jacobian of  f  its gradient with respect to time and more For all cases  u0  is the initial condition  p  are the parameters and  t  is the independent variable Constructor Note that only the function  f  itself is required This function should be given as  f!(du,u,p,t  or  du  f(u,p,t  See the section on  iip  for more details on in-place vs out-of-place handling All of the remaining functions are optional for improving or accelerating  the usage of  f  These include mass_matrix  the mass matrix  M  represented in the ODE function Can be used to determine that the equation is actually a differential-algebraic equation DAE if  M  is singular Note that in this case special solvers are required see the DAE solver page for more details https://diffeq.sciml.ai/stable/solvers/dae_solve Must be an AbstractArray or an AbstractSciMLOperator analytic(u0,p,t  used to pass an analytical solution function for the analytical  solution of the ODE Generally only used for testing and development of the solvers tgrad(dT,u,p,t  or dT=tgrad(u,p,t returns  frac{\\partial f(u,p,t)}{\\partial t jac(J,u,p,t  or  J=jac(u,p,t  returns  frac{df}{du jvp(Jv,v,u,p,t  or  Jv=jvp(v,u,p,t  returns the directional derivative frac{df}{du v vjp(Jv,v,u,p,t  or  Jv=vjp(v,u,p,t  returns the adjoint derivative frac{df}{du}^\\ast v jac_prototype  a prototype matrix matching the type that matches the Jacobian For example if the Jacobian is tridiagonal then an appropriately sized  Tridiagonal  matrix can be used as the prototype and integrators will specialize on this structure where possible Non-structured sparsity patterns should use a  SparseMatrixCSC  with a correct sparsity pattern for the Jacobian The default is  nothing  which means a dense Jacobian paramjac(pJ,u,p,t  returns the parameter Jacobian  frac{df}{dp  syms  the symbol names for the elements of the equation This should match  u0  in size For example if  u0  0.0,1.0  and  syms  x y  this will apply a canonical naming to the values allowing  sol[:x  in the solution and automatically naming values in plots indepsym  the canonical naming for the independent variable Defaults to nothing which internally uses  t  as the representation in any plots colorvec  a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the  jac_prototype  This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern Defaults to  nothing  which means a color vector will be internally computed on demand when required The cost of this operation is highly dependent on the sparsity pattern iip In-Place vs Out-Of-Place For more details on this argument see the ODEFunction documentation recompile Controlling Compilation and Specialization For more details on this argument see the ODEFunction documentation Fields The fields of the RODEFunction type directly match the names of the inputs"},{"doctype":"documentation","id":"references/LinearSolve.LUFactorization","title":"LUFactorization","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleDistributed","title":"EnsembleDistributed","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.__has_jvp","title":"__has_jvp","text":""},{"doctype":"documentation","id":"references/SciMLBase.has_Wfact_t","title":"has_Wfact_t","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractEnsembleProblem","title":"AbstractEnsembleProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.AbstractRODEProblem","title":"AbstractRODEProblem","text":"DocStringExtensions.TypeDefinition Base for types which define RODE problems"},{"doctype":"documentation","id":"references/SciMLBase.AbstractOptimizationSolution","title":"AbstractOptimizationSolution","text":""},{"doctype":"documentation","id":"references/LinearSolve.LinearSolveFunction","title":"LinearSolveFunction","text":""},{"doctype":"documentation","id":"references/LinearSolve.set_p","title":"set_p","text":"DocStringExtensions.MethodSignatures"},{"doctype":"documentation","id":"references/LinearSolve.needs_concrete_A","title":"needs_concrete_A","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSecondOrderODEIntegrator","title":"AbstractSecondOrderODEIntegrator","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.SecondOrderDDEProblem","title":"SecondOrderDDEProblem","text":"DocStringExtensions.TypeDefinition Define a second order DDE problem with the specified function Arguments f  The function for the second derivative du0  The initial derivative u0  The initial condition h  The initial history function tspan  The timespan for the problem p  Parameter values for  f  callback  A callback to be applied to every solver which uses the problem Defaults to nothing isinplace  optionally sets whether the function is inplace or not This is determined automatically but not inferred"},{"doctype":"documentation","id":"references/SciMLBase.IntegratorIntervals","title":"IntegratorIntervals","text":"DocStringExtensions.TypeDefinition"},{"doctype":"document","id":"LinearSolve/tutorials/caching_interface.md","title":"Linear Solve with Caching Interface","text":"A b1 A b2 lu! A A b1 A b2 n A rand n n b1 rand n b2 rand n prob A b1 linsolve init prob sol1 solve linsolve sol1 u linsolve sol1 cache b2 sol2 solve linsolve sol2 u A2 rand n n linsolve sol2 cache A2 sol3 solve linsolve sol3 u Linear Solve with Caching Interface In many cases one may want to cache information that is reused between different linear solves For example if one is going to perform then it would be more efficient to LU-factorize one time and reuse the factorization LinearSolve.jl's caching interface automates this process to use the most efficient means of solving and resolving linear systems To do this with LinearSolve.jl you simply  init  a cache  solve  replace  b  and solve again This looks like Then refactorization will occur when a new  A  is given The factorization occurs on the first solve and it stores the factorization in the cache You can retrieve this cache via  sol.cache  which is the same object as the  init  but updated to know not to re-solve the factorization The advantage of course with using LinearSolve.jl in this form is that it is efficient while being agnostic to the linear solver One can easily swap in iterative solvers sparse solvers etc and it will do all of the tricks like caching symbolic factorizations if the sparsity pattern is unchanged"},{"doctype":"documentation","id":"references/SciMLBase.SDEProblem","title":"SDEProblem","text":"DiffEqProblemLibrary SDEProblemLibrary SDEProblemLibrary importsdeproblems prob SDEProblemLibrary prob_sde_linear sol solve prob Defines an stochastic differential equation SDE problem Documentation Page https://diffeq.sciml.ai/stable/types/sde_types Mathematical Specification of a SDE Problem To define an SDE Problem you simply need to give the forcing function  f  the noise function  g  and the initial condition  u₀  which define an SDE du  f(u,p,t)dt  Σgᵢ(u,p,t)dWⁱ f  and  g  should be specified as  f(u,p,t  and   g(u,p,t  respectively and  u₀  should be an AbstractArray whose geometry matches the desired geometry of  u  Note that we are not limited to numbers or vectors for  u₀  one is allowed to provide  u₀  as arbitrary matrices  higher dimension tensors as well A vector of  g s can also be defined to determine an SDE of higher Ito dimension Problem Type Wraps the data which defines an SDE problem u  f(u,p,t)dt  Σgᵢ(u,p,t)dWⁱ with initial condition  u0  Constructors SDEProblem(f::SDEFunction,g,u0,tspan,p=NullParameters();noise=WHITE_NOISE,noise_rate_prototype=nothing SDEProblem{isinplace}(f,g,u0,tspan,p=NullParameters();noise=WHITE_NOISE,noise_rate_prototype=nothing   Defines the SDE with the specified functions The default noise is  WHITE_NOISE   isinplace  optionally sets whether the function is inplace or not This is determined automatically but not inferred Parameters are optional and if not given then a  NullParameters  singleton will be used which will throw nice errors if you try to index non-existent parameters Any extra keyword arguments are passed on to the solvers For example if you set a  callback  in the problem then that  callback  will be added in every solve call For specifying Jacobians and mass matrices see the DiffEqFunctions  performance_overloads page Fields f  The drift function in the SDE g  The noise function in the SDE u0  The initial condition tspan  The timespan for the problem p  The optional parameters for the problem Defaults to  NullParameters  noise  The noise process applied to the noise upon generation Defaults to Gaussian white noise For information on defining different noise processes see the noise process documentation page  noise_process noise_rate_prototype  A prototype type instance for the noise rates that is the output  g  It can be any type which overloads  A_mul_B  with itself being the middle argument Commonly this is a matrix or sparse matrix If this is not given it defaults to  nothing  which means the problem should be interpreted as having diagonal noise kwargs  The keyword arguments passed onto the solves Example Problems Examples problems can be found in  DiffEqProblemLibrary.jl  To use a sample problem such as  prob_sde_linear  you can do something like"},{"doctype":"documentation","id":"references/LinearSolve.RFLUFactorization","title":"RFLUFactorization","text":""},{"doctype":"documentation","id":"references/LinearSolve.default_tol","title":"default_tol","text":""},{"doctype":"documentation","id":"references/SciMLBase.isrecompile","title":"isrecompile","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractLinearAlgorithm","title":"AbstractLinearAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.NoRootFind","title":"NoRootFind","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timestep_quantile","title":"timestep_quantile","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.componentwise_mean","title":"componentwise_mean","text":""},{"doctype":"documentation","id":"references/SciMLBase.LinearSolution","title":"LinearSolution","text":"DocStringExtensions.TypeDefinition Representation of the solution to an linear system Ax=b defined by a LinearProblem Fields u  the representation of the optimization's solution resid  the residual of the solver if the method is an iterative method alg  the algorithm type used by the solver iters  the number of iterations used to solve the equation if the method is an iterative method retcode  the return code from the solver Used to determine whether the solver solved successfully  sol.retcode  Success  whether it terminated due to a user-defined callback  sol.retcode  Terminated  or whether it exited due to an error For more details see the return code section of the DifferentialEquations.jl documentation cache  the  LinearCache  object containing the solver's internal cached variables This is given to allow continuation of solver usage for example solving  Ax=b  with the same  A  and a new  b  without refactorizing  A  See the caching interface tutorial for details on how to use the  cache  effectively http://linearsolve.sciml.ai/dev/tutorials/caching_interface"},{"doctype":"documentation","id":"references/NonlinearSolve.MAXITERS_EXCEED","title":"MAXITERS_EXCEED","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.alg_autodiff","title":"alg_autodiff","text":""},{"doctype":"documentation","id":"references/SciMLBase.DEProblem","title":"DEProblem","text":"DocStringExtensions.TypeDefinition Base type for all DifferentialEquations.jl problems Concrete subtypes of  DEProblem  contain the necessary information to fully define a differential equation of the corresponding type"},{"doctype":"documentation","id":"references/NonlinearSolve.calc_J","title":"calc_J","text":""},{"doctype":"documentation","id":"references/SciMLBase.DynamicalSDEFunction","title":"DynamicalSDEFunction","text":"iip recompile f1 f2 mass_matrix I analytic nothing tgrad nothing jac nothing jvp nothing vjp nothing ggprime nothing jac_prototype nothing sparsity jac_prototype paramjac nothing syms nothing indepsym nothing colorvec nothing DynamicalSDEFunction  AbstractSDEFunction A representation of an SDE function  f  and  g  defined by M du  f(u,p,t dt  g(u,p,t dW_t as a partitioned ODE M_1 du  f_1(u,p,t dt  g(u,p,t dW_t\nM_2 du  f_2(u,p,t dt  g(u,p,t dW_t and all of its related functions such as the Jacobian of  f  its gradient with respect to time and more For all cases  u0  is the initial condition  p  are the parameters and  t  is the independent variable Constructor Note that only the functions  f_i  themselves are required These functions should be given as  f_i!(du,u,p,t  or  du  f_i(u,p,t  See the section on  iip  for more details on in-place vs out-of-place handling All of the remaining functions are optional for improving or accelerating  the usage of  f  These include mass_matrix  the mass matrix  M_i  represented in the ODE function Can be used to determine that the equation is actually a differential-algebraic equation DAE if  M  is singular Note that in this case special solvers are required see the DAE solver page for more details https://diffeq.sciml.ai/stable/solvers/dae*solve Must be an AbstractArray or an AbstractSciMLOperator Should be given as a tuple of mass matrices i.e  M*1 M_2  for the mass matrices of equations 1 and 2 respectively analytic(u0,p,t  used to pass an analytical solution function for the analytical  solution of the ODE Generally only used for testing and development of the solvers tgrad(dT,u,p,t  or dT=tgrad(u,p,t returns  frac{\\partial f(u,p,t)}{\\partial t jac(J,u,p,t  or  J=jac(u,p,t  returns  frac{df}{du jvp(Jv,v,u,p,t  or  Jv=jvp(v,u,p,t  returns the directional derivative frac{df}{du v vjp(Jv,v,u,p,t  or  Jv=vjp(v,u,p,t  returns the adjoint derivative frac{df}{du}^\\ast v ggprime(J,u,p,t  or  J  ggprime(u,p,t  returns the Milstein derivative   frac{dg(u,p,t)}{du g(u,p,t jac_prototype  a prototype matrix matching the type that matches the Jacobian For example if the Jacobian is tridiagonal then an appropriately sized  Tridiagonal  matrix can be used as the prototype and integrators will specialize on this structure where possible Non-structured sparsity patterns should use a  SparseMatrixCSC  with a correct sparsity pattern for the Jacobian The default is  nothing  which means a dense Jacobian paramjac(pJ,u,p,t  returns the parameter Jacobian  frac{df}{dp  syms  the symbol names for the elements of the equation This should match  u0  in size For example if  u0  0.0,1.0  and  syms  x y  this will apply a canonical naming to the values allowing  sol[:x  in the solution and automatically naming values in plots indepsym  the canonical naming for the independent variable Defaults to nothing which internally uses  t  as the representation in any plots colorvec  a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the  jac_prototype  This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern Defaults to  nothing  which means a color vector will be internally computed on demand when required The cost of this operation is highly dependent on the sparsity pattern iip In-Place vs Out-Of-Place For more details on this argument see the ODEFunction documentation recompile Controlling Compilation and Specialization For more details on this argument see the ODEFunction documentation Fields The fields of the DynamicalSDEFunction type directly match the names of the inputs"},{"doctype":"documentation","id":"references/SciMLBase.AbstractDynamicalSDEProblem","title":"AbstractDynamicalSDEProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.componentwise_vectors_timestep","title":"componentwise_vectors_timestep","text":""},{"doctype":"documentation","id":"references/SciMLBase.NoAD","title":"NoAD","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleSolution","title":"EnsembleSolution","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.AbstractQuadratureSolution","title":"AbstractQuadratureSolution","text":""},{"doctype":"documentation","id":"references/SciMLBase.DEFAULT_PLOT_FUNC","title":"DEFAULT_PLOT_FUNC","text":""},{"doctype":"documentation","id":"references/SciMLBase.set_ut!","title":"set_ut!","text":"Set current state of the  integrator  to  u  and  t"},{"doctype":"documentation","id":"references/SciMLBase.has_analytic","title":"has_analytic","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleThreads","title":"EnsembleThreads","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.batch_func","title":"batch_func","text":""},{"doctype":"documentation","id":"references/SciMLBase.has_mul!","title":"has_mul!","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractHistoryFunction","title":"AbstractHistoryFunction","text":"DocStringExtensions.TypeDefinition Base for types which define the history of a delay differential equation"},{"doctype":"documentation","id":"references/SciMLBase.struct_as_namedtuple","title":"struct_as_namedtuple","text":""},{"doctype":"documentation","id":"references/LinearSolve.DESolution","title":"DESolution","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractDiffEqLinearOperator","title":"AbstractDiffEqLinearOperator","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/LinearSolve.SimpleLUFactorization","title":"SimpleLUFactorization","text":""},{"doctype":"documentation","id":"references/SciMLBase.__has_tgrad","title":"__has_tgrad","text":""},{"doctype":"documentation","id":"references/SciMLBase.DiffEqIdentity","title":"DiffEqIdentity","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.@CSI_str","title":"@CSI_str","text":"Create an ANSI escape sequence string for the CSI command  cmd "},{"doctype":"documentation","id":"references/SciMLBase.solution_new_retcode","title":"solution_new_retcode","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.componentwise_vectors_timepoint","title":"componentwise_vectors_timepoint","text":""},{"doctype":"documentation","id":"references/SciMLBase.__has_paramjac","title":"__has_paramjac","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timeseries_point_quantile","title":"timeseries_point_quantile","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSDEFunction","title":"AbstractSDEFunction","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.add_analytic_labels!","title":"add_analytic_labels!","text":""},{"doctype":"documentation","id":"references/SciMLBase.DECallback","title":"DECallback","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/NonlinearSolve.nextfloat_tdir","title":"nextfloat_tdir","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.perform_step","title":"perform_step","text":""},{"doctype":"documentation","id":"references/SciMLBase.check_keywords","title":"check_keywords","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timepoint_meanvar","title":"timepoint_meanvar","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.NewtonRaphsonCache","title":"NewtonRaphsonCache","text":""},{"doctype":"documentation","id":"references/LinearSolve.__init__","title":"__init__","text":""},{"doctype":"documentation","id":"references/SciMLBase.StandardODEProblem","title":"StandardODEProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.AbstractIntegralSolution","title":"AbstractIntegralSolution","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.parameterless_type","title":"parameterless_type","text":""},{"doctype":"documentation","id":"references/SciMLBase.interpret_vars","title":"interpret_vars","text":""},{"doctype":"documentation","id":"references/LinearSolve.KrylovJL_CG","title":"KrylovJL_CG","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSecondOrderODEProblem","title":"AbstractSecondOrderODEProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.get_colorizers","title":"get_colorizers","text":""},{"doctype":"documentation","id":"references/SciMLBase.check_error","title":"check_error","text":"Check state of  integrator  and return one of the  Return Codes"},{"doctype":"documentation","id":"references/SciMLBase.build_solution","title":"build_solution","text":""},{"doctype":"documentation","id":"references/SciMLBase.unwrap_fw","title":"unwrap_fw","text":""},{"doctype":"documentation","id":"references/SciMLBase.done","title":"done","text":""},{"doctype":"documentation","id":"references/SciMLBase.has_jac","title":"has_jac","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSensitivityAlgorithm","title":"AbstractSensitivityAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.AbstractDiffEqCompositeOperator","title":"AbstractDiffEqCompositeOperator","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.DiffEqScaledOperator","title":"DiffEqScaledOperator","text":""},{"doctype":"documentation","id":"references/SciMLBase.FactorizedDiffEqArrayOperator","title":"FactorizedDiffEqArrayOperator","text":"Like DiffEqArrayOperator but stores a Factorization instead Supports left division and  ldiv  when applied to an array"},{"doctype":"documentation","id":"references/SciMLBase.postamble!","title":"postamble!","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.AbstractNonlinearSolveAlgorithm","title":"AbstractNonlinearSolveAlgorithm","text":""},{"doctype":"documentation","id":"references/SciMLBase.FINALIZE_DEFAULT","title":"FINALIZE_DEFAULT","text":""},{"doctype":"documentation","id":"references/SciMLBase.has_syms","title":"has_syms","text":""},{"doctype":"documentation","id":"references/SciMLBase.addat!","title":"addat!","text":"Grows the ODE by adding the  idxs  components Must be contiguous indices"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timepoint_meancor","title":"timepoint_meancor","text":""},{"doctype":"documentation","id":"references/NonlinearSolve.NewtonRaphson","title":"NewtonRaphson","text":""},{"doctype":"documentation","id":"references/SciMLBase.DECache","title":"DECache","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/LinearSolve.KrylovKitJL_CG","title":"KrylovKitJL_CG","text":""},{"doctype":"documentation","id":"references/SciMLBase.get_proposed_dt","title":"get_proposed_dt","text":"Gets the proposed  dt  for the next timestep"},{"doctype":"documentation","id":"references/SciMLBase.AbstractDiffEqOperator","title":"AbstractDiffEqOperator","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.AbstractADType","title":"AbstractADType","text":"DocStringExtensions.TypeDefinition Base type for AD choices"},{"doctype":"documentation","id":"references/SciMLBase.AbstractDiscretization","title":"AbstractDiscretization","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.RECOMPILE_BY_DEFAULT","title":"RECOMPILE_BY_DEFAULT","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timestep_median","title":"timestep_median","text":""},{"doctype":"documentation","id":"references/SciMLBase.numargs","title":"numargs","text":"DocStringExtensions.MethodSignatures Returns the number of arguments of  f  for the method which has the most arguments"},{"doctype":"documentation","id":"references/SciMLBase.AbstractDAEIntegrator","title":"AbstractDAEIntegrator","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.isdiscrete","title":"isdiscrete","text":"isdiscrete(alg::DEAlgorithm Trait declaration for whether an algorithm allows for discrete state values such as integers Defaults to false"},{"doctype":"documentation","id":"references/NonlinearSolve.EXACT_SOLUTION_RIGHT","title":"EXACT_SOLUTION_RIGHT","text":""},{"doctype":"documentation","id":"references/SciMLBase.getsyms","title":"getsyms","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractRODEAlgorithm","title":"AbstractRODEAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.AbstractConstantLagDDEProblem","title":"AbstractConstantLagDDEProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.AbstractLinearSolution","title":"AbstractLinearSolution","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.first_tstop","title":"first_tstop","text":"Gets the first stopping time of the integrator"},{"doctype":"documentation","id":"references/LinearSolve.SVDFactorization","title":"SVDFactorization","text":""},{"doctype":"documentation","id":"references/SciMLBase.has_Wfact","title":"has_Wfact","text":""},{"doctype":"documentation","id":"references/SciMLBase.change_t_via_interpolation!","title":"change_t_via_interpolation!","text":"Modifies the current  t  and changes all of the corresponding values using the local interpolation If the current solution has already been saved one can provide the optional value  modify_save_endpoint  to also modify the endpoint of  sol  in the same manner"},{"doctype":"documentation","id":"references/SciMLBase.getops","title":"getops","text":""},{"doctype":"documentation","id":"references/SciMLBase.DEAlgorithm","title":"DEAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/LinearSolve.RFWrapper","title":"RFWrapper","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSDEIntegrator","title":"AbstractSDEIntegrator","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.interpolant!","title":"interpolant!","text":"Hairer Norsett Wanner Solving Ordinary Differential Euations I  Nonstiff Problems Page 190 Hermite Interpolation Hermite Interpolation Hermite Interpolation Hermite Interpolation Linear Interpolation Linear Interpolation Constant Interpolation Constant Interpolation"},{"doctype":"documentation","id":"references/SciMLBase.AbstractDiscreteCallback","title":"AbstractDiscreteCallback","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/LinearSolve.set_prec","title":"set_prec","text":"DocStringExtensions.MethodSignatures"},{"doctype":"documentation","id":"references/SciMLBase.AbstractOptimizationProblem","title":"AbstractOptimizationProblem","text":"DocStringExtensions.TypeDefinition Base for types which define equations for optimization"},{"doctype":"documentation","id":"references/SciMLBase.DEIntegrator","title":"DEIntegrator","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.StandardBVProblem","title":"StandardBVProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"document","id":"SciMLBase/interfaces/Common_Keywords.md","title":"Common Keyword Arguments","text":"Common Keyword Arguments The following defines the keyword arguments which are meant to be preserved throughout all of the SciMLProblem cases where applicable Default Algorithm Hinting To help choose the default algorithm the keyword argument  alg_hints  is provided to  solve   alg_hints  is a  Vector{Symbol  which describe the problem at a high level to the solver The options are This functionality is derived via the benchmarks in  SciMLBenchmarks.jl Currently this is only implemented for the differential equation solvers Output Control These arguments control the output behavior of the solvers It defaults to maximum output to give the best interactive user experience but can be reduced all the way to only saving the solution at the final timepoint The following options are all related to output control See the Examples section at the end of this page for some example usage dense  Denotes whether to save the extra pieces required for dense continuous output Default is  save_everystep  isempty(saveat  for algorithms which have the ability to produce dense output i.e by default it's  true  unless the user has turned off saving on steps or has chosen a  saveat  value If  dense=false  the solution still acts like a function and  sol(t  is a linear interpolation between the saved time points saveat  Denotes specific times to save the solution at during the solving phase The solver will save at each of the timepoints in this array in the most efficient manner available to the solver If only  saveat  is given then the arguments  save_everystep  and  dense  are  false  by default If  saveat  is given a number then it will automatically expand to  tspan[1]:saveat:tspan[2  For methods where interpolation is not possible  saveat  may be equivalent to  tstops  The default value is    save_idxs  Denotes the indices for the components of the equation to save Defaults to saving all indices For example if you are solving a 3-dimensional ODE and given  save_idxs  1 3  only the first and third components of the solution will be outputted Notice that of course in this case the outputed solution will be two-dimensional tstops  Denotes  extra  times that the timestepping algorithm must step to This should be used to help the solver deal with discontinuities and singularities since stepping exactly at the time of the discontinuity will improve accuracy If a method cannot change timesteps fixed timestep multistep methods then  tstops  will use an interpolation matching the behavior of  saveat  If a method cannot change timesteps and also cannot interpolate then  tstops  must be a multiple of  dt  or else an error will be thrown Default is    d_discontinuities  Denotes locations of discontinuities in low order derivatives This will force FSAL algorithms which assume derivative continuity to re-evaluate the derivatives at the point of discontinuity The default is    save_everystep  Saves the result at every step Default is true if  isempty(saveat  save_on  Denotes whether intermediate solutions are saved This overrides the settings of  dense   saveat  and  save_everystep  and is used by some applicatioins to manually turn off saving temporarily Everyday use of the solvers should leave this unchanged Defaults to  true  save_start  Denotes whether the initial condition should be included in the solution type as the first timepoint Defaults to  true  save_end  Denotes whether the final timepoint is forced to be saved regardless of the other saving settings Defaults to  true  initialize_save  Denotes whether to save after the callback initialization phase when  u_modified=true  Defaults to  true  Note that  dense  requires  save_everystep=true  and  saveat=false  Stepsize Control These arguments control the timestepping routines Basic Stepsize Control adaptive  Turns on adaptive timestepping for appropriate methods Default is true abstol  Absolute tolerance in adaptive timestepping This is the tolerance on local error estimates not necessarily the global error though these quantities are related reltol  Relative tolerance in adaptive timestepping  This is the tolerance on local error estimates not necessarily the global error though these quantities are related dt  Sets the initial stepsize This is also the stepsize for fixed timestep methods Defaults to an automatic choice if the method is adaptive dtmax  Maximum dt for adaptive timestepping Defaults are package-dependent dtmin  Minimum dt for adaptive timestepping Defaults are package-dependent Fixed Stepsize Usage Note that if a method does not have adaptivity the following rules apply If  dt  is set then the algorithm will step with size  dt  each iteration If  tstops  and  dt  are both set then the algorithm will step with either a size  dt  or use a smaller step to hit the  tstops  point If  tstops  is set without  dt  then the algorithm will step directly to each value in  tstops If neither  dt  nor  tstops  are set the solver will throw an error Memory Optimizations alias_u0  allows the solver to alias the initial condition array that is contained in the problem struct Defaults to false cache  pass a solver cache to decrease the construction time This is not implemented for any of the problem interfaces at this moment Miscellaneous maxiters  Maximum number of iterations before stopping callback  Specifies a callback function that is called between iterations verbose  Toggles whether warnings are thrown when the solver exits early Defaults to true Progress Monitoring These arguments control the usage of the progressbar in the logger progress  Turns on/off the Juno progressbar Default is false progress_steps  Numbers of steps between updates of the progress bar Default is 1000 progress_name  Controls the name of the progressbar Default is the name of the problem type progress_message  Controls the message with the progressbar Defaults to showing  dt   t  the maximum of  u  The progress bars all use the Julia Logging interface in order to be generic to the IDE or programming tool that is used For more information on how this is all put together see  this discussion  Error Calculations If you are using the test problems i.e  SciMLFunction s where  f.analytic  is defined then options control the errors which are calculated By default any cheap error estimates are always calculated Extra keyword arguments include timeseries_errors dense_errors for specifying more expensive errors Automatic Differentiation Control See the Automatic Differentiation page for a full description of  sensealg   sensealg"},{"doctype":"documentation","id":"references/SciMLBase.AbstractSplitSDEProblem","title":"AbstractSplitSDEProblem","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.get_dt","title":"get_dt","text":""},{"doctype":"documentation","id":"references/SciMLBase.wrapfun_iip","title":"wrapfun_iip","text":""},{"doctype":"documentation","id":"references/LinearSolve.KrylovKitJL","title":"KrylovKitJL","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.componentwise_weighted_meancov","title":"componentwise_weighted_meancov","text":""},{"doctype":"documentation","id":"references/LinearSolve.do_factorization","title":"do_factorization","text":""},{"doctype":"documentation","id":"references/SciMLBase.has_ldiv","title":"has_ldiv","text":""},{"doctype":"documentation","id":"references/SciMLBase.DDEFunction","title":"DDEFunction","text":"iip recompile f mass_matrix I analytic nothing tgrad nothing jac nothing jvp nothing vjp nothing jac_prototype nothing sparsity jac_prototype paramjac nothing syms nothing indepsym nothing colorvec nothing DDEFunction  AbstractDDEFunction A representation of a DDE function  f  defined by M frac{du}{dt  f(u,h,p,t and all of its related functions such as the Jacobian of  f  its gradient with respect to time and more For all cases  u0  is the initial condition  p  are the parameters and  t  is the independent variable Constructor Note that only the function  f  itself is required This function should be given as  f!(du,u,h,p,t  or  du  f(u,h,p,t  See the section on  iip  for more details on in-place vs out-of-place handling The histroy function  h  acts as an interpolator over time i.e  h(t  with options matching the solution interface i.e  h(t save_idxs  2  All of the remaining functions are optional for improving or accelerating  the usage of  f  These include mass_matrix  the mass matrix  M  represented in the ODE function Can be used to determine that the equation is actually a differential-algebraic equation DAE if  M  is singular Note that in this case special solvers are required see the DAE solver page for more details https://diffeq.sciml.ai/stable/solvers/dae_solve Must be an AbstractArray or an AbstractSciMLOperator analytic(u0,p,t  used to pass an analytical solution function for the analytical  solution of the ODE Generally only used for testing and development of the solvers tgrad(dT,u,h,p,t  or dT=tgrad(u,p,t returns  frac{\\partial f(u,p,t)}{\\partial t jac(J,u,h,p,t  or  J=jac(u,p,t  returns  frac{df}{du jvp(Jv,v,h,u,p,t  or  Jv=jvp(v,u,p,t  returns the directional derivative frac{df}{du v vjp(Jv,v,h,u,p,t  or  Jv=vjp(v,u,p,t  returns the adjoint derivative frac{df}{du}^\\ast v jac_prototype  a prototype matrix matching the type that matches the Jacobian For example if the Jacobian is tridiagonal then an appropriately sized  Tridiagonal  matrix can be used as the prototype and integrators will specialize on this structure where possible Non-structured sparsity patterns should use a  SparseMatrixCSC  with a correct sparsity pattern for the Jacobian The default is  nothing  which means a dense Jacobian paramjac(pJ,h,u,p,t  returns the parameter Jacobian  frac{df}{dp  syms  the symbol names for the elements of the equation This should match  u0  in size For example if  u0  0.0,1.0  and  syms  x y  this will apply a canonical naming to the values allowing  sol[:x  in the solution and automatically naming values in plots indepsym  the canonical naming for the independent variable Defaults to nothing which internally uses  t  as the representation in any plots colorvec  a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the  jac_prototype  This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern Defaults to  nothing  which means a color vector will be internally computed on demand when required The cost of this operation is highly dependent on the sparsity pattern iip In-Place vs Out-Of-Place For more details on this argument see the ODEFunction documentation recompile Controlling Compilation and Specialization For more details on this argument see the ODEFunction documentation Fields The fields of the DDEFunction type directly match the names of the inputs"},{"doctype":"documentation","id":"references/SciMLBase.isadaptive","title":"isadaptive","text":"isadaptive(alg::DEAlgorithm Trait declaration for whether an algorithm uses adaptivity i.e has a non-quasi-static compute graph Defaults to true Checks if the integrator is adaptive"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timeseries_point_median","title":"timeseries_point_median","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractODEProblem","title":"AbstractODEProblem","text":"DocStringExtensions.TypeDefinition Base for types which define ODE problems"},{"doctype":"documentation","id":"references/NonlinearSolve.scalar_nlsolve_ad","title":"scalar_nlsolve_ad","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSDDEFunction","title":"AbstractSDDEFunction","text":"DocStringExtensions.TypeDefinition"},{"doctype":"document","id":"SciMLBase/index.md","title":"The SciML Common Interface for Julia Equation Solvers","text":"The SciML Common Interface for Julia Equation Solvers The SciML common interface ties together the numerical solvers of the Julia package ecosystem into a single unified interface It is designed for maximal efficiency and parallelism while incorporating essential features for large-scale scientific machine learning such as differentiability composability and sparsity This documentation is made to pool together the docs of the various SciML libraries to paint the overarching picture establish development norms and document the shared/common functionality Domains of SciML The SciML common interface covers the following domains Linear systems  LinearProblem  Direct methods for dense and sparse Iterative solvers with preconditioning Nonlinear Systems  NonlinearProblem  Systems of nonlinear equations Scalar bracketing systems Integrals quadrature  QuadratureProblem  Differential Equations Discrete equations function maps discrete stochastic Gillespie/Markov simulations  DiscreteProblem  Ordinary differential equations ODEs  ODEProblem  Split and Partitioned ODEs Symplectic integrators IMEX Methods  SplitODEProblem  Stochastic ordinary differential equations SODEs or SDEs  SDEProblem  Stochastic differential-algebraic equations SDAEs  SDEProblem  with mass matrices Random differential equations RODEs or RDEs  RODEProblem  Differential algebraic equations DAEs  DAEProblem  and  ODEProblem  with mass matrices Delay differential equations DDEs  DDEProblem  Neutral retarded and algebraic delay differential equations NDDEs RDDEs and DDAEs Stochastic delay differential equations SDDEs  SDDEProblem  Experimental support for stochastic neutral retarded and algebraic delay differential equations SNDDEs SRDDEs and SDDAEs Mixed discrete and continuous equations Hybrid Equations Jump Diffusions  DEProblem s with callbacks Optimization  OptimizationProblem  Nonlinear constrained optimization Stochastic/Delay/Differential-Algebraic Partial Differential Equations  PDESystem  Finite difference and finite volume methods Interfaces to finite element methods Physics-Informed Neural Networks PINNs Integro-Differential Equations Fractional Differential Equations The SciML common interface also includes  ModelingToolkit.jl  for defining such systems symbolically allowing for optimizations like automated generation of parallel code symbolic simplification and generation of sparsity patterns Extended SciML Domain In addition to the purely numerical representations of mathematical objects there are also sets of problem types associated with common mathematical algorithms These are Data-driven modeling Discrete-time data-driven dynamical systems  DiscreteDataDrivenProblem  Continuous-time data-driven dynamical systems  ContinuousDataDrivenProblem  Symbolic regression  DirectDataDrivenProblem  Uncertainty quantification and expected values  ExpectationProblem  Inverse Problems Parameter Estimation and Structural Identification We note that parameter estimation and inverse problems are solved directly on their constituant problem types using tools like  DiffEqFlux.jl  Thus for example there is no  ODEInverseProblem  and instead  ODEProblem  is used to find the parameters  p  that solve the inverse problem Common Interface High Level The SciML interface is common as the usage of arguments is standardized across all of the problem domains Underlying high level ideas include All domains use the same interface of defining a  SciMLProblem  which is then solved via  solve(prob,alg;kwargs  where  alg  is a  SciMLAlgorithm  The keyword argument namings are standardized across the organization SciMLProblem s are generally defined by a  SciMLFunction  which can define extra details about a model function such as its analytical Jacobian its sparsity patterns and so on There is an organization-wide method for defining linear and nonlinear solvers used within other solvers giving maximum control of performance to the user Types used within the packages are defined by the input types For example packages attempt to internally use the type of the initial condition as the type for the state within differential equation solvers solve  calls should be thread-safe and parallel-safe init(prob,alg;kwargs  returns an iterator which allows for directly iterating over the solution process High performance is key Any performance that is not at the top level is considered a bug and should be reported as such All functions have an in-place and out-of-place form where the in-place form is made to utilize mutation for high performance on large-scale problems and the out-of-place form is for compatibility with tooling like static arrays and some reverse-mode automatic differentiation systems User-Facing Solver Libraries DifferentialEquations.jl Multi-package interface of high performance numerical solvers of differential equations ModelingToolkit.jl The symbolic modeling package which implements the SciML symbolic common interface LinearSolve.jl Multi-package interface for specifying linear solvers direct sparse and iterative along with tools for caching and preconditioners for use in large-scale modeling NonlinearSolve.jl High performance numerical solving of nonlinear systems Quadrature.jl Multi-package interface for high performance batched and parallelized numerical quadrature GalacticOptim.jl Multi-package interface for numerical solving of optimization problems NeuralPDE.jl Physics-Informed Neural Network PINN package for transforming partial differential equations into optimization problems DiffEqOperators.jl Automated finite difference method FDM package for transforming partial differential equations into nonlinear problems and ordinary differential equations DiffEqFlux.jl High level package for scientific machine learning applications such as neural and universal differential equations solving of inverse problems parameter estimation nonlinear optimal control and more DataDrivenDiffEq.jl Multi-package interface for data-driven modeling Koopman dynamic mode decomposition symbolic regression/sparsification and automated model discovery DiffEqUncertainty.jl Extension to the dynamical modeling tools for performing uncertainty quantification and calculating expectations Interface Implementation Libraries SciMLBase.jl The core package defining the interface which is consumed by the modeling and solver packages DiffEqBase.jl The core package defining the extended interface which is consumed by the differential equation solver packages DiffEqSensitivity.jl A package which pools together the definition of derivative overloads to define the common  sensealg  automatic differentiation interface DiffEqNoiseProcess.jl A package which defines the stochastic  AbstractNoiseProcess  interface for the SciML ecosystem RecursiveArrayTools.jl A package which defines the underlying  AbstractVectorOfArray  structure used as the output for all time series results ArrayInterface.jl The package which defines the extended  AbstractArray  interface employed throughout the SciML ecosystem Using-Facing Modeling Libraries There are too many to name here and this will be populated when there is time Flowchart Example for PDE-Constrained Optimal Control The following example showcases how the pieces of the common interface connect to solve a problem that mixes inference symbolics and numerics External Binding Libraries diffeqr Solving differential equations in R using DifferentialEquations.jl with ModelingToolkit for JIT compilation and GPU-acceleration diffeqpy Solving differential equations in Python using DifferentialEquations.jl Solver Libraries There are too many to name here Check out the  SciML Organization Github Page  for details Contributing Please refer to the  SciML ColPrac Contributor's Guide on Collaborative Practices for Community Packages  for guidance on PRs issues and other matters relating to contributing to SciML There are a few community forums The diffeq-bridged and sciml-bridged channels in the  Julia Slack JuliaDiffEq  on Gitter On the Julia Discourse forums look for the  modelingtoolkit tag See also  SciML Community page"},{"doctype":"documentation","id":"references/SciMLBase.AbstractNonlinearAlgorithm","title":"AbstractNonlinearAlgorithm","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.getindepsym_defaultt","title":"getindepsym_defaultt","text":""},{"doctype":"document","id":"NonlinearSolve/index.md","title":"NonlinearSolve.jl: High-Performance Unified Nonlinear Solvers","text":"Pkg Pkg add NonlinearSolve.jl High-Performance Unified Nonlinear Solvers NonlinearSolve.jl is a unified interface for the nonlinear solving packages of Julia It includes its own high-performance nonlinear solvers which include the ability to swap out to fast direct and iterative linear solvers along with the ability to use sparse automatic differentiation for Jacobian construction and Jacobian-vector products It interfaces with other packages of the Julia ecosystem to make it easy to test alternative solver packages and pass small types to control algorithm swapping It also interfaces with the  ModelingToolkit.jl  world of symbolic modeling to allow for automatically generating high-performance code Performance is key the current methods are made to be highly performant on scalar and statically sized small problems with options for large-scale systems If you run into any performance issues please file an issue Note that this package is distinct from  SciMLNLSolve.jl  Consult the NonlinearSystemSolvers  nonlinearsystemsolvers page for information on how to import solvers from different packages Installation To install NonlinearSolve.jl use the Julia package manager Contributing Please refer to the  SciML ColPrac Contributor's Guide on Collaborative Practices for Community Packages  for guidance on PRs issues and other matters relating to contributing to ModelingToolkit There are a few community forums the diffeq-bridged channel in the  Julia Slack JuliaDiffEq  on Gitter on the Julia Discourse forums look for the  modelingtoolkit tag see also  SciML Community page Roadmap The current algorithms should support automatic differentiation though improved adjoint overloads are planned to be added in the current update which will make use of the  f(u,p  form Future updates will include standard methods for larger scale nonlinear solving like Newton-Krylov methods"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timestep_mean","title":"timestep_mean","text":""},{"doctype":"documentation","id":"references/LinearSolve.IterativeSolversJL_MINRES","title":"IterativeSolversJL_MINRES","text":""},{"doctype":"documentation","id":"references/SciMLBase.has_mul","title":"has_mul","text":""},{"doctype":"documentation","id":"references/SciMLBase.AbstractSDEProblem","title":"AbstractSDEProblem","text":"DocStringExtensions.TypeDefinition Base for types which define SDE problems"},{"doctype":"documentation","id":"references/SciMLBase.DynamicalODEProblem","title":"DynamicalODEProblem","text":"f v0 u0 tspan p kwargs f1 f2 v0 u0 tspan p kwargs Defines an dynamical ordinary differential equation ODE problem Documentation Page https://diffeq.sciml.ai/stable/types/dynamical_types Dynamical ordinary differential equations such as those arising from the definition of a Hamiltonian system or a second order ODE have a special structure that can be utilized in the solution of the differential equation On this page we describe how to define second order differential equations for their efficient numerical solution Mathematical Specification of a Dynamical ODE Problem These algorithms require a Partitioned ODE of the form frac{dv}{dt  f_1(u,t \n\\frac{du}{dt  f_2(v  This is a Partitioned ODE partitioned into two groups so the functions should be specified as  f1(dv,v,u,p,t  and  f2(du,v,u,p,t  in the inplace form where  f1  is independent of  v  unless specified by the solver and  f2  is independent of  u  and  t  This includes discretizations arising from  SecondOrderODEProblem s where the velocity is not used in the acceleration function and Hamiltonians where the potential is or can be time-dependent but the kinetic energy is only dependent on  v  Note that some methods assume that the integral of  f2  is a quadratic form That means that  f2=v'*M*v  i.e  int f_2  frac{1}{2 m v^2  giving  du  v  This is equivalent to saying that the kinetic energy is related to  v^2  The methods which require this assumption will lose accuracy if this assumption is violated Methods listed make note of this requirement with Requires quadratic kinetic energy Constructor Defines the ODE with the specified functions  isinplace  optionally sets whether the function is inplace or not This is determined automatically but not inferred Parameters are optional and if not given then a  NullParameters  singleton will be used which will throw nice errors if you try to index non-existent parameters Any extra keyword arguments are passed on to the solvers For example if you set a  callback  in the problem then that  callback  will be added in every solve call Fields f1  and  f2  The functions in the ODE v0  and  u0  The initial conditions tspan  The timespan for the problem p  The parameters for the problem Defaults to  NullParameters kwargs  The keyword arguments passed onto the solves Define a dynamical ODE function from a  DynamicalODEFunction "},{"doctype":"documentation","id":"references/SciMLBase.AbstractDEOptions","title":"AbstractDEOptions","text":"DocStringExtensions.TypeDefinition"},{"doctype":"documentation","id":"references/SciMLBase.DEFAULT_OBSERVED_NO_TIME","title":"DEFAULT_OBSERVED_NO_TIME","text":""},{"doctype":"documentation","id":"references/SciMLBase.JacobianWrapper","title":"JacobianWrapper","text":""},{"doctype":"documentation","id":"references/LinearSolve.UMFPACKFactorization","title":"UMFPACKFactorization","text":""},{"doctype":"documentation","id":"references/LinearSolve.IterativeSolversJL_GMRES","title":"IterativeSolversJL_GMRES","text":""},{"doctype":"documentation","id":"references/SciMLBase.DAESolution","title":"DAESolution","text":"DocStringExtensions.TypeDefinition Representation of the solution to an differential-algebraic equation defined by an DAEProblem DESolution Interface For more information on interacting with  DESolution  types check out the Solution Handling page of the DifferentialEquations.jl documentation https://diffeq.sciml.ai/stable/basics/solution Fields u  the representation of the DAE solution Given as an array of solutions where  u[i  corresponds to the solution at time  t[i  It is recommended in most cases one does not access  sol.u  directly and instead use the array interface described in the Solution Handling page of the DifferentialEquations.jl documentation du  the representation fo the derivatives of the DAE solution t  the time points corresponding to the saved values of the DAE solution prob  the original DAEProblem that was solved alg  the algorithm type used by the solver destats  statistics of the solver such as the number of function evaluations required number of Jacobians computed and more retcode  the return code from the solver Used to determine whether the solver solved successfully  sol.retcode  Success  whether it terminated due to a user-defined callback  sol.retcode  Terminated  or whether it exited due to an error For more details see the return code section of the DifferentialEquations.jl documentation"},{"doctype":"documentation","id":"references/SciMLBase.SteadyStateSolution","title":"SteadyStateSolution","text":""},{"doctype":"documentation","id":"references/SciMLBase.@add_kwonly","title":"@add_kwonly","text":"Define keyword-only version of the  function_definition  expands to"},{"doctype":"documentation","id":"references/SciMLBase.has_tgrad","title":"has_tgrad","text":""},{"doctype":"documentation","id":"references/SciMLBase.TimeChoiceIterator","title":"TimeChoiceIterator","text":""},{"doctype":"documentation","id":"references/SciMLBase.has_invW","title":"has_invW","text":""},{"doctype":"documentation","id":"references/SciMLBase.NonlinearProblem","title":"NonlinearProblem","text":"f u0 p kwargs f u0 p kwargs Defines a nonlinear system problem Documentation Page https://nonlinearsolve.sciml.ai/dev/basics/NonlinearProblem Mathematical Specification of a Nonlinear Problem To define a Nonlinear Problem you simply need to give the function  f  which defines the nonlinear system f(u,p  0 and an initial guess  u₀  of where  f(u,p)=0   f  should be specified as  f(u,p  or in-place as  f(du,u,p  and  u₀  should be an AbstractArray or number whose geometry matches the desired geometry of  u  Note that we are not limited to numbers or vectors for  u₀  one is allowed to provide  u₀  as arbitrary matrices  higher-dimension tensors as well Problem Type Constructors isinplace  optionally sets whether the function is in-place or not This is determined automatically but not inferred Parameters are optional and if not given then a  NullParameters  singleton will be used which will throw nice errors if you try to index non-existent parameters Any extra keyword arguments are passed on to the solvers For example if you set a  callback  in the problem then that  callback  will be added in every solve call For specifying Jacobians and mass matrices see the NonlinearFunctions  nonlinearfunctions page Fields f  The function in the problem u0  The initial guess for the steady state p  The parameters for the problem Defaults to  NullParameters  kwargs  The keyword arguments passed on to the solvers DocStringExtensions.MethodSignatures Define a steady state problem using an instance of  AbstractNonlinearFunction   AbstractNonlinearFunction DocStringExtensions.MethodSignatures Define a steady state problem from a standard ODE problem"},{"doctype":"documentation","id":"references/NonlinearSolve.prevfloat_tdir","title":"prevfloat_tdir","text":"prevfloat_tdir(x x0 x1 Move  x  one floating point towards x0"},{"doctype":"documentation","id":"references/SciMLBase.SENSITIVITY_INTERP_MESSAGE","title":"SENSITIVITY_INTERP_MESSAGE","text":""},{"doctype":"documentation","id":"references/SciMLBase.UDerivativeWrapper","title":"UDerivativeWrapper","text":""},{"doctype":"documentation","id":"references/LinearSolve.IterativeSolversJL","title":"IterativeSolversJL","text":""},{"doctype":"documentation","id":"references/LinearSolve.KrylovJL_BICGSTAB","title":"KrylovJL_BICGSTAB","text":""},{"doctype":"documentation","id":"references/LinearSolve.IterativeSolversJL_BICGSTAB","title":"IterativeSolversJL_BICGSTAB","text":""},{"doctype":"documentation","id":"references/LinearSolve.KrylovJL","title":"KrylovJL","text":""},{"doctype":"document","id":"NonlinearSolve/basics/NonlinearFunctions.md","title":"[NonlinearFunctions and Jacobian Types]( nonlinearfunctions)","text":"NonlinearFunctions and Jacobian Types  nonlinearfunctions The SciML ecosystem provides an extensive interface for declaring extra functions associated with the differential equation's data In traditional libraries there is usually only one option the Jacobian However we allow for a large array of pre-computed functions to speed up the calculations This is offered via the  NonlinearFunction  types which can be passed to the problems Function Type Definitions"},{"doctype":"documentation","id":"references/SciMLBase.AbstractPDEProblem","title":"AbstractPDEProblem","text":"DocStringExtensions.TypeDefinition Base for types which define PDE problems"},{"doctype":"documentation","id":"references/SciMLBase.RODESolution","title":"RODESolution","text":"DocStringExtensions.TypeDefinition Representation of the solution to an stochastic differential equation defined by an SDEProblem or of a random ordinary differential equation defined by an RODEProblem DESolution Interface For more information on interacting with  DESolution  types check out the Solution Handling page of the DifferentialEquations.jl documentation https://diffeq.sciml.ai/stable/basics/solution Fields u  the representation of the SDE or RODE solution Given as an array of solutions where  u[i  corresponds to the solution at time  t[i  It is recommended in most cases one does not access  sol.u  directly and instead use the array interface described in the Solution Handling page of the DifferentialEquations.jl documentation t  the time points corresponding to the saved values of the ODE solution W  the representation of the saved noise process from the solution See the Noise Processes page of the DifferentialEquations.jl documentation for more details https://diffeq.sciml.ai/stable/features/noise_process  Note that this noise is only saved in full if  save_noise=true  in the solver prob  the original SDEProblem/RODEProblem that was solved alg  the algorithm type used by the solver destats  statistics of the solver such as the number of function evaluations required number of Jacobians computed and more retcode  the return code from the solver Used to determine whether the solver solved successfully  sol.retcode  Success  whether it terminated due to a user-defined callback  sol.retcode  Terminated  or whether it exited due to an error For more details see the return code section of the DifferentialEquations.jl documentation"},{"doctype":"documentation","id":"references/SciMLBase.SteadyStateProblem","title":"SteadyStateProblem","text":"f u0 p kwargs f u0 p kwargs prob Defines an Defines a steady state ODE problem Documentation Page https://diffeq.sciml.ai/stable/types/steady state types Mathematical Specification of a Steady State Problem To define an Steady State Problem you simply need to give the function  f  which defines the ODE frac{du}{dt  f(u,p,t and an initial guess  u_0  of where  f(u,p,t)=0   f  should be specified as  f(u,p,t  or in-place as  f(du,u,p,t  and  u₀  should be an AbstractArray or number whose geometry matches the desired geometry of  u  Note that we are not limited to numbers or vectors for  u₀  one is allowed to provide  u₀  as arbitrary matrices  higher dimension tensors as well Note that for the steady-state to be defined we must have that  f  is autonomous that is  f  is independent of  t  But the form which matches the standard ODE solver should still be used The steady state solvers interpret the  f  by fixing  t=0  Problem Type Constructors isinplace  optionally sets whether the function is inplace or not This is determined automatically but not inferred Additionally the constructor from  ODEProblem s is provided Parameters are optional and if not given then a  NullParameters  singleton will be used which will throw nice errors if you try to index non-existent parameters Any extra keyword arguments are passed on to the solvers For example if you set a  callback  in the problem then that  callback  will be added in every solve call For specifying Jacobians and mass matrices see the DiffEqFunctions  performance_overloads page Fields f  The function in the ODE u0  The initial guess for the steady state p  The parameters for the problem Defaults to  NullParameters kwargs  The keyword arguments passed onto the solves Special Solution Fields The  SteadyStateSolution  type is different from the other DiffEq solutions because it does not have temporal information DocStringExtensions.MethodSignatures Define a steady state problem using an instance of  AbstractODEFunction   AbstractODEFunction DocStringExtensions.MethodSignatures Define a steady state problem from a standard ODE problem"},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.componentwise_meanvar","title":"componentwise_meanvar","text":""},{"doctype":"documentation","id":"references/SciMLBase.DEFAULT_UPDATE_FUNC","title":"DEFAULT_UPDATE_FUNC","text":""},{"doctype":"documentation","id":"references/SciMLBase.isfunctionwrapper","title":"isfunctionwrapper","text":""},{"doctype":"documentation","id":"references/SciMLBase.isinplace","title":"isinplace","text":"Check whether a function operates in place by comparing its number of arguments to the expected number The second parameter is optional if  f  is an  AbstractDiffEqFunction   AbstractDiffEqFunction See also  numargs   numargs Determine whether the function of the given problem operates in place or not"},{"doctype":"documentation","id":"references/NonlinearSolve","title":"NonlinearSolve","text":""},{"doctype":"documentation","id":"references/SciMLBase.IncrementingODEProblem","title":"IncrementingODEProblem","text":"DocStringExtensions.MethodSignatures Experimental"},{"doctype":"documentation","id":"references/LinearSolve.simplelu_factorize!","title":"simplelu_factorize!","text":""},{"doctype":"documentation","id":"references/SciMLBase.sensitivity_solution","title":"sensitivity_solution","text":""},{"doctype":"documentation","id":"references/SciMLBase.set_reltol!","title":"set_reltol!","text":""},{"doctype":"documentation","id":"references/SciMLBase.ParamJacobianWrapper","title":"ParamJacobianWrapper","text":""},{"doctype":"documentation","id":"references/SciMLBase.EnsembleAnalysis.timeseries_point_mean","title":"timeseries_point_mean","text":""},{"doctype":"documentation","id":"references/LinearSolve.set_cacheval","title":"set_cacheval","text":""},{"doctype":"documentation","id":"references/SciMLBase.observed","title":"observed","text":""},{"doctype":"documentation","id":"references/SciMLBase.DEFAULT_REDUCTION","title":"DEFAULT_REDUCTION","text":""},{"doctype":"documentation","id":"references/SciMLBase.has_destats","title":"has_destats","text":""},{"doctype":"documentation","id":"references/SciMLBase.step!","title":"step!","text":"Perform one successful step on the integrator Alternative if a  dt  is given then  step  the integrator until there is a temporal difference  ≥ dt  in  integ.t   When  true  is passed to the optional third argument the integrator advances exactly  dt "},{"doctype":"document","id":"LinearSolve/advanced/developing.md","title":"Developing New Linear Solvers","text":"MyLUFactorization P alg MyLUFactorization A b u Pl Pr maxiters abstol reltol verbose lu! convert AbstractMatrix A solve cache alg MyLUFactorization kwargs cache isfresh A convert AbstractMatrix A fact lu! A cache cache fact y ldiv! cache u cache cacheval cache b alg y nothing cache alg MyLUFactorization A b u Pl Pr maxiters abstol reltol verbose Developing New Linear Solvers Developing new or custom linear solvers for the SciML interface can be done in one of two ways You can either create a completely new set of dispatches for  init  and  solve  You can extend LinearSolve.jl's internal mechanisms For developer ease we highly recommend 2 as that will automatically make the caching API work Thus this is the documentation for how to do that Developing New Linear Solvers with LinearSolve.jl Primitives Let's create a new wrapper for a simple LU-factorization which uses only the basic machinery A simplified version is The way this works is as follows LinearSolve.jl has a  LinearCache  that everything shares this is what gives most of the ease of use However many algorithms need to cache their own things and so there's one value  cacheval  that is for the algorithms to modify The function is what is called at  init  time to create the first  cacheval  Note that this should match the type of the cache later used in  solve  as many algorithms like those in OrdinaryDiffEq.jl expect type-groundedness in the linear solver definitions While there are cheaper ways to obtain this type for LU factorizations specifically  ArrayInterfaceCore.lu_instance(A  for a demonstration this just performs an LU-factorization to get an  LU{T Matrix{T  which it puts into the  cacheval  so its typed for future use After the  init_cacheval  the only thing left to do is to define  SciMLBase.solve(cache::LinearCache alg::MyLUFactorization  Many algorithms may use a lazy matrix-free representation of the operator  A  Thus if the algorithm requires a concrete matrix like LU-factorization does the algorithm should  convert(AbstractMatrix,cache.A  The flag  cache.isfresh  states whether  A  has changed since the last  solve  Since we only need to factorize when  A  is new the factorization part of the algorithm is done in a  if cache.isfresh   cache  set_cacheval(cache fact  puts the new factorization into the cache so it's updated for future solves Then  y  ldiv!(cache.u cache.cacheval cache.b  performs the solve and a linear solution is returned via  SciMLBase.build_linear_solution(alg,y,nothing,cache "},{"doctype":"documentation","id":"references/SciMLBase.calculate_solution_errors!","title":"calculate_solution_errors!","text":""},{"doctype":"documentation","id":"references/SciMLBase.discretize","title":"discretize","text":""},{"doctype":"document","id":"NonlinearSolve/tutorials/iterator_interface.md","title":"Nonlinear Solver Iterator Interface","text":"f u p u u u0 probB f u0 solver init probB solver solve! solver Nonlinear Solver Iterator Interface There is an iterator form of the nonlinear solver which mirrors the DiffEq integrator interface Note that the  solver  object is actually immutable since we want to make it live on the stack for the sake of performance"},{"doctype":"documentation","id":"references/SciMLBase.ODEFunction","title":"ODEFunction","text":"iip recompile f mass_matrix I analytic nothing tgrad nothing jac nothing jvp nothing vjp nothing jac_prototype nothing sparsity jac_prototype paramjac nothing syms nothing indepsym nothing colorvec nothing LinearAlgebra f du u p t du t u jac J u p t J t J t J jp Diagonal zeros fun f jac jac jac_prototype jp f du u p t du u u u du u u u f_jac J u p t J u J u J u J u nothing ff f jac f_jac prob ff ones ODEFunction  AbstractODEFunction A representation of an ODE function  f  defined by M frac{du}{dt  f(u,p,t and all of its related functions such as the Jacobian of  f  its gradient with respect to time and more For all cases  u0  is the initial condition  p  are the parameters and  t  is the independent variable Constructor Note that only the function  f  itself is required This function should be given as  f!(du,u,p,t  or  du  f(u,p,t  See the section on  iip  for more details on in-place vs out-of-place handling All of the remaining functions are optional for improving or accelerating  the usage of  f  These include mass_matrix  the mass matrix  M  represented in the ODE function Can be used to determine that the equation is actually a differential-algebraic equation DAE if  M  is singular Note that in this case special solvers are required see the DAE solver page for more details https://diffeq.sciml.ai/stable/solvers/dae_solve Must be an AbstractArray or an AbstractSciMLOperator analytic(u0,p,t  used to pass an analytical solution function for the analytical  solution of the ODE Generally only used for testing and development of the solvers tgrad(dT,u,p,t  or dT=tgrad(u,p,t returns  frac{\\partial f(u,p,t)}{\\partial t jac(J,u,p,t  or  J=jac(u,p,t  returns  frac{df}{du jvp(Jv,v,u,p,t  or  Jv=jvp(v,u,p,t  returns the directional derivative frac{df}{du v vjp(Jv,v,u,p,t  or  Jv=vjp(v,u,p,t  returns the adjoint derivative frac{df}{du}^\\ast v jac_prototype  a prototype matrix matching the type that matches the Jacobian For example if the Jacobian is tridiagonal then an appropriately sized  Tridiagonal  matrix can be used as the prototype and integrators will specialize on this structure where possible Non-structured sparsity patterns should use a  SparseMatrixCSC  with a correct sparsity pattern for the Jacobian The default is  nothing  which means a dense Jacobian paramjac(pJ,u,p,t  returns the parameter Jacobian  frac{df}{dp  syms  the symbol names for the elements of the equation This should match  u0  in size For example if  u0  0.0,1.0  and  syms  x y  this will apply a canonical naming to the values allowing  sol[:x  in the solution and automatically naming values in plots indepsym  the canonical naming for the independent variable Defaults to nothing which internally uses  t  as the representation in any plots colorvec  a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the  jac_prototype  This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern Defaults to  nothing  which means a color vector will be internally computed on demand when required The cost of this operation is highly dependent on the sparsity pattern iip In-Place vs Out-Of-Place iip  is the the optional boolean for determining whether a given function is written to be used in-place or out-of-place In-place functions are  f!(du,u,p,t  where the return is ignored and the result is expected to be mutated into the value of  du  Out-of-place functions are  du=f(u,p,t  Normally this is determined automatically by looking at the method table for  f  and seeing the maximum number of arguments in available dispatches For this reason the constructor  ODEFunction(f  generally works but is type-unstable However for type-stability or to enforce correctness this option is passed via  ODEFunction{true}(f  recompile Controlling Compilation and Specialization The  recompile  parameter controls whether the ODEFunction will fully specialize on the  typeof(f  This causes recompilation of the solver for each new  f  function but gives the maximum compiler information and runtime speed By default  recompile  true  If  recompile  false  the  ODEFunction  uses  Any  type parameters for each of the functions allowing for the reuse of compilation caches but adding a dynamic dispatch at the  f  call sites potentially leading to runtime regressions Overriding the  true  default is done by passing a second type parameter after  iip  for example  ODEFunction{true,false}(f  is an in-place function with no recompilation specialization Fields The fields of the ODEFunction type directly match the names of the inputs More Details on Jacobians The following example creates an inplace  ODEFunction  whose jacobian is a  Diagonal  Note that the integrators will always make a deep copy of  fun.jac_prototype  so there's no worry of aliasing In general the jacobian prototype can be anything that has  mul  defined in particular sparse matrices or custom lazy types that support  mul  A special case is when the  jac_prototype  is a  AbstractDiffEqLinearOperator  in which case you do not need to supply  jac  as it is automatically set to  update_coefficients  Refer to the AbstractSciMLOperators documentation for more information on setting up time/parameter dependent operators Examples Declaring Explicit Jacobians for ODEs The most standard case declaring a function for a Jacobian is done by overloading the function  f(du,u,p,t  with an in-place updating function for the Jacobian  f_jac(J,u,p,t  where the value type is used for dispatch For example take the LotkaVolterra model To declare the Jacobian we simply add the dispatch Then we can supply the Jacobian with our ODE as and use this in an  ODEProblem  Symbolically Generating the Functions See the  modelingtoolkitize  function from  ModelingToolkit.jl  for automatically symbolically generating the Jacobian and more from the  numerically-defined functions"}]