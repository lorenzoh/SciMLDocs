{"attributes":{"backlinks":[],"path":"/home/runner/.julia/packages/SciMLBase/dYFnI/docs/src/interfaces/Common_Keywords.md","title":"Common Keyword Arguments"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Common Keyword Arguments"],"type":"node"},{"attributes":{},"tag":"p","children":["The following defines the keyword arguments which are meant to be preserved throughout all of the SciMLProblem cases (where applicable)."],"type":"node"},{"attributes":{},"tag":"h2","children":["Default Algorithm Hinting"],"type":"node"},{"attributes":{},"tag":"p","children":["To help choose the default algorithm, the keyword argument ",{"attributes":{},"tag":"code","children":["alg_hints"],"type":"node"}," is provided to ",{"attributes":{},"tag":"code","children":["solve"],"type":"node"},". ",{"attributes":{},"tag":"code","children":["alg_hints"],"type":"node"}," is a ",{"attributes":{},"tag":"code","children":["Vector{Symbol}"],"type":"node"}," which describe the problem at a high level to the solver. The options are:"],"type":"node"},{"attributes":{},"tag":"p","children":["This functionality is derived via the benchmarks in ",{"attributes":{"href":"https://github.com/SciML/SciMLBenchmarks.jl","title":""},"tag":"a","children":["SciMLBenchmarks.jl"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Currently this is only implemented for the differential equation solvers."],"type":"node"},{"attributes":{},"tag":"h2","children":["Output Control"],"type":"node"},{"attributes":{},"tag":"p","children":["These arguments control the output behavior of the solvers. It defaults to maximum output to give the best interactive user experience, but can be reduced all the way to only saving the solution at the final timepoint."],"type":"node"},{"attributes":{},"tag":"p","children":["The following options are all related to output control. See the \"Examples\" section at the end of this page for some example usage."],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["dense"],"type":"node"},": Denotes whether to save the extra pieces required for dense (continuous) output. Default is ",{"attributes":{},"tag":"code","children":["save_everystep && !isempty(saveat)"],"type":"node"}," for algorithms which have the ability to produce dense output, i.e. by default it's ",{"attributes":{},"tag":"code","children":["true"],"type":"node"}," unless the user has turned off saving on steps or has chosen a ",{"attributes":{},"tag":"code","children":["saveat"],"type":"node"}," value. If ",{"attributes":{},"tag":"code","children":["dense=false"],"type":"node"},", the solution still acts like a function, and ",{"attributes":{},"tag":"code","children":["sol(t)"],"type":"node"}," is a linear interpolation between the saved time points."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["saveat"],"type":"node"},": Denotes specific times to save the solution at, during the solving phase. The solver will save at each of the timepoints in this array in the most efficient manner available to the solver. If only ",{"attributes":{},"tag":"code","children":["saveat"],"type":"node"}," is given, then the arguments ",{"attributes":{},"tag":"code","children":["save_everystep"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["dense"],"type":"node"}," are ",{"attributes":{},"tag":"code","children":["false"],"type":"node"}," by default. If ",{"attributes":{},"tag":"code","children":["saveat"],"type":"node"}," is given a number, then it will automatically expand to ",{"attributes":{},"tag":"code","children":["tspan[1]:saveat:tspan[2]"],"type":"node"},". For methods where interpolation is not possible, ",{"attributes":{},"tag":"code","children":["saveat"],"type":"node"}," may be equivalent to ",{"attributes":{},"tag":"code","children":["tstops"],"type":"node"},". The default value is ",{"attributes":{},"tag":"code","children":["[]"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["save_idxs"],"type":"node"},": Denotes the indices for the components of the equation to save. Defaults to saving all indices. For example, if you are solving a 3-dimensional ODE, and given ",{"attributes":{},"tag":"code","children":["save_idxs = [1, 3]"],"type":"node"},", only the first and third components of the solution will be outputted. Notice that of course in this case the outputed solution will be two-dimensional."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["tstops"],"type":"node"},": Denotes ",{"attributes":{},"tag":"em","children":["extra"],"type":"node"}," times that the timestepping algorithm must step to. This should be used to help the solver deal with discontinuities and singularities, since stepping exactly at the time of the discontinuity will improve accuracy. If a method cannot change timesteps (fixed timestep multistep methods), then ",{"attributes":{},"tag":"code","children":["tstops"],"type":"node"}," will use an interpolation, matching the behavior of ",{"attributes":{},"tag":"code","children":["saveat"],"type":"node"},". If a method cannot change timesteps and also cannot interpolate, then ",{"attributes":{},"tag":"code","children":["tstops"],"type":"node"}," must be a multiple of ",{"attributes":{},"tag":"code","children":["dt"],"type":"node"}," or else an error will be thrown. Default is ",{"attributes":{},"tag":"code","children":["[]"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["d_discontinuities:"],"type":"node"}," Denotes locations of discontinuities in low order derivatives. This will force FSAL algorithms which assume derivative continuity to re-evaluate the derivatives at the point of discontinuity. The default is ",{"attributes":{},"tag":"code","children":["[]"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["save_everystep"],"type":"node"},": Saves the result at every step. Default is true if ",{"attributes":{},"tag":"code","children":["isempty(saveat)"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["save_on"],"type":"node"},": Denotes whether intermediate solutions are saved. This overrides the settings of ",{"attributes":{},"tag":"code","children":["dense"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["saveat"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["save_everystep"],"type":"node"}," and is used by some applicatioins to manually turn off saving temporarily. Everyday use of the solvers should leave this unchanged. Defaults to ",{"attributes":{},"tag":"code","children":["true"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["save_start"],"type":"node"},": Denotes whether the initial condition should be included in the solution type as the first timepoint. Defaults to ",{"attributes":{},"tag":"code","children":["true"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["save_end"],"type":"node"},": Denotes whether the final timepoint is forced to be saved, regardless of the other saving settings. Defaults to ",{"attributes":{},"tag":"code","children":["true"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["initialize_save"],"type":"node"},": Denotes whether to save after the callback initialization phase (when ",{"attributes":{},"tag":"code","children":["u_modified=true"],"type":"node"},"). Defaults to ",{"attributes":{},"tag":"code","children":["true"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Note that ",{"attributes":{},"tag":"code","children":["dense"],"type":"node"}," requires ",{"attributes":{},"tag":"code","children":["save_everystep=true"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["saveat=false"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h2","children":["Stepsize Control"],"type":"node"},{"attributes":{},"tag":"p","children":["These arguments control the timestepping routines."],"type":"node"},{"attributes":{},"tag":"h4","children":["Basic Stepsize Control"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["adaptive"],"type":"node"},": Turns on adaptive timestepping for appropriate methods. Default is true."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["abstol"],"type":"node"},": Absolute tolerance in adaptive timestepping. This is the tolerance on local error estimates, not necessarily the global error (though these quantities are related)."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["reltol"],"type":"node"},": Relative tolerance in adaptive timestepping.  This is the tolerance on local error estimates, not necessarily the global error (though these quantities are related)."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["dt"],"type":"node"},": Sets the initial stepsize. This is also the stepsize for fixed timestep methods. Defaults to an automatic choice if the method is adaptive."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["dtmax"],"type":"node"},": Maximum dt for adaptive timestepping. Defaults are package-dependent."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["dtmin"],"type":"node"},": Minimum dt for adaptive timestepping. Defaults are package-dependent."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h4","children":["Fixed Stepsize Usage"],"type":"node"},{"attributes":{},"tag":"p","children":["Note that if a method does not have adaptivity, the following rules apply:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If ",{"attributes":{},"tag":"code","children":["dt"],"type":"node"}," is set, then the algorithm will step with size ",{"attributes":{},"tag":"code","children":["dt"],"type":"node"}," each iteration."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If ",{"attributes":{},"tag":"code","children":["tstops"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["dt"],"type":"node"}," are both set, then the algorithm will step with either a size ",{"attributes":{},"tag":"code","children":["dt"],"type":"node"},", or use a smaller step to hit the ",{"attributes":{},"tag":"code","children":["tstops"],"type":"node"}," point."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If ",{"attributes":{},"tag":"code","children":["tstops"],"type":"node"}," is set without ",{"attributes":{},"tag":"code","children":["dt"],"type":"node"},", then the algorithm will step directly to each value in ",{"attributes":{},"tag":"code","children":["tstops"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If neither ",{"attributes":{},"tag":"code","children":["dt"],"type":"node"}," nor ",{"attributes":{},"tag":"code","children":["tstops"],"type":"node"}," are set, the solver will throw an error."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Memory Optimizations"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["alias_u0"],"type":"node"},": allows the solver to alias the initial condition array that is contained in the problem struct. Defaults to false."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["cache"],"type":"node"},": pass a solver cache to decrease the construction time. This is not implemented for any of the problem interfaces at this moment."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Miscellaneous"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["maxiters"],"type":"node"},": Maximum number of iterations before stopping."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["callback"],"type":"node"},": Specifies a callback function that is called between iterations."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["verbose"],"type":"node"},": Toggles whether warnings are thrown when the solver exits early. Defaults to true."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Progress Monitoring"],"type":"node"},{"attributes":{},"tag":"p","children":["These arguments control the usage of the progressbar in the logger."],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["progress"],"type":"node"},": Turns on/off the Juno progressbar. Default is false."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["progress_steps"],"type":"node"},": Numbers of steps between updates of the progress bar. Default is 1000."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["progress_name"],"type":"node"},": Controls the name of the progressbar. Default is the name of the problem type."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["progress_message"],"type":"node"},": Controls the message with the progressbar. Defaults to showing ",{"attributes":{},"tag":"code","children":["dt"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["t"],"type":"node"},", the maximum of ",{"attributes":{},"tag":"code","children":["u"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The progress bars all use the Julia Logging interface in order to be generic to the IDE or programming tool that is used. For more information on how this is all put together, see ",{"attributes":{"href":"https://github.com/FedeClaudi/Term.jl/discussions/67","title":""},"tag":"a","children":["this discussion"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h2","children":["Error Calculations"],"type":"node"},{"attributes":{},"tag":"p","children":["If you are using the test problems (i.e. ",{"attributes":{},"tag":"code","children":["SciMLFunction"],"type":"node"},"s where ",{"attributes":{},"tag":"code","children":["f.analytic"],"type":"node"}," is defined), then options control the errors which are calculated. By default, any cheap error estimates are always calculated. Extra keyword arguments include:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["timeseries_errors"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["dense_errors"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["for specifying more expensive errors."],"type":"node"},{"attributes":{},"tag":"h2","children":["Automatic Differentiation Control"],"type":"node"},{"attributes":{},"tag":"p","children":["See the [Automatic Differentiation page for a full description of ",{"attributes":{},"tag":"code","children":["sensealg"],"type":"node"},"](",{"attributes":{},"tag":"citation","children":[],"type":"node"}," sensealg)"],"type":"node"}],"type":"node"}],"type":"node"}