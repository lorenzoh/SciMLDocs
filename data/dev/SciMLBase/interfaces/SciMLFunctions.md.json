{"attributes":{"backlinks":[],"path":"/home/runner/.julia/packages/SciMLBase/dYFnI/docs/src/interfaces/SciMLFunctions.md","title":"[SciMLFunctions (Jacobians, Sparsity, Etc.)]( scimlfunctions)"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["[SciMLFunctions (Jacobians, Sparsity, Etc.)](",{"attributes":{},"tag":"citation","children":[],"type":"node"}," scimlfunctions)"],"type":"node"},{"attributes":{},"tag":"p","children":["The SciML ecosystem provides an extensive interface for declaring extra functions associated with the differential equation's data. In traditional libraries there is usually only one option: the Jacobian. However, we allow for a large array of pre-computed functions to speed up the calculations. This is offered via the ",{"attributes":{},"tag":"code","children":["SciMLFunction"],"type":"node"}," types which can be passed to the problems."],"type":"node"},{"attributes":{},"tag":"h2","children":["Definition of the AbstractSciMLFunction Interface"],"type":"node"},{"attributes":{},"tag":"p","children":["The following standard principles should be adhered to across all ",{"attributes":{},"tag":"code","children":["AbstractSciMLFunction"],"type":"node"}," instantiations."],"type":"node"},{"attributes":{},"tag":"h3","children":["Common Function Choice Definitions"],"type":"node"},{"attributes":{},"tag":"p","children":["The full interface available to the solvers is as follows:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["jac"],"type":"node"},": The Jacobian of the differential equation with respect to the state variable ",{"attributes":{},"tag":"code","children":["u"],"type":"node"}," at a time ",{"attributes":{},"tag":"code","children":["t"],"type":"node"}," with parameters ",{"attributes":{},"tag":"code","children":["p"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["paramjac"],"type":"node"},": The Jacobian of the differential equation with respect to ",{"attributes":{},"tag":"code","children":["p"],"type":"node"}," at state ",{"attributes":{},"tag":"code","children":["u"],"type":"node"}," at time ",{"attributes":{},"tag":"code","children":["t"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["analytic"],"type":"node"},": Defines an analytical solution using ",{"attributes":{},"tag":"code","children":["u0"],"type":"node"}," at time ",{"attributes":{},"tag":"code","children":["t"],"type":"node"}," with ",{"attributes":{},"tag":"code","children":["p"],"type":"node"}," which will cause the solvers to return errors. Used for testing."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["syms"],"type":"node"},": Allows you to name your variables for automatic names in plots and other output."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["jac_prototype"],"type":"node"},": Defines the type to be used for any internal Jacobians within the solvers."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["sparsity"],"type":"node"},": Defines the sparsity pattern to be used for the sparse differentiation schemes. By default this is equal to ",{"attributes":{},"tag":"code","children":["jac_prototype"],"type":"node"},". See the sparsity handling portion of this page for more information."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["colorvec"],"type":"node"},": The coloring pattern used by the sparse differentiator. See the sparsity handling portion of this page for more information."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["observed"],"type":"node"},": A function which allows for generating other observables from a solution."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Each function type additionally has some specific arguments, refer to their documentation for details."],"type":"node"},{"attributes":{},"tag":"h3","children":["In-place Specification and No-Recompile Mode"],"type":"node"},{"attributes":{},"tag":"p","children":["Each SciMLFunction type can be called with an \"is inplace\" (iip) choice."],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/SciMLBase.ODEFunction"},"tag":"reference","children":["ODEFunction"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["f"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"CURLY","children":[{"attributes":{"reftype":"symbol","document_id":"references/SciMLBase.ODEFunction"},"tag":"reference","children":["ODEFunction"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["iip"],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["f"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["which is a boolean for whether the function is in the inplace form (mutating to change the first value). This is automatically determined using the methods table but note that for full type-inferrability of the ",{"attributes":{},"tag":"code","children":["SciMLProblem"],"type":"node"}," this iip-ness should be specified."],"type":"node"},{"attributes":{},"tag":"p","children":["Additionally, the functions are fully specialized to reduce the runtimes. If one would instead like to not specialize on the functions to reduce compile time, then one can set ",{"attributes":{},"tag":"code","children":["recompile"],"type":"node"}," to false."],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"CURLY","children":[{"attributes":{"reftype":"symbol","document_id":"references/SciMLBase.ODEFunction"},"tag":"reference","children":["ODEFunction"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["iip"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"FALSE","children":["false"],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["f"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["This makes the ODE solver compilation independent of the function and so changing the function will not cause recompilation. One can change the default value by changing the ",{"attributes":{},"tag":"code","children":["const RECOMPILE_BY_DEFAULT = true"],"type":"node"}," to false in the SciMLBase.jl source code."],"type":"node"},{"attributes":{},"tag":"h3","children":["Specifying Jacobian Types"],"type":"node"},{"attributes":{},"tag":"p","children":["The ",{"attributes":{},"tag":"code","children":["jac"],"type":"node"}," field of an inplace style ",{"attributes":{},"tag":"code","children":["SciMLFunction"],"type":"node"}," has the signature ",{"attributes":{},"tag":"code","children":["jac(J,u,p,t)"],"type":"node"},", which updates the jacobian ",{"attributes":{},"tag":"code","children":["J"],"type":"node"}," in-place. The intended type for ",{"attributes":{},"tag":"code","children":["J"],"type":"node"}," can sometimes be inferred (e.g. when it is just a dense ",{"attributes":{},"tag":"code","children":["Matrix"],"type":"node"},"), but not in general. To supply the type information, you can provide a ",{"attributes":{},"tag":"code","children":["jac_prototype"],"type":"node"}," in the function's constructor."],"type":"node"},{"attributes":{},"tag":"p","children":["The following example creates an inplace ",{"attributes":{},"tag":"code","children":["ODEFunction"],"type":"node"}," whose jacobian is a ",{"attributes":{},"tag":"code","children":["Diagonal"],"type":"node"},":"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"USING","children":[{"attributes":{},"tag":"USING","children":["using"],"type":"node"},{"attributes":{},"tag":"DOT","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["LinearAlgebra"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["f"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"ANON_FUNC","children":[{"attributes":{},"tag":"TUPLE","children":[{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["du"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["u"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["t"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"ANON_FUNC","children":["->"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["du"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":[".="],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["t"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"STAR","children":[".*"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["u"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["jac"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"ANON_FUNC","children":[{"attributes":{},"tag":"TUPLE","children":[{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["J"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["u"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["t"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"ANON_FUNC","children":["->"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"BLOCK","children":[{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["J"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["1"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["1"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["t"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"SEMICOLON","children":[";"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["J"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["2"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["2"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["t"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"SEMICOLON","children":[";"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["J"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["jp"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["Diagonal"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["zeros"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["2"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["fun"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/SciMLBase.ODEFunction"},"tag":"reference","children":["ODEFunction"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["f"],"type":"node"},{"attributes":{},"tag":"PARAMETERS","children":[{"attributes":{},"tag":"SEMICOLON","children":[";"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["jac"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["jac"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["jac_prototype"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["jp"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Note that the integrators will always make a deep copy of ",{"attributes":{},"tag":"code","children":["fun.jac_prototype"],"type":"node"},", so there's no worry of aliasing."],"type":"node"},{"attributes":{},"tag":"p","children":["In general the jacobian prototype can be anything that has ",{"attributes":{},"tag":"code","children":["mul!"],"type":"node"}," defined, in particular sparse matrices or custom lazy types that support ",{"attributes":{},"tag":"code","children":["mul!"],"type":"node"},". A special case is when the ",{"attributes":{},"tag":"code","children":["jac_prototype"],"type":"node"}," is a ",{"attributes":{},"tag":"code","children":["AbstractDiffEqLinearOperator"],"type":"node"},", in which case you do not need to supply ",{"attributes":{},"tag":"code","children":["jac"],"type":"node"}," as it is automatically set to ",{"attributes":{},"tag":"code","children":["update_coefficients!"],"type":"node"},". Refer to the ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"SciMLBase/interfaces/@ref"},"tag":"reference","children":["DiffEqOperators"],"type":"node"}," section for more information on setting up time/parameter dependent operators."],"type":"node"},{"attributes":{},"tag":"h3","children":["Sparsity Handling"],"type":"node"},{"attributes":{},"tag":"p","children":["The solver libraries internally use packages such as ",{"attributes":{"href":"https://github.com/JuliaDiff/FiniteDiff.jl","title":""},"tag":"a","children":["FiniteDiff.jl"],"type":"node"}," and ",{"attributes":{"href":"https://github.com/JuliaDiff/SparseDiffTools.jl","title":""},"tag":"a","children":["SparseDiffTools.jl"],"type":"node"}," for high performance calculation of sparse Jacobians and Hessians, along with matrix-free calculations of Jacobian-Vector products (J*v), vector-Jacobian products (v'",{"attributes":{},"tag":"em","children":["J),"," ","and Hessian-vector products (H"],"type":"node"},"v). The SciML interface gives users the ability to control these connections in order to allow for top notch performance."],"type":"node"},{"attributes":{},"tag":"p","children":["The key arguments in the SciMLFunction is the ",{"attributes":{},"tag":"code","children":["prototype"],"type":"node"},", which is an object that will be used as the underlying Jacobian/Hessian. Thus if one wants to use a sparse Jacobian, one should specify ",{"attributes":{},"tag":"code","children":["jac_prototype"],"type":"node"}," to be a sparse matrix. The sparsity pattern used in the differentiation scheme is defined by ",{"attributes":{},"tag":"code","children":["sparsity"],"type":"node"},". By default, ",{"attributes":{},"tag":"code","children":["sparsity=jac_prototype"],"type":"node"},", meaning that the sparse automatic differentiation scheme should specialize on the sparsity pattern given by the actual sparsity pattern. This can be overridden to say perform partial matrix coloring approximations. Additionally, the color vector for the sparse differentiation directions can be specified directly via ",{"attributes":{},"tag":"code","children":["colorvec"],"type":"node"},". For more information on how these arguments control the differentiation process, see the aforementioned differentiation library documentations."],"type":"node"},{"attributes":{},"tag":"h2","children":["Traits"],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["SciMLBase.isinplace(f::SciMLBase.AbstractSciMLFunction)\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["AbstractSciMLFunction API"],"type":"node"},{"attributes":{},"tag":"h3","children":["Abstract SciML Functions"],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["SciMLBase.AbstractDiffEqFunction\nSciMLBase.AbstractODEFunction\nSciMLBase.AbstractSDEFunction\nSciMLBase.AbstractDDEFunction\nSciMLBase.AbstractDAEFunction\nSciMLBase.AbstractRODEFunction\nSciMLBase.AbstractDiscreteFunction\nSciMLBase.AbstractSDDEFunction\nSciMLBase.AbstractNonlinearFunction\n"],"type":"node"},{"attributes":{},"tag":"h3","children":["Concrete SciML Functions"],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["ODEFunction\nSplitFunction\nDynamicalODEFunction\nDDEFunction\nDynamicalDDEFunction\nDiscreteFunction\nSDEFunction\nSplitSDEFunction\nDynamicalSDEFunction\nRODEFunction\nDAEFunction\nSDDEFunction\nNonlinearFunction\nOptimizationFunction\n"],"type":"node"}],"type":"node"}],"type":"node"}