{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/Catalyst/2UqoT/docs/src/tutorials/symbolic_stoich.md","title":"Parametric Stoichiometry"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Parametric Stoichiometry"],"type":"node"},{"attributes":{},"tag":"p","children":["Catalyst supports stoichiometric coefficients that involve parameters, species, or even general expressions. In this tutorial we show several examples of how to use parametric stoichiometry, and discuss several caveats to be aware of."],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"em","children":["Note, this tutorial requires ModelingToolkit v8.5.4 or greater to work properly."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Using Symbolic Stoichiometry"],"type":"node"},{"attributes":{},"tag":"p","children":["Let's first consider a simple reversible reaction where the number of reactants is a parameter, and the number of products is the product of two parameters."],"type":"node"},{"attributes":{"lang":"@example s1"},"tag":"codeblock","children":["using Catalyst, Latexify, DifferentialEquations, ModelingToolkit, Plots\nrevsys = @reaction_network revsys begin\n    k₊, m*A --> (m*n)*B\n    k₋, B --> A\nend k₊ k₋ m n\nreactions(revsys)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Note, as always the ",{"attributes":{},"tag":"code","children":["@reaction_network"],"type":"node"}," macro sets all symbols not declared to be parameters to be species, so that in this example we have two species, ",{"attributes":{},"tag":"code","children":["A"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["B"],"type":"node"},", and four parameters. In addition, the stoichiometry is applied to the right most symbol in a given term, i.e. in the first equation the substrate ",{"attributes":{},"tag":"code","children":["A"],"type":"node"}," has stoichiometry ",{"attributes":{},"tag":"code","children":["m"],"type":"node"}," and the product ",{"attributes":{},"tag":"code","children":["B"],"type":"node"}," has stoichiometry ",{"attributes":{},"tag":"code","children":["m*n"],"type":"node"},". For example, in"],"type":"node"},{"attributes":{"lang":"@example s1"},"tag":"codeblock","children":["rn = @reaction_network begin\n    k, A*C --> 2B\n    end k\nreactions(rn)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["we see three species, ",{"attributes":{},"tag":"code","children":["(A,B,C)"],"type":"node"},", however, ",{"attributes":{},"tag":"code","children":["A"],"type":"node"}," is treated as the stoichiometric coefficient of ",{"attributes":{},"tag":"code","children":["C"],"type":"node"},", i.e."],"type":"node"},{"attributes":{"lang":"@example s1"},"tag":"codeblock","children":["rx = reactions(rn)[1]\nrx.substrates[1],rx.substoich[1]\n"],"type":"node"},{"attributes":{},"tag":"p","children":["We could have equivalently specified our systems directly via the Catalyst API. For example, for ",{"attributes":{},"tag":"code","children":["revsys"],"type":"node"}," we would could use"],"type":"node"},{"attributes":{"lang":"@example s1"},"tag":"codeblock","children":["@parameters k₊,k₋,m,n\n@variables t, A(t), B(t)\nrxs = [Reaction(k₊,[A],[B],[m],[m*n]),\n       Reaction(k₋,[B],[A])] \nrevsys2 = ReactionSystem(rxs,t; name=:revsys)\nrevsys2 == revsys\n"],"type":"node"},{"attributes":{},"tag":"p","children":["which can be simplified using the ",{"attributes":{},"tag":"code","children":["@reaction"],"type":"node"}," macro to"],"type":"node"},{"attributes":{"lang":"@example s1"},"tag":"codeblock","children":["rxs2 = [(@reaction k₊, m*A --> (m*n)*B),\n        (@reaction k₋, B --> A)]\nrevsys3 = ReactionSystem(rxs2,t; name=:revsys)\nrevsys3 == revsys\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Note, the ",{"attributes":{},"tag":"code","children":["@reaction"],"type":"node"}," macro assumes all symbols are parameters except the right most symbols in the reaction line (i.e. ",{"attributes":{},"tag":"code","children":["A"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["B"],"type":"node"},"). For example, in ",{"attributes":{},"tag":"code","children":["@reaction k, F*A + 2(H*G+B) --> D"],"type":"node"},", the substrates are ",{"attributes":{},"tag":"code","children":["(A,G,B)"],"type":"node"}," with stoichiometries ",{"attributes":{},"tag":"code","children":["(F,2*H,2)"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["Let's now convert ",{"attributes":{},"tag":"code","children":["revsys"],"type":"node"}," to ODEs and look at the resulting equations:"],"type":"node"},{"attributes":{"lang":"@example s1"},"tag":"codeblock","children":["osys = convert(ODESystem, revsys)\nequations(osys)\nshow(stdout, MIME\"text/plain\"(), equations(osys)) # hide\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Notice, as described in the ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"Catalyst/tutorials/@ref"},"tag":"reference","children":["Reaction rate laws used in simulations"],"type":"node"}," section, the default rate laws involve factorials in the stoichiometric coefficients. For this reason we must specify ",{"attributes":{},"tag":"code","children":["m"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["n"],"type":"node"}," as integers, and hence ",{"attributes":{},"tag":"em","children":["use a tuple for the parameter mapping"],"type":"node"}],"type":"node"},{"attributes":{"lang":"@example s1"},"tag":"codeblock","children":["p  = (k₊ => 1.0, k₋ => 1.0, m => 2, n => 2)\nu₀ = [A => 1.0, B => 1.0]\noprob = ODEProblem(osys, u₀, (0.0,1.0), p)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["We can now solve and plot the system"],"type":"node"},{"attributes":{"lang":"@example s1"},"tag":"codeblock","children":["sol = solve(oprob, Tsit5())\nplot(sol)\n"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"em","children":["If we had used a vector to store parameters, ",{"attributes":{},"tag":"code","children":["m"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["n"],"type":"node"}," would be converted to floating point giving an error when solving the system."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["An alternative approach to avoid the issues of using mixed floating point and integer variables is to disable the rescaling of rate laws as described in ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"Catalyst/tutorials/@ref"},"tag":"reference","children":["Reaction rate laws used in simulations"],"type":"node"}," section. This requires passing the ",{"attributes":{},"tag":"code","children":["combinatoric_ratelaws=false"],"type":"node"}," keyword to ",{"attributes":{},"tag":"code","children":["convert"],"type":"node"}," or to ",{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"}," (if directly building the problem from a ",{"attributes":{},"tag":"code","children":["ReactionSystem"],"type":"node"}," instead of first converting to an ",{"attributes":{},"tag":"code","children":["ODESystem"],"type":"node"},"). For the previous example this gives the following (different) system of ODEs"],"type":"node"},{"attributes":{"lang":"@example s1"},"tag":"codeblock","children":["osys = convert(ODESystem, revsys; combinatoric_ratelaws=false)\nequations(osys)\nshow(stdout, MIME\"text/plain\"(), equations(osys)) # hide\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Since we no longer have factorial functions appearing, our example will now run even with floating point values for ",{"attributes":{},"tag":"code","children":["m"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["n"],"type":"node"},":"],"type":"node"},{"attributes":{"lang":"@example s1"},"tag":"codeblock","children":["p  = (k₊ => 1.0, k₋ => 1.0, m => 2.0, n => 2.0)\noprob = ODEProblem(osys, u₀, (0.0,1.0), p)\nsol = solve(oprob, Tsit5())\nplot(sol)\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["Gene expression with randomly produced amounts of protein"],"type":"node"},{"attributes":{},"tag":"p","children":["As a second example, let's build the negative feedback model from ",{"attributes":{"href":"https://augustinas1.github.io/MomentClosure.jl/dev/tutorials/geometric_reactions+conditional_closures/","title":""},"tag":"a","children":["MomentClosure.jl"],"type":"node"}," that involves a bursty reaction that produces a random amount of protein."],"type":"node"},{"attributes":{},"tag":"p","children":["In our model ",{"attributes":{},"tag":"code","children":["G₋"],"type":"node"}," will denote the repressed state, and ",{"attributes":{},"tag":"code","children":["G₊"],"type":"node"}," the active state where the gene can transcribe. ",{"attributes":{},"tag":"code","children":["P"],"type":"node"}," will denote the protein product of the gene. We will assume that proteins are produced in bursts that produce ",{"attributes":{},"tag":"code","children":["m"],"type":"node"}," proteins, where ",{"attributes":{},"tag":"code","children":["m"],"type":"node"}," is a (shifted) geometric random variable with mean ",{"attributes":{},"tag":"code","children":["b"],"type":"node"},". To define ",{"attributes":{},"tag":"code","children":["m"],"type":"node"}," we must register the ",{"attributes":{},"tag":"code","children":["Distributions.Geometric"],"type":"node"}," distribution from Distributions.jl with Symbolics.jl, after which we can use it in symbolic expressions:"],"type":"node"},{"attributes":{"lang":"@example s1"},"tag":"codeblock","children":["using Distributions: Geometric\n@register_symbolic Geometric(b)\n@parameters b\nm = rand(Geometric(1/b)) + 1\nnothing # hide\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Note, as we require the shifted geometric distribution, we add one to Distributions.jl's ",{"attributes":{},"tag":"code","children":["Geometric"],"type":"node"}," random variable (which includes zero)."],"type":"node"},{"attributes":{},"tag":"p","children":["We can now define our model"],"type":"node"},{"attributes":{"lang":"@example s1"},"tag":"codeblock","children":["burstyrn = @reaction_network burstyrn begin\n    k₊, G₋ --> G₊\n    k₋*P^2, G₊ --> G₋\n    kₚ, G₊ --> G₊ + $m*P\n    γₚ, P --> ∅\nend k₊ k₋ kₚ γₚ\nreactions(burstyrn)\nshow(stdout, MIME\"text/plain\"(), reactions(burstyrn)) # hide\n"],"type":"node"},{"attributes":{},"tag":"p","children":["The parameter ",{"attributes":{},"tag":"code","children":["b"],"type":"node"}," does not need to be explicitly declared in the ",{"attributes":{},"tag":"code","children":["@reaction_network"],"type":"node"}," macro as it is detected when the expression ",{"attributes":{},"tag":"code","children":["rand(Geometric(1/b)) + 1"],"type":"node"}," is substituted for ",{"attributes":{},"tag":"code","children":["m"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["We next convert our network to a jump process representation"],"type":"node"},{"attributes":{"lang":"@example s1"},"tag":"codeblock","children":["jsys = convert(JumpSystem, burstyrn; combinatoric_ratelaws=false)\nequations(jsys)\nshow(stdout, MIME\"text/plain\"(), equations(jsys)) # hide\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Notice, the ",{"attributes":{},"tag":"code","children":["equations"],"type":"node"}," of ",{"attributes":{},"tag":"code","children":["jsys"],"type":"node"}," have three ",{"attributes":{},"tag":"code","children":["MassActionJump"],"type":"node"},"s for the first three reactions, and one ",{"attributes":{},"tag":"code","children":["ConstantRateJump"],"type":"node"}," for the last reaction. If we examine the ",{"attributes":{},"tag":"code","children":["ConstantRateJump"],"type":"node"}," more closely we can see the generated ",{"attributes":{},"tag":"code","children":["rate"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["affect!"],"type":"node"}," functions for the bursty reaction that makes protein"],"type":"node"},{"attributes":{"lang":"@example s1"},"tag":"codeblock","children":["equations(jsys)[4].rate\nshow(stdout, MIME\"text/plain\"(), equations(jsys)[4].rate) # hide\n"],"type":"node"},{"attributes":{"lang":"@example s1"},"tag":"codeblock","children":["equations(jsys)[4].affect!\nshow(stdout, MIME\"text/plain\"(), equations(jsys)[4].affect!) # hide\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Finally, we can now simulate our jumpsystem"],"type":"node"},{"attributes":{"lang":"@example s1"},"tag":"codeblock","children":["pmean = 200\nbval = 70\nγₚval = 1\nk₋val = 0.001\nk₊val = 0.05\nkₚval = pmean * γₚval * (k₋val * pmean^2 + k₊val) / (k₊val * bval)\np = symmap_to_varmap(jsys, (:k₊ => k₊val, :k₋ => k₋val, :kₚ => kₚval, :γₚ => γₚval, :b => bval))\nu₀ = symmap_to_varmap(jsys, [:G₊ => 1, :G₋ => 0, :P => 1])\ntspan = (0., 6.0)   # time interval to solve over\ndprob = DiscreteProblem(jsys, u₀, tspan, p)\njprob = JumpProblem(jsys, dprob, Direct())\nsol = solve(jprob, SSAStepper())\nplot(sol.t, sol[jsys.P], legend=false, xlabel=\"time\", ylabel=\"P(t)\")\n"],"type":"node"},{"attributes":{},"tag":"p","children":["To double check our results are consistent with MomentClosure.jl, let's calculate and plot the average amount of protein (which is also plotted in the MomentClosure.jl ",{"attributes":{"href":"https://augustinas1.github.io/MomentClosure.jl/dev/tutorials/geometric_reactions+conditional_closures/","title":""},"tag":"a","children":["tutorial"],"type":"node"},")."],"type":"node"},{"attributes":{"lang":"@example s1"},"tag":"codeblock","children":["function getmean(jprob, Nsims, tv)\n    Pmean = zeros(length(tv))\n    @variables t, P(t)\n    for n in 1:Nsims\n        sol = solve(jprob, SSAStepper())        \n        Pmean .+= sol(tv, idxs=P)\n    end\n    Pmean ./= Nsims\nend\ntv = range(tspan[1],tspan[2],step=.1)\npsim_mean = getmean(jprob, 20000, tv)\nplot(tv, psim_mean, ylabel=\"average of P(t)\", xlabel=\"time\", xlim=(0.0,6.0), legend=false)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Comparing, we see similar averages for ",{"attributes":{},"tag":"code","children":["P(t)"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"}