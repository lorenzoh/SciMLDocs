{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/ModelingToolkit/fp90z/docs/src/comparison.md","title":"Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Comparison of ModelingToolkit vs Equation-Based and Block Modeling Languages"],"type":"node"},{"attributes":{},"tag":"h2","children":["Comparison Against Modelica"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Both Modelica and ModelingToolkit.jl are acausal modeling languages."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Modelica is a language with many different implementations, such as ",{"attributes":{"href":"https://www.3ds.com/products-services/catia/products/dymola/","title":""},"tag":"a","children":["Dymola"],"type":"node"}," and ",{"attributes":{"href":"https://openmodelica.org/","title":""},"tag":"a","children":["OpenModelica"],"type":"node"},", which have differing levels of performance and can give different results on the same model. Many of the commonly used Modelica compilers are not open source. ModelingToolkit.jl is a language with a single canonical open source implementation."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["All current Modelica compiler implementations are fixed and not extendable by the users from the Modelica language itself. For example, the Dymola compiler ",{"attributes":{"href":"https://www.claytex.com/tech-blog/model-translation-and-symbolic-manipulation/","title":""},"tag":"a","children":["shares its symbolic processing pipeline"],"type":"node"}," which is roughly equivalent to the ",{"attributes":{},"tag":"code","children":["dae_index_lowering"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["structural_simplify"],"type":"node"}," of ModelingToolkit.jl. ModelingToolkit.jl is an open and hackable transformation system which allows users to add new non-standard transformations and control the order of application."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Modelica is a declarative programming language. ModelingToolkit.jl is a declarative symbolic modeling language used from within the Julia programming language. Its programming language semantics, such as loop constructs and conditionals, can be used to more easily generate models."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Modelica is an object-oriented single dispatch language. ModelingToolkit.jl, built on Julia, uses multiple dispatch extensively to simplify code."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Many Modelica compilers supply a GUI. ModelingToolkit.jl does not."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Modelica can be used to simulate ODE and DAE systems. ModelingToolkit.jl has a much more expansive set of system types, including nonlinear systems, SDEs, PDEs, and more."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Comparison Against Simulink"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Simulink is a causal modeling environment, whereas ModelingToolkit.jl is an acausal modeling environment. For an overview of the differences, consult academic reviews such as ",{"attributes":{"href":"https://arxiv.org/abs/1909.00484","title":""},"tag":"a","children":["this one"],"type":"node"},". In this sense, ModelingToolkit.jl is more similar to the Simscape sub-environment."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Simulink is used from MATLAB while ModelingToolkit.jl is used from Julia. Thus any user defined functions have the performance of their host language. For information on the performance differences between Julia and MATLAB, consult ",{"attributes":{"href":"https://julialang.org/benchmarks/","title":""},"tag":"a","children":["open benchmarks"],"type":"node"}," which demonstrate Julia as an order of magnitude or more faster in many cases due to its JIT compilation."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Simulink uses the MATLAB differential equation solvers while ModelingToolkit.jl uses ",{"attributes":{"href":"https://diffeq.sciml.ai/dev/","title":""},"tag":"a","children":["DifferentialEquations.jl"],"type":"node"},". For a systematic comparison between the solvers, consult ",{"attributes":{"href":"https://benchmarks.sciml.ai/html/MultiLanguage/wrapper_packages.html","title":""},"tag":"a","children":["open benchmarks"],"type":"node"}," which demonstrate two orders of magnitude performance advantage for the native Julia solvers across many benchmark problems."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Simulink comes with a Graphical User Interface (GUI), ModelingToolkit.jl does not."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Simulink is a proprietary software, meaning users cannot actively modify or extend the software. ModelingToolkit.jl is built in Julia and used in Julia, where users can actively extend and modify the software interactively in the REPL and contribute to its open source repositories."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Simulink covers ODE and DAE systems. ModelingToolkit.jl has a much more expansive set of system types, including SDEs, PDEs, optimization problems, and more."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Comparison Against CASADI"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["CASADI is written in C++ but used from Python/MATLAB, meaning that it cannot be directly extended by users unless they are using the C++ interface and run a local build of CASADI. ModelingToolkit.jl is both written and used from Julia, meaning that users can easily extend the library on the fly, even interactively in the REPL."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["CASADI includes limited support for Computer Algebra System (CAS) functionality, while ModelingToolkit.jl is built on the full ",{"attributes":{"href":"https://github.com/JuliaSymbolics/Symbolics.jl","title":""},"tag":"a","children":["Symbolics.jl"],"type":"node"}," CAS."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["CASADI supports DAE and ODE problems via SUNDIALS IDAS and CVODES. ModelingToolkit.jl supports DAE and ODE problems via ",{"attributes":{"href":"https://diffeq.sciml.ai/dev/","title":""},"tag":"a","children":["DifferentialEquations.jl"],"type":"node"},", of which Sundials.jl is <1% of the total available solvers and is outperformed by the native Julia solvers on the vast majority of the benchmark equations. In addition, the DifferentialEquations.jl interface is confederated, meaning that any user can dynamically extend the system to add new solvers to the interface by defining new dispatches of solve."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["CASADI's DAEBuilder does not implement efficiency transformations like tearing which are standard in the ModelingToolkit.jl transformation pipeline."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["CASADI supports special functionality for quadratic programming problems while ModelingToolkit only provides nonlinear programming via ",{"attributes":{},"tag":"code","children":["OptimizationSystem"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["ModelingToolkit.jl integrates with its host language Julia, so Julia code can be automatically converted into ModelingToolkit expressions. Users of CASADI must explicitly create CASADI expressions."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Comparison Against Modia.jl"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Modia.jl uses Julia's expression objects for representing its equations. ModelingToolkit.jl uses ",{"attributes":{"href":"https://symbolics.juliasymbolics.org/dev/","title":""},"tag":"a","children":["Symbolics.jl"],"type":"node"},", and thus the Julia expressions follow Julia semantics and can be manipulated using a computer algebra system (CAS)."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Modia's compilation pipeline is similar to the ",{"attributes":{"href":"https://www.claytex.com/tech-blog/model-translation-and-symbolic-manipulation/","title":""},"tag":"a","children":["Dymola symbolic processing pipeline"],"type":"node"}," with some improvements. ModelingToolkit.jl has an open transformation pipeline that allows for users to extend and reorder transformation passes, where ",{"attributes":{},"tag":"code","children":["structural_simplify"],"type":"node"}," is an adaptation of the Modia.jl-improved alias elimination and tearing algorithms."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Both Modia and ModelingToolkit generate ",{"attributes":{},"tag":"code","children":["DAEProblem"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"}," forms for solving with ",{"attributes":{"href":"https://diffeq.sciml.ai/dev/","title":""},"tag":"a","children":["DifferentialEquations.jl"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["ModelingToolkit.jl integrates with its host language Julia, so Julia code can be automatically converted into ModelingToolkit expressions. Users of Modia must explicitly create Modia expressions."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Modia covers DAE systems. ModelingToolkit.jl has a much more expansive set of system types, including SDEs, PDEs, optimization problems, and more."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Comparison Against Causal.jl"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Causal.jl is a causal modeling environment, whereas ModelingToolkit.jl is an acausal modeling environment. For an overview of the differences, consult academic reviews such as ",{"attributes":{"href":"https://arxiv.org/abs/1909.00484","title":""},"tag":"a","children":["this one"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Both ModelingToolkit.jl and Causal.jl use ",{"attributes":{"href":"https://diffeq.sciml.ai/stable/","title":""},"tag":"a","children":["DifferentialEquations.jl"],"type":"node"}," as the backend solver library."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Causal.jl lets one add arbitrary equation systems to a given node, and allow the output to effect the next node. This means an SDE may drive an ODE. These two portions are solved with different solver methods in tandem. In ModelingToolkit.jl, such connections promote the whole system to an SDE. This results in better accuracy and stability, though in some cases it can be less performant."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Causal.jl, similar to Simulink, breaks algebraic loops via inexact heuristics. ModelingToolkit.jl treats algebraic loops exactly through algebraic equations in the generated model."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}