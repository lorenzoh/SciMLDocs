{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/ModelingToolkit/fp90z/docs/src/mtkitize_tutorials/modelingtoolkitize_index_reduction.md","title":"Automated Index Reduction of DAEs"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Automated Index Reduction of DAEs"],"type":"node"},{"attributes":{},"tag":"p","children":["In many cases one may accidentally write down a DAE that is not easily solvable by numerical methods. In this tutorial we will walk through an example of a pendulum which accidentally generates an index-3 DAE, and show how to use the ",{"attributes":{},"tag":"code","children":["modelingtoolkitize"],"type":"node"}," to correct the model definition before solving."],"type":"node"},{"attributes":{},"tag":"h2","children":["Copy-Pastable Example"],"type":"node"},{"attributes":{"lang":"@example indexred"},"tag":"codeblock","children":["using ModelingToolkit\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing Plots\n\nfunction pendulum!(du, u, p, t)\n    x, dx, y, dy, T = u\n    g, L = p\n    du[1] = dx\n    du[2] = T*x\n    du[3] = dy\n    du[4] = T*y - g\n    du[5] = x^2 + y^2 - L^2\n    return nothing\nend\npendulum_fun! = ODEFunction(pendulum!, mass_matrix=Diagonal([1,1,1,1,0]))\nu0 = [1.0, 0, 0, 0, 0]\np = [9.8, 1]\ntspan = (0, 10.0)\npendulum_prob = ODEProblem(pendulum_fun!, u0, tspan, p)\ntraced_sys = modelingtoolkitize(pendulum_prob)\npendulum_sys = structural_simplify(dae_index_lowering(traced_sys))\nprob = ODAEProblem(pendulum_sys, [], tspan)\nsol = solve(prob, Tsit5(),abstol=1e-8,reltol=1e-8)\nplot(sol, vars=states(traced_sys))\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["Explanation"],"type":"node"},{"attributes":{},"tag":"h3","children":["Attempting to Solve the Equation"],"type":"node"},{"attributes":{},"tag":"p","children":["In this tutorial we will look at the pendulum system:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\begin{aligned}\n    x^\\prime &= v_x\\\\\n    v_x^\\prime &= Tx\\\\\n    y^\\prime &= v_y\\\\\n    v_y^\\prime &= Ty - g\\\\\n    0 &= x^2 + y^2 - L^2\n\\end{aligned}"],"type":"node"},{"attributes":{},"tag":"p","children":["As a good DifferentialEquations.jl user, one would follow ",{"attributes":{"href":"https://diffeq.sciml.ai/stable/tutorials/dae_example/#Mass-Matrix-Differential-Algebraic-Equations-(DAEs)","title":""},"tag":"a","children":["the mass matrix DAE tutorial"],"type":"node"}," to arrive at code for simulating the model:"],"type":"node"},{"attributes":{"lang":"@example indexred"},"tag":"codeblock","children":["using OrdinaryDiffEq, LinearAlgebra\nfunction pendulum!(du, u, p, t)\n    x, dx, y, dy, T = u\n    g, L = p\n    du[1] = dx; du[2] = T*x\n    du[3] = dy; du[4] = T*y - g\n    du[5] = x^2 + y^2 - L^2\nend\npendulum_fun! = ODEFunction(pendulum!, mass_matrix=Diagonal([1,1,1,1,0]))\nu0 = [1.0, 0, 0, 0, 0]; p = [9.8, 1]; tspan = (0, 10.0)\npendulum_prob = ODEProblem(pendulum_fun!, u0, tspan, p)\nsolve(pendulum_prob,Rodas4())\n"],"type":"node"},{"attributes":{},"tag":"p","children":["However, one will quickly be greeted with the unfortunate message:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":["┌ Warning: First function call produced NaNs. Exiting.\n└ @ OrdinaryDiffEq C:\\Users\\accou\\.julia\\packages\\OrdinaryDiffEq\\yCczp\\src\\initdt.jl:76\n┌ Warning: Automatic dt set the starting dt as NaN, causing instability.\n└ @ OrdinaryDiffEq C:\\Users\\accou\\.julia\\packages\\OrdinaryDiffEq\\yCczp\\src\\solve.jl:485\n┌ Warning: NaN dt detected. Likely a NaN value in the state, parameters, or derivative value caused this outcome.\n└ @ SciMLBase C:\\Users\\accou\\.julia\\packages\\SciMLBase\\DrPil\\src\\integrator_interface.jl:325"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Did you implement the DAE incorrectly? No. Is the solver broken? No."],"type":"node"},{"attributes":{},"tag":"h3","children":["Understanding DAE Index"],"type":"node"},{"attributes":{},"tag":"p","children":["It turns out that this is a property of the DAE that we are attempting to solve. This kind of DAE is known as an index-3 DAE. For a complete discussion of DAE index, see ",{"attributes":{"href":"http://www.scholarpedia.org/article/Differential-algebraic_equations","title":""},"tag":"a","children":["this article"],"type":"node"},". Essentially the issue here is that we have 4 differential variables (",{"attributes":{},"tag":"math","children":["x"],"type":"node"},", ",{"attributes":{},"tag":"math","children":["v_x"],"type":"node"},", ",{"attributes":{},"tag":"math","children":["y"],"type":"node"},", ",{"attributes":{},"tag":"math","children":["v_y"],"type":"node"},") and one algebraic variable ",{"attributes":{},"tag":"math","children":["T"],"type":"node"}," (which we can know because there is no ",{"attributes":{},"tag":"code","children":["D(T)"],"type":"node"}," term in the equations). An index-1 DAE always satisfies that the Jacobian of the algebraic equations is non-singular. Here, the first 4 equations are differential equations, with the last term the algebraic relationship. However, the partial derivative of ",{"attributes":{},"tag":"code","children":["x^2 + y^2 - L^2"],"type":"node"}," w.r.t. ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}," is zero, and thus the Jacobian of the algebraic equations is the zero matrix and thus it's singular. This is a very quick way to see whether the DAE is index 1!"],"type":"node"},{"attributes":{},"tag":"p","children":["The problem with higher order DAEs is that the matrices used in Newton solves are singular or close to singular when applied to such problems. Because of this fact, the nonlinear solvers (or Rosenbrock methods) break down, making them difficult to solve. The classic paper ",{"attributes":{"href":"https://epubs.siam.org/doi/10.1137/0903023","title":""},"tag":"a","children":["DAEs are not ODEs"],"type":"node"}," goes into detail on this and shows that many methods are no longer convergent when index is higher than one. So it's not necessarily the fault of the solver or the implementation: this is known."],"type":"node"},{"attributes":{},"tag":"p","children":["But that's not a satisfying answer, so what do you do about it?"],"type":"node"},{"attributes":{},"tag":"h3","children":["Transforming Higher Order DAEs to Index-1 DAEs"],"type":"node"},{"attributes":{},"tag":"p","children":["It turns out that higher order DAEs can be transformed into lower order DAEs. ",{"attributes":{"href":"https://courses.seas.harvard.edu/courses/am205/g_act/dae_notes.pdf","title":""},"tag":"a","children":["If you differentiate the last equation two times and perform a substitution,"," ","you can arrive at the following set of equations"],"type":"node"},":"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\begin{aligned}\nx^\\prime =& v_x \\\\\nv_x^\\prime =& x T \\\\\ny^\\prime =& v_y \\\\\nv_y^\\prime =& y T - g \\\\\n0 =& 2 \\left(v_x^{2} + v_y^{2} + y ( y T - g ) + T x^2 \\right)\n\\end{aligned}"],"type":"node"},{"attributes":{},"tag":"p","children":["Note that this is mathematically-equivalent to the equation that we had before, but the Jacobian w.r.t. ",{"attributes":{},"tag":"code","children":["T"],"type":"node"}," of the algebraic equation is no longer zero because of the substitution. This means that if you wrote down this version of the model it will be index-1 and solve correctly! In fact, this is how DAE index is commonly defined: the number of differentiations it takes to transform the DAE into an ODE, where an ODE is an index-0 DAE by substituting out all of the algebraic relationships."],"type":"node"},{"attributes":{},"tag":"h3","children":["Automating the Index Reduction"],"type":"node"},{"attributes":{},"tag":"p","children":["However, requiring the user to sit there and work through this process on potentially millions of equations is an unfathomable mental overhead. But, we can avoid this by using methods like ",{"attributes":{"href":"https://ptolemy.berkeley.edu/projects/embedded/eecsx44/lectures/Spring2013/modelica-dae-part-2.pdf","title":""},"tag":"a","children":["the Pantelides algorithm"],"type":"node"}," for automatically performing this reduction to index 1. While this requires the ModelingToolkit symbolic form, we use ",{"attributes":{},"tag":"code","children":["modelingtoolkitize"],"type":"node"}," to transform the numerical code into symbolic code, run ",{"attributes":{},"tag":"code","children":["dae_index_lowering"],"type":"node"}," lowering, then transform back to numerical code with ",{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"},", and solve with a numerical solver. Let's try that out:"],"type":"node"},{"attributes":{"lang":"@example indexred"},"tag":"codeblock","children":["traced_sys = modelingtoolkitize(pendulum_prob)\npendulum_sys = structural_simplify(dae_index_lowering(traced_sys))\nprob = ODEProblem(pendulum_sys, Pair[], tspan)\nsol = solve(prob, Rodas4())\n\nusing Plots\nplot(sol, vars=states(traced_sys))\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Note that plotting using ",{"attributes":{},"tag":"code","children":["states(traced_sys)"],"type":"node"}," is done so that any variables which are symbolically eliminated, or any variable reorderings done for enhanced parallelism/performance, still show up in the resulting plot and the plot is shown in the same order as the original numerical code."],"type":"node"},{"attributes":{},"tag":"p","children":["Note that we can even go a little bit further. If we use the ",{"attributes":{},"tag":"code","children":["ODAEProblem"],"type":"node"}," constructor, we can remove the algebraic equations from the states of the system and fully transform the index-3 DAE into an index-0 ODE which can be solved via an explicit Runge-Kutta method:"],"type":"node"},{"attributes":{"lang":"@example indexred"},"tag":"codeblock","children":["traced_sys = modelingtoolkitize(pendulum_prob)\npendulum_sys = structural_simplify(dae_index_lowering(traced_sys))\nprob = ODAEProblem(pendulum_sys, Pair[], tspan)\nsol = solve(prob, Tsit5(),abstol=1e-8,reltol=1e-8)\nplot(sol, vars=states(traced_sys))\n"],"type":"node"},{"attributes":{},"tag":"p","children":["And there you go: this has transformed the model from being too hard to solve with implicit DAE solvers, to something that is easily solved with explicit Runge-Kutta methods for non-stiff equations."],"type":"node"}],"type":"node"}],"type":"node"}