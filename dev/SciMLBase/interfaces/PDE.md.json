{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/docs/src/interfaces/PDE.md","title":"The PDE Definition Interface"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["The PDE Definition Interface"],"type":"node"},{"attributes":{},"tag":"p","children":["While ODEs ",{"attributes":{},"tag":"math","children":["u' = f(u,p,t)"],"type":"node"}," can be defined by a user-function ",{"attributes":{},"tag":"code","children":["f"],"type":"node"},", for PDEs the function form can be different for every PDE. How many functions, and how many inputs? This can always change. The SciML ecosystem solves this problem by using ",{"attributes":{"href":"https://mtk.sciml.ai/dev/","title":""},"tag":"a","children":["ModelingToolkit.jl"],"type":"node"}," to define ",{"attributes":{},"tag":"code","children":["PDESystem"],"type":"node"},", a high-level symbolic description of the PDE to be consumed by other packages."],"type":"node"},{"attributes":{},"tag":"p","children":["The vision for the common PDE interface is that a user should only have to specify their PDE once, mathematically, and have instant access to everything as simple as a finite difference method with constant grid spacing, to something as complex as a distributed multi-GPU discontinuous Galerkin method."],"type":"node"},{"attributes":{},"tag":"p","children":["The key to the common PDE interface is a separation of the symbolic handling from the numerical world. All of the discretizers should not \"solve\" the PDE, but instead be a conversion of the mathematical specification to a numerical problem. Preferably, the transformation should be to another ModelingToolkit.jl ",{"attributes":{},"tag":"code","children":["AbstractSystem"],"type":"node"}," via a ",{"attributes":{},"tag":"code","children":["symbolic_discretize"],"type":"node"}," dispatch, but in some cases this cannot be done or will not be performant. Thus in some cases, only a ",{"attributes":{},"tag":"code","children":["discretize"],"type":"node"}," definition is given to a ",{"attributes":{},"tag":"code","children":["SciMLProblem"],"type":"node"},", with ",{"attributes":{},"tag":"code","children":["symbolic_discretize"],"type":"node"}," simply providing diagnostic or lower level information about the construction process."],"type":"node"},{"attributes":{},"tag":"p","children":["These elementary problems, such as solving linear systems ",{"attributes":{},"tag":"code","children":["Ax=b"],"type":"node"},", solving nonlinear systems ",{"attributes":{},"tag":"code","children":["f(x)=0"],"type":"node"},", ODEs, etc. are all defined by SciMLBase.jl, which then numerical solvers can all target these common forms. Thus someone who works on linear solvers doesn't necessarily need to be working on a Discontinuous Galerkin or finite element library, but instead \"linear solvers that are good for matrices A with properties ...\" which are then accessible by every other discretization method in the common PDE interface."],"type":"node"},{"attributes":{},"tag":"p","children":["Similar to the rest of the ",{"attributes":{},"tag":"code","children":["AbstractSystem"],"type":"node"}," types, transformation and analyses functions will allow for simplifying the PDE before solving it, and constructing block symbolic functions like Jacobians."],"type":"node"},{"attributes":{},"tag":"h2","children":["Constructors"],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["ModelingToolkit.PDESystem\n"],"type":"node"},{"attributes":{},"tag":"h3","children":["Domains (WIP)"],"type":"node"},{"attributes":{},"tag":"p","children":["Domains are specifying by saying ",{"attributes":{},"tag":"code","children":["indepvar in domain"],"type":"node"},", where ",{"attributes":{},"tag":"code","children":["indepvar"],"type":"node"}," is a single or a collection of independent variables, and ",{"attributes":{},"tag":"code","children":["domain"],"type":"node"}," is the chosen domain type. A 2-tuple can be used to indicate an ",{"attributes":{},"tag":"code","children":["Interval"],"type":"node"},". Thus forms for the ",{"attributes":{},"tag":"code","children":["indepvar"],"type":"node"}," can be like:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["t"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"ELEMENT_OF","children":["∈"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"TUPLE","children":[{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"FLOAT","children":["0.0"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"FLOAT","children":["1.0"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"TUPLE","children":[{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["t"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["x"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"ELEMENT_OF","children":["∈"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["UnitDisk"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"VECT","children":[{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["v"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["w"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["x"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["y"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["z"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"ELEMENT_OF","children":["∈"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["VectorUnitBall"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["5"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h4","children":["Domain Types (WIP)"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["Interval(a,b)"],"type":"node"},": Defines the domain of an interval from ",{"attributes":{},"tag":"code","children":["a"],"type":"node"}," to ",{"attributes":{},"tag":"code","children":["b"],"type":"node"}," (requires explicit import from ",{"attributes":{},"tag":"code","children":["DomainSets.jl"],"type":"node"},", but a 2-tuple can be used instead)"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":[{"attributes":{},"tag":"code","children":["discretize"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["symbolic_discretize"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The only functions which act on a PDESystem are the following:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["discretize(sys,discretizer)"],"type":"node"},": produces the outputted ",{"attributes":{},"tag":"code","children":["AbstractSystem"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["SciMLProblem"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["symbolic_discretize(sys,discretizer)"],"type":"node"},": produces a debugging symbolic description of the discretized problem."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Boundary Conditions (WIP)"],"type":"node"},{"attributes":{},"tag":"h2","children":["Transformations"],"type":"node"},{"attributes":{},"tag":"h2","children":["Analyses"],"type":"node"},{"attributes":{},"tag":"h2","children":["Discretizer Ecosystem"],"type":"node"},{"attributes":{},"tag":"h3","children":["NeuralPDE.jl: PhysicsInformedNN"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://github.com/SciML/NeuralPDE.jl","title":""},"tag":"a","children":["NeuralPDE.jl"],"type":"node"}," defines the ",{"attributes":{},"tag":"code","children":["PhysicsInformedNN"],"type":"node"}," discretizer which uses a ",{"attributes":{"href":"https://github.com/SciML/DiffEqFlux.jl","title":""},"tag":"a","children":["DiffEqFlux.jl"],"type":"node"}," neural network to solve the differential equation."],"type":"node"},{"attributes":{},"tag":"h3","children":["MethodOfLines.jl: MOLFiniteDifference (WIP)"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://github.com/SciML/MethodOfLines.jl","title":""},"tag":"a","children":["MethodOfLines.jl"],"type":"node"}," defines the ",{"attributes":{},"tag":"code","children":["MOLFiniteDifference"],"type":"node"}," discretizer which performs a finite difference discretization using the DiffEqOperators.jl stencils. These stencils make use of NNLib.jl for fast operations on semi-linear domains."],"type":"node"}],"type":"node"}],"type":"node"}