{"attributes":{"backlinks":[],"path":"/home/runner/.julia/packages/SciMLBase/dYFnI/docs/src/interfaces/Solutions.md","title":"SciMLSolutions"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["SciMLSolutions"],"type":"node"},{"attributes":{},"tag":"h2","children":["Definition of the SciMLSolution Interface"],"type":"node"},{"attributes":{},"tag":"p","children":["All ",{"attributes":{},"tag":"code","children":["SciMLSolution"],"type":"node"}," types are a subset of some ",{"attributes":{},"tag":"code","children":["AbstractArray"],"type":"node"},". Types with time series (like ",{"attributes":{},"tag":"code","children":["ODESolution"],"type":"node"},") are subtypes of ",{"attributes":{},"tag":"code","children":["RecursiveArrayTools.AbstractVectorOfArray"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["RecursiveArrayTools.AbstractDiffEqArray"],"type":"node"}," where appropriate. Types without a time series (like ",{"attributes":{},"tag":"code","children":["OptimizationSolution"],"type":"node"},") are directly subsets of ",{"attributes":{},"tag":"code","children":["AbstractArray"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h3","children":["Array Interface"],"type":"node"},{"attributes":{},"tag":"p","children":["Instead of working on the ",{"attributes":{},"tag":"code","children":["Vector{uType}"],"type":"node"}," directly, we can use the provided array interface."],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["sol"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["j"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["to access the value at timestep ",{"attributes":{},"tag":"code","children":["j"],"type":"node"}," (if the timeseries was saved), and"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"DOT","children":[{"attributes":{},"tag":"IDENTIFIER","children":["sol"],"type":"node"},{"attributes":{},"tag":"DOT","children":["."],"type":"node"},{"attributes":{},"tag":"QUOTE","children":[{"attributes":{},"tag":"IDENTIFIER","children":["t"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["j"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["to access the value of ",{"attributes":{},"tag":"code","children":["t"],"type":"node"}," at timestep ",{"attributes":{},"tag":"code","children":["j"],"type":"node"},". For multi-dimensional systems, this will address first by component and lastly by time, and thus"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["sol"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["i"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["j"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["will be the ",{"attributes":{},"tag":"code","children":["i"],"type":"node"},"th component at timestep ",{"attributes":{},"tag":"code","children":["j"],"type":"node"},". Hence, ",{"attributes":{},"tag":"code","children":["sol[j][i] == sol[i, j]"],"type":"node"},". This is done because Julia is column-major, so the leading dimension should be contiguous in memory. If the independent variables had shape (for example, was a matrix), then ",{"attributes":{},"tag":"code","children":["i"],"type":"node"}," is the linear index. We can also access solutions with shape:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["sol"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["i"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["k"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["j"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["gives the ",{"attributes":{},"tag":"code","children":["[i,k]"],"type":"node"}," component of the system at timestep ",{"attributes":{},"tag":"code","children":["j"],"type":"node"},". The colon operator is supported, meaning that"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["sol"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["i"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"COLON","children":[":"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["gives the timeseries for the ",{"attributes":{},"tag":"code","children":["i"],"type":"node"},"th component."],"type":"node"},{"attributes":{},"tag":"h3","children":["Common Field Names"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["u"],"type":"node"},": the solution values"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["t"],"type":"node"},": the independent variable values, matching the length of the solution, if applicable"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["resid"],"type":"node"},": the residual of the solution, if applicable"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["original"],"type":"node"},": the solution object from the original solver, if it's a wrapper algorithm"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["retcode"],"type":"node"},": see the documentation section on return codes"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["prob"],"type":"node"},": the problem that was solved"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["alg"],"type":"node"},": the algorithm used to solve the problem"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h3","children":["[Return Codes (RetCodes)](",{"attributes":{},"tag":"citation","children":[],"type":"node"}," retcodes)"],"type":"node"},{"attributes":{},"tag":"p","children":["The solution types have a ",{"attributes":{},"tag":"code","children":["retcode"],"type":"node"}," field which returns a symbol signifying the error state of the solution. The retcodes are as follows:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":[":Default"],"type":"node"},": The solver did not set retcodes."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":[":Success"],"type":"node"},": The integration completed without erroring or the steady state solver from ",{"attributes":{},"tag":"code","children":["SteadyStateDiffEq"],"type":"node"}," found the steady state."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":[":Terminated"],"type":"node"},": The integration is terminated with ",{"attributes":{},"tag":"code","children":["terminate!(integrator)"],"type":"node"},". Note that this may occur by using ",{"attributes":{},"tag":"code","children":["TerminateSteadyState"],"type":"node"}," from the callback library ",{"attributes":{},"tag":"code","children":["DiffEqCallbacks"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":[":MaxIters"],"type":"node"},": The integration exited early because it reached its maximum number of iterations."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":[":DtLessThanMin"],"type":"node"},": The timestep method chose a stepsize which is smaller than the allowed minimum timestep, and exited early."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":[":Unstable"],"type":"node"},": The solver detected that the solution was unstable and exited early."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":[":InitialFailure"],"type":"node"},": The DAE solver could not find consistent initial conditions."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":[":ConvergenceFailure"],"type":"node"},": The internal implicit solvers failed to converge."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":[":Failure"],"type":"node"},": General uncategorized failures or errors."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Traits"],"type":"node"},{"attributes":{},"tag":"h2","children":["SciMLSolution API"],"type":"node"},{"attributes":{},"tag":"h3","children":["Abstract SciML Solutions"],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["SciMLBase.SciMLSolution\nSciMLBase.AbstractNoTimeSolution\nSciMLBase.AbstractTimeseriesSolution\nSciMLBase.AbstractNoiseProcess\nSciMLBase.AbstractEnsembleSolution\nSciMLBase.AbstractLinearSolution\nSciMLBase.AbstractNonlinearSolution\nSciMLBase.AbstractQuadratureSolution\nSciMLBase.AbstractSteadyStateSolution\nSciMLBase.AbstractAnalyticalSolution\nSciMLBase.AbstractODESolution\nSciMLBase.AbstractDDESolution\nSciMLBase.AbstractRODESolution\nSciMLBase.AbstractDAESolution\n"],"type":"node"},{"attributes":{},"tag":"h3","children":["Concrete SciML Solutions"],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["SciMLBase.LinearSolution\nSciMLBase.QuadratureSolution\nSciMLBase.DAESolution\nSciMLBase.NonlinearSolution\nSciMLBase.ODESolution\nSciMLBase.OptimizationSolution\nSciMLBase.RODESolution\n"],"type":"node"}],"type":"node"}],"type":"node"}