{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/ExponentialUtilities/j8g4q/docs/src/expv.md","title":"Expv: Matrix Exponentials Times Vectors"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Expv: Matrix Exponentials Times Vectors"],"type":"node"},{"attributes":{},"tag":"p","children":["The main functionality of ExponentialUtilities is the computation of matrix-phi-vector products. The phi functions are defined as"],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["ϕ_0(z) = exp(z)\nϕ_(k+1)(z) = (ϕ_k(z) - 1) / z\n"],"type":"node"},{"attributes":{},"tag":"p","children":["In exponential algorithms, products in the form of ",{"attributes":{},"tag":"code","children":["ϕ_m(tA)b"],"type":"node"}," is frequently encountered. Instead of computing the matrix function first and then computing the matrix-vector product, the common alternative is to construct a ",{"attributes":{"href":"https://en.wikipedia.org/wiki/Krylov_subspace","title":""},"tag":"a","children":["Krylov subspace"],"type":"node"}," ",{"attributes":{},"tag":"code","children":["K_m(A,b)"],"type":"node"}," and then approximate the matrix-phi-vector product."],"type":"node"},{"attributes":{},"tag":"h3","children":["Support for matrix-free operators"],"type":"node"},{"attributes":{},"tag":"p","children":["You can use any object as the \"matrix\" ",{"attributes":{},"tag":"code","children":["A"],"type":"node"}," as long as it implements the following linear operator interface:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["Base.eltype(A)"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["Base.size(A, dim)"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["LinearAlgebra.mul!(y, A, x)"],"type":"node"}," (for computing ",{"attributes":{},"tag":"code","children":["y = A * x"],"type":"node"}," in place)."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["LinearAlgebra.opnorm(A, p=Inf)"],"type":"node"},". If this is not implemented or the default implementation can be slow, you can manually pass in the operator norm (a rough estimate is fine) using the keyword argument ",{"attributes":{},"tag":"code","children":["opnorm"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["LinearAlgebra.ishermitian(A)"],"type":"node"},". If this is not implemented or the default implementation can be slow, you can manually pass in the value using the keyword argument ",{"attributes":{},"tag":"code","children":["ishermitian"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Core API"],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["expv\nphiv\nexpv!\nphiv!\nexp_timestep\nphiv_timestep\nexp_timestep!\nphiv_timestep!\nphi\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["Caches"],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["ExpvCache\nPhivCache\n"],"type":"node"}],"type":"node"}],"type":"node"}