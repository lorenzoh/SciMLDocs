{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/PolyChaos/THVqe/docs/src/numerical_integration.md","title":"[Numerical Integration]( NumericalIntegration)"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["[Numerical Integration](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," NumericalIntegration)"],"type":"node"},{"attributes":{},"tag":"p","children":["The goal of this tutorial is to solve an integral using Gauss quadrature,"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["I := \\int_{0}^{1} f(t) \\mathrm{d} t \\approx \\sum_{k=1}^n w_k f(t_k),"],"type":"node"},{"attributes":{},"tag":"p","children":["where we choose ",{"attributes":{},"tag":"math","children":["f(t) = \\sin(t)"],"type":"node"},", and ",{"attributes":{},"tag":"math","children":["n = 5"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["Make sure to check out [this tutorial](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," QuadratureRules) too."],"type":"node"},{"attributes":{},"tag":"h3","children":["Variant 0"],"type":"node"},{"attributes":{"lang":"jldoctest mylabel"},"tag":"codeblock","children":["julia> using PolyChaos\n\njulia> n = 5;\n\njulia> f(t) = sin(t);\n\njulia> op = Uniform01OrthoPoly(n, addQuadrature=true);\n\njulia> variant0 = integrate(f, op)\n0.4596976941320484\n\njulia> print(\"Numerical error: $(abs(1 - cos(1) - variant0))\")\nNumerical error: 1.8868240303504535e-13\n"],"type":"node"},{"attributes":{},"tag":"p","children":["with negligible numerical errors."],"type":"node"},{"attributes":{},"tag":"h3","children":["Variant 1"],"type":"node"},{"attributes":{},"tag":"p","children":["Let us  now solve the same problem, while elaborating what is going on under the hood. At first, we load the package by calling"],"type":"node"},{"attributes":{"lang":"@repl"},"tag":"codeblock","children":["using PolyChaos\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Now we define a measure, specifically the uniform measure ",{"attributes":{},"tag":"math","children":["\\mathrm{d}\\lambda(t) = w(t) \\mathrm{d} t"],"type":"node"}," with the weight ",{"attributes":{},"tag":"math","children":["w"],"type":"node"}," defined as"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["  w: \\mathcal{W} = [0,1] \\rightarrow \\mathbb{R}, \\quad w(t) = 1."],"type":"node"},{"attributes":{},"tag":"p","children":["This measure can be defined using the composite type ",{"attributes":{},"tag":"code","children":["Uniform01Measure"],"type":"node"},":"],"type":"node"},{"attributes":{"lang":"jldoctest mylabel"},"tag":"codeblock","children":["julia> measure = Uniform01Measure()\nUniform01Measure(PolyChaos.w_uniform01, (0.0, 1.0), true)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Next, we need to compute the quadrature rule relative to the uniform measure. To do this we use the composite type ",{"attributes":{},"tag":"code","children":["Quad"],"type":"node"},"."],"type":"node"},{"attributes":{"lang":"jldoctest mylabel"},"tag":"codeblock","children":["julia> quadRule1 = Quad(n-1, measure)\n┌ Warning: For measures of type Uniform01Measure the quadrature rule should be based on the recurrence coefficients.\n└ @ PolyChaos ~/Documents/Code/JuliaDev/PolyChaos/src/typesQuad.jl:58\nQuad{Float64,Array{Float64,1}}(\"quadgp\", 4, [1.0, 0.8535533905932737, 0.5, 0.14644660940672627, 0.0], [0.033333333333333354, 0.26666666666666666, 0.4, 0.26666666666666666, 0.033333333333333354])\n\njulia> nw(quadRule1)\n5×2 Array{Float64,2}:\n 1.0       0.0333333\n 0.853553  0.266667 \n 0.5       0.4      \n 0.146447  0.266667 \n 0.0       0.0333333\n"],"type":"node"},{"attributes":{},"tag":"p","children":["This creates a quadrature rule ",{"attributes":{},"tag":"code","children":["quadRule_1"],"type":"node"}," relative to the measure ",{"attributes":{},"tag":"code","children":["measure"],"type":"node"},". The function ",{"attributes":{},"tag":"code","children":["nw()"],"type":"node"}," prints the nodes and weights. To solve the integral we call ",{"attributes":{},"tag":"code","children":["integrate()"],"type":"node"}],"type":"node"},{"attributes":{"lang":"jldoctest mylabel"},"tag":"codeblock","children":["julia> variant1 = integrate(f, quadRule1)\n0.4596977927043755\n\njulia> print(\"Numerical error: $(abs(1 - cos(1) - variant1))\")\nNumerical error: 9.857251526135258e-8\n"],"type":"node"},{"attributes":{},"tag":"h3","children":["Revisiting Variant 0"],"type":"node"},{"attributes":{},"tag":"p","children":["Why is the error from variant 0 so much smaller? It's because the quadrature rule for variant 0 is based on the recurrence coefficients of the polynomials that are orthogonal relative to the measure ",{"attributes":{},"tag":"code","children":["measure"],"type":"node"},". Let's take a closer look First, we compute the orthogonal polynomials using the composite type ",{"attributes":{},"tag":"code","children":["OrthoPoly"],"type":"node"},", and we set the keyword ",{"attributes":{},"tag":"code","children":["addQuadrature"],"type":"node"}," to ",{"attributes":{},"tag":"code","children":["false"],"type":"node"},"."],"type":"node"},{"attributes":{"lang":"jldoctest mylabel"},"tag":"codeblock","children":["julia> op = Uniform01OrthoPoly(n, addQuadrature=false)\nUniform01OrthoPoly{Array{Float64,1},Uniform01Measure,EmptyQuad{Float64}}(5, [0.5, 0.5, 0.5, 0.5, 0.5, 0.5], [1.0, 0.08333333333333333, 0.06666666666666667, 0.06428571428571428, 0.06349206349206349, 0.06313131313131314], Uniform01Measure(PolyChaos.w_uniform01, (0.0, 1.0), true), EmptyQuad{Float64}())\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Note how ",{"attributes":{},"tag":"code","children":["op"],"type":"node"}," has a field ",{"attributes":{},"tag":"code","children":["EmptyQuad"],"type":"node"},", i.e. we computed no quadrature rule. The resulting system of orthogonal polynomials is characterized by its recursion coefficients ",{"attributes":{},"tag":"math","children":["(\\alpha, \\beta)"],"type":"node"},", which can be extracted with the function ",{"attributes":{},"tag":"code","children":["coeffs()"],"type":"node"},"."],"type":"node"},{"attributes":{"lang":"jldoctest mylabel"},"tag":"codeblock","children":["julia> coeffs(op)\n6×2 Array{Float64,2}:\n 0.5  1.0      \n 0.5  0.0833333\n 0.5  0.0666667\n 0.5  0.0642857\n 0.5  0.0634921\n 0.5  0.0631313\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Now, the quadrature rule can be constructed based on ",{"attributes":{},"tag":"code","children":["op"],"type":"node"},", and the integral be solved."],"type":"node"},{"attributes":{"lang":"jldoctest mylabel"},"tag":"codeblock","children":["julia> quadRule2 = Quad(n, op)\nQuad{Float64,Array{Float64,1}}(\"golubwelsch\", 5, [0.046910077030667935, 0.23076534494715842, 0.49999999999999994, 0.7692346550528418, 0.9530899229693321], [0.11846344252809445, 0.23931433524968332, 0.28444444444444444, 0.23931433524968337, 0.1184634425280949])\n\njulia> nw(quadRule2)\n5×2 Array{Float64,2}:\n 0.0469101  0.118463\n 0.230765   0.239314\n 0.5        0.284444\n 0.769235   0.239314\n 0.95309    0.118463\n\njulia> variant0_revisited = integrate(f, quadRule2)\n0.4596976941320484\n\njulia> print(\"Numerical error: $(abs(1 - cos(1) - variant0_revisited))\")\nNumerical error: 1.8818280267396403e-13\n"],"type":"node"},{"attributes":{},"tag":"h3","children":["Comparison"],"type":"node"},{"attributes":{},"tag":"p","children":["We see that the different variants provide slightly different results:"],"type":"node"},{"attributes":{"lang":"jldoctest mylabel"},"tag":"codeblock","children":["julia> 1-cos(1) .- [variant0 variant1 variant0_revisited]\n1×3 Array{Float64,2}:\n -1.88183e-13  -9.85725e-8  -1.88183e-13\n"],"type":"node"},{"attributes":{},"tag":"p","children":["with ",{"attributes":{},"tag":"code","children":["variant0"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["variant0_revisited"],"type":"node"}," being the same and more accurate than ",{"attributes":{},"tag":"code","children":["variant1"],"type":"node"},". The increased accuracy is based on the fact that for ",{"attributes":{},"tag":"code","children":["variant0"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["variant0_revisited"],"type":"node"}," the quadrature rules are based on the recursion coefficients of the underlying orthogonal polynomials. The quadrature for ",{"attributes":{},"tag":"code","children":["variant1"],"type":"node"}," is based on an general-purpose method that can be significantly less accurate, see also [the next tutorial](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," QuadratureRules)."],"type":"node"}],"type":"node"}],"type":"node"}