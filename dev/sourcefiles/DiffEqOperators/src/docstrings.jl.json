{"attributes":{"module":"DiffEqOperators","backlinks":[],"path":"/Users/lorenz/.julia/packages/DiffEqOperators/NWEwW/src/docstrings.jl","title":"DiffEqOperators/src/docstrings.jl"},"tag":"sourcefile","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"MACROCALL","children":[{"attributes":{},"tag":"AT_SIGN","children":["@"],"type":"node"},{"attributes":{},"tag":"MACRO_NAME","children":["doc"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"STRING_INTERP","children":[{"attributes":{},"tag":"TRIPLE_DQUOTE","children":["\"\"\""],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["    CenteredDifference{N}(n, order, step, len, [coeff_func])\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["    CenteredDifference{N}(n, order, steps, len, [coeff_func])\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["See also: [`UpwindDifference`](@ref)\n"],"type":"node"},{"attributes":{},"tag":"TRIPLE_DQUOTE","children":["\"\"\""],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.CenteredDifference"},"tag":"reference","children":["CenteredDifference"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"MACROCALL","children":[{"attributes":{},"tag":"AT_SIGN","children":["@"],"type":"node"},{"attributes":{},"tag":"MACRO_NAME","children":["doc"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"STRING_INTERP","children":[{"attributes":{},"tag":"TRIPLE_DQUOTE","children":["\"\"\""],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["    calculate_weights(n::Int, x₀::Real, x::Vector)\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["Return a vector `c` such that `c⋅f.(x)` approximates ``f^{(n)}(x₀)`` for a smooth `f`.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["The points `x` need not be evenly spaced.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["The stencil `c` has the highest approximation order possible given values of `f` at `length(x)` points. More precisely, if `x` has length `m`, there is a function `g` such that ``g(y) = f(y) + O(y-x₀)^{m-n+?}`` and ``c⋅f.(x) = g'(x₀)``.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["The algorithm is due to [Fornberg](https://doi.org/10.1090/S0025-5718-1988-0935077-0), with a [modification](http://epubs.siam.org/doi/pdf/10.1137/S0036144596322507) to improve stability.\n"],"type":"node"},{"attributes":{},"tag":"TRIPLE_DQUOTE","children":["\"\"\""],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.calculate_weights"},"tag":"reference","children":["calculate_weights"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"MACROCALL","children":[{"attributes":{},"tag":"AT_SIGN","children":["@"],"type":"node"},{"attributes":{},"tag":"MACRO_NAME","children":["doc"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"STRING_INTERP","children":[{"attributes":{},"tag":"TRIPLE_DQUOTE","children":["\"\"\""],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["    DerivativeOperator{T<:Real,N,Wind,T2,S1,S2<:SVector,T3,F}(<fields>)\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["Represent a finite-difference derivative operator.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["These operators implement the `DiffEqBase.AbstractDiffEqLinearOperator` interface. Therefore, `eltype` returns `T`.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["These operators can be contracted over an arbitrary dimension, given by the type parameter `N`.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["The `CentredDifference` and `UpwindDifference` types serve as hooks to hang constructors, but no objects are actually constructed with those types. Their constructors return structures of type `DerivativeOperator`, with stencils constructed by `calculate_weights`, and other fields filled out appropriately.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["The finite-difference methods are defined for `DerivativeOperator`. In particular, `*`, which actually takes derivatives.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["The key data are three stencils of coefficients, stored in `SVector`s. The interior stencil, stored in `stencil_coefs::S1`, is the normal one used in the interior of the grid. The others, `low_boundary_coefs::S2` and `high_boundary_coefs::S2`, are used where the normal stencil would jut out of the grid boundary. These can have a different length than the interior stencil, hence the two types.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["When the operator is applied by `mul!`, these stencils are multiplied by the vector in the `coefficients` field. It is set to `coeff_func.(1:len)` in `UpwindDifference`, which seems odd, because `len` is not the stencil length. Scalar multiplication is absorbed into this vector, as required by the `DiffEqBase.AbstractDiffEqLinearOperator` interface.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["The `coefficients` field appears to be a more general `DifferentialEquations` thing. There is an `update_coefficients!` method.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["The term “left boundary” is used interchangeably with “low boundary”, and “right” with “high”.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["# Type Parameters\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["Presumably, most of these are to force method specialization on:a) the stencil lengths, which are given by the parameters of the `SVector` types `S1` and `S2`, and b) even or arbitrary grid spacing.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `T<:Real`: Function range type.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `N`: Contraction dimension.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `Wind`: Flag `true` for upwind operators, `false` for centered.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `T2`: Concrete type of `dx` field, which might be `T` or `AbstractVector{T}`.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `S1`: Concrete type of the interior stencil. (When is this not an `SVector`?)\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `S2<:SVector`: Concrete type of boundary coefficients.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `T3`: `Vector{T}` if a `coeff_func` was supplied, `Nothing` otherwise.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `F`: `typeof(coeff_func)` if a `coeff_func` was supplied, `Nothing` otherwise.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["# Fields\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `derivative_order::Int`: The `n` in `f⁽ⁿ⁾(x)`.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `approximation_order::Int`: The degree of polynomial for which the operator is numerically exact.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `dx::T2`: Grid step.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `len::Int`: The number of interior points on the grid.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `stencil_length::Int`: Length of the interior stencil.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `stencil_coefs::S1`: An `SVector` of the interior stencil coefficients.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `boundary_stencil_length::Int`:\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `boundary_point_count::Int`:\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `low_boundary_coefs::S2`: An array of `SVector` stencils for the interior points where `stencil_coefs` juts over the left boundary.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `high_boundary_coefs::S2`: An array of `SVector` stencils for the interior points where `stencil_coefs` juts over the right boundary.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `coefficients::T3`: Multiplier for the stencil.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `coeff_func::F`: God only knows what this function is for.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["See also: [`AbstractBC`](@ref), [`CenteredDifference`](@ref), [`UpwindDifference`](@ref)\n"],"type":"node"},{"attributes":{},"tag":"TRIPLE_DQUOTE","children":["\"\"\""],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.DerivativeOperator"},"tag":"reference","children":["DerivativeOperator"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"MACROCALL","children":[{"attributes":{},"tag":"AT_SIGN","children":["@"],"type":"node"},{"attributes":{},"tag":"MACRO_NAME","children":["doc"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"STRING_INTERP","children":[{"attributes":{},"tag":"TRIPLE_DQUOTE","children":["\"\"\""],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["    abstract type AbstractBC{T}\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["`T` is the range type of the discretized function.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["Boundary condition operators extrapolate the discretized function\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["as illustrated in the README, adding a ghost node at each end such\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["that an interpolated polynomial satisfies the boundary condition.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["Some of these are affine operators with a constant term, not linear\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["operators, so using `*` and `\\\\` is a minor abuse of notation. For example,\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["when there is a non-zero Dirichlet boundary value, the value at the\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["ghost node is constant, and does not scale proportional to the\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["interior function values. Because boundary condition operators are\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["not linear, they can not be concretized as matrices.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["`GhostDerivativeOperator` somehow concretizes as a pair of matrices.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["The implementation of `*(::AffineBC, ::Vector)` returns a\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["`BoundaryPaddedVector`. This is a structure that stores the ghost\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["values separately from the original vector. Presumably, this is to\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["avoid allocations, although the `mul!` method for `GhostDerivativeOperator`\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["and `Matrix` method allocates a new `BoundaryPaddedArray` for each\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["column.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["In higher-dimensional cases, it might return a\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["`BoundaryPaddedArray`.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["The `*` operator for a derivative multiplying a boundary condition\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["packages them up as a `GhostDerivativeOperator`. This cannot\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["return a sparse matrix, because the operator is affine (not linear).\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["When a vector is multiplied by one of those, it uses `*(::AbstractBC,\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["::AbstractVector)` to pad with ghost nodes, then\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["`mul!(::DerivativeOperator, ::AbstractVector)` evaluates the\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["derivative.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["See also: [`DerivativeOperator`](@ref), [`PeriodicBC`](@ref) [`NeumannBC`](@ref), [`DirichletBC`](@ref), [`RobinBC`](@ref).\n"],"type":"node"},{"attributes":{},"tag":"TRIPLE_DQUOTE","children":["\"\"\""],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.AbstractBC"},"tag":"reference","children":["AbstractBC"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"MACROCALL","children":[{"attributes":{},"tag":"AT_SIGN","children":["@"],"type":"node"},{"attributes":{},"tag":"MACRO_NAME","children":["doc"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"STRING_INTERP","children":[{"attributes":{},"tag":"TRIPLE_DQUOTE","children":["\"\"\""],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["    PeriodicBC{T}()\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["q = PeriodicBC{T}()\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["Qx, Qy, ... = PeriodicBC{T}(size(u)) #When all dimensions are to be extended with\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["a periodic boundary condition.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["Creates a periodic boundary condition, where the lower index end of some u is extended\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["with the upper index end and vice versa. It is not recommended to concretize this BC\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["type in to a BandedMatrix, since the vast majority of bands will be all 0s.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["SparseMatrix concretization is recommended.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["Currently, periodic boundary conditions are only implemented in one\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["dimension.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["# Type parameters\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["- `T` is the domain type of the discretized function.\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["\n"],"type":"node"},{"attributes":{},"tag":"STRING","children":["See also: [`AbstractBC`](@ref)\n"],"type":"node"},{"attributes":{},"tag":"TRIPLE_DQUOTE","children":["\"\"\""],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.PeriodicBC"},"tag":"reference","children":["PeriodicBC"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.RobinBC"},"tag":"reference","children":["RobinBC"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"MACROCALL","children":[{"attributes":{},"tag":"AT_SIGN","children":["@"],"type":"node"},{"attributes":{},"tag":"MACRO_NAME","children":["doc"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"MACROCALL","children":[{"attributes":{},"tag":"AT_SIGN","children":["@"],"type":"node"},{"attributes":{},"tag":"MACRO_NAME","children":["doc"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.RobinBC"},"tag":"reference","children":["RobinBC"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.NeumannBC"},"tag":"reference","children":["NeumannBC"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"MACROCALL","children":[{"attributes":{},"tag":"AT_SIGN","children":["@"],"type":"node"},{"attributes":{},"tag":"MACRO_NAME","children":["doc"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"MACROCALL","children":[{"attributes":{},"tag":"AT_SIGN","children":["@"],"type":"node"},{"attributes":{},"tag":"MACRO_NAME","children":["doc"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.RobinBC"},"tag":"reference","children":["RobinBC"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.Neumann0BC"},"tag":"reference","children":["Neumann0BC"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"MACROCALL","children":[{"attributes":{},"tag":"AT_SIGN","children":["@"],"type":"node"},{"attributes":{},"tag":"MACRO_NAME","children":["doc"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"MACROCALL","children":[{"attributes":{},"tag":"AT_SIGN","children":["@"],"type":"node"},{"attributes":{},"tag":"MACRO_NAME","children":["doc"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.RobinBC"},"tag":"reference","children":["RobinBC"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.DirichletBC"},"tag":"reference","children":["DirichletBC"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"MACROCALL","children":[{"attributes":{},"tag":"AT_SIGN","children":["@"],"type":"node"},{"attributes":{},"tag":"MACRO_NAME","children":["doc"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"MACROCALL","children":[{"attributes":{},"tag":"AT_SIGN","children":["@"],"type":"node"},{"attributes":{},"tag":"MACRO_NAME","children":["doc"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.RobinBC"},"tag":"reference","children":["RobinBC"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/DiffEqOperators.Dirichlet0BC"},"tag":"reference","children":["Dirichlet0BC"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}