{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/SciMLOperators/zadvX/docs/src/interface.md","title":"The AbstractSciMLOperator Interface"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["The AbstractSciMLOperator Interface"],"type":"node"},{"attributes":{},"tag":"h2","children":["Formal Properties of DiffEqOperators"],"type":"node"},{"attributes":{},"tag":"p","children":["These are the formal properties that an ",{"attributes":{},"tag":"code","children":["AbstractSciMLOperator"],"type":"node"}," should obey for it to work in the solvers."],"type":"node"},{"attributes":{},"tag":"h2","children":["AbstractDiffEqOperator Interface Description"],"type":"node"},{"attributes":{},"tag":"ol","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Function call and multiplication: ",{"attributes":{},"tag":"code","children":["L(du,u,p,t)"],"type":"node"}," for inplace and ",{"attributes":{},"tag":"code","children":["du = L(u,p,t)"],"type":"node"}," for out-of-place, meaning ",{"attributes":{},"tag":"code","children":["L*u"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["mul!"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If the operator is not a constant, update it with ",{"attributes":{},"tag":"code","children":["(u,p,t)"],"type":"node"},". A mutating form, i.e. ",{"attributes":{},"tag":"code","children":["update_coefficients!(A,u,p,t)"],"type":"node"}," that changes the internal coefficients, and a out-of-place form ",{"attributes":{},"tag":"code","children":["B = update_coefficients(A,u,p,t)"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["isconstant(A)"],"type":"node"}," trait for whether the operator is constant or not."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["AbstractDiffEqLinearOperator Interface Description"],"type":"node"},{"attributes":{},"tag":"ol","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["AbstractSciMLLinearOperator <: AbstractSciMLOperator"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Can absorb under multiplication by a scalar. In all algorithms things like ",{"attributes":{},"tag":"code","children":["dt*L"],"type":"node"}," show up all the time, so the linear operator must be able to absorb such constants."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["isconstant(A)"],"type":"node"}," trait for whether the operator is constant or not."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Optional: ",{"attributes":{},"tag":"code","children":["diagonal"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["symmetric"],"type":"node"},", etc traits from LinearMaps.jl."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Optional: ",{"attributes":{},"tag":"code","children":["exp(A)"],"type":"node"},". Required for simple exponential integration."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Optional: ",{"attributes":{},"tag":"code","children":["expv(A,u,t) = exp(t*A)*u"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["expv!(v,A::AbstractSciMLOperator,u,t)"],"type":"node"}," Required for sparse-saving exponential integration."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Optional: factorizations. ",{"attributes":{},"tag":"code","children":["ldiv!"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["factorize"],"type":"node"}," et. al. This is only required for algorithms which use the factorization of the operator (Crank-Nicolson), and only for when the default linear solve is used."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Note About Affine Operators"],"type":"node"},{"attributes":{},"tag":"p","children":["Affine operators are operators which have the action ",{"attributes":{},"tag":"code","children":["Q*x = A*x + b"],"type":"node"},". These operators have no matrix representation, since if there was it would be a linear operator instead of an affine operator. You can only represent an affine operator as a linear operator in a dimension of one larger via the operation: ",{"attributes":{},"tag":"code","children":["[A b] * [u;1]"],"type":"node"},", so it would require something modified to the input as well. As such, affine operators are a distinct generalization of linear operators."],"type":"node"},{"attributes":{},"tag":"p","children":["While it this seems like it might doom the idea of using matrix-free affine operators, it turns out that affine operators can be used in all cases where matrix-free linear solvers are used due to an easy genearlization of the standard convergence proofs. If Q is the affine operator ",{"attributes":{},"tag":"math","children":["Q(x) = Ax + b"],"type":"node"},", then solving ",{"attributes":{},"tag":"math","children":["Qx = c"],"type":"node"}," is equivalent to solving ",{"attributes":{},"tag":"math","children":["Ax + b = c"],"type":"node"}," or ",{"attributes":{},"tag":"math","children":["Ax = c-b"],"type":"node"},". If you know do this same \"plug-and-chug\" handling of the affine operator in into the GMRES/CG/etc. convergence proofs, move the affine part to the rhs residual, and show it converges to solving ",{"attributes":{},"tag":"math","children":["Ax = c-b"],"type":"node"},", and thus GMRES/CG/etc. solves ",{"attributes":{},"tag":"math","children":["Q(x) = c"],"type":"node"}," for an affine operator properly."],"type":"node"},{"attributes":{},"tag":"p","children":["That same trick then can be used pretty much anywhere you would've had a linear operator to extend the proof to affine operators, so then ",{"attributes":{},"tag":"math","children":["exp(A*t)*v"],"type":"node"}," operations via Krylov methods work for A being affine as well, and all sorts of things. Thus affine operators have no matrix representation but they are still compatible with essentially any Krylov method which would otherwise be compatible with matrix-free representations, hence their support in the SciMLOperators interface."],"type":"node"}],"type":"node"}],"type":"node"}