{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/DiffEqSensitivity/GjhZ8/docs/src/sensitivity_math.md","title":"[Mathematics of Sensitivity Analysis]( sensitivity_math)"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["[Mathematics of Sensitivity Analysis](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," sensitivity_math)"],"type":"node"},{"attributes":{},"tag":"h2","children":["Forward Sensitivity Analysis"],"type":"node"},{"attributes":{},"tag":"p","children":["The local sensitivity is computed using the sensitivity ODE:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\frac{d}{dt}\\frac{\\partial u}{\\partial p_{j}}=\\frac{\\partial f}{\\partial u}\\frac{\\partial u}{\\partial p_{j}}+\\frac{\\partial f}{\\partial p_{j}}=J\\cdot S_{j}+F_{j}"],"type":"node"},{"attributes":{},"tag":"p","children":["where"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["J=\\left(\\begin{array}{cccc}\n\\frac{\\partial f_{1}}{\\partial u_{1}} & \\frac{\\partial f_{1}}{\\partial u_{2}} & \\cdots & \\frac{\\partial f_{1}}{\\partial u_{k}}\\\\\n\\frac{\\partial f_{2}}{\\partial u_{1}} & \\frac{\\partial f_{2}}{\\partial u_{2}} & \\cdots & \\frac{\\partial f_{2}}{\\partial u_{k}}\\\\\n\\cdots & \\cdots & \\cdots & \\cdots\\\\\n\\frac{\\partial f_{k}}{\\partial u_{1}} & \\frac{\\partial f_{k}}{\\partial u_{2}} & \\cdots & \\frac{\\partial f_{k}}{\\partial u_{k}}\n\\end{array}\\right)"],"type":"node"},{"attributes":{},"tag":"p","children":["is the Jacobian of the system,"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["F_{j}=\\left(\\begin{array}{c}\n\\frac{\\partial f_{1}}{\\partial p_{j}}\\\\\n\\frac{\\partial f_{2}}{\\partial p_{j}}\\\\\n\\vdots\\\\\n\\frac{\\partial f_{k}}{\\partial p_{j}}\n\\end{array}\\right)"],"type":"node"},{"attributes":{},"tag":"p","children":["are the parameter derivatives, and"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["S_{j}=\\left(\\begin{array}{c}\n\\frac{\\partial u_{1}}{\\partial p_{j}}\\\\\n\\frac{\\partial u_{2}}{\\partial p_{j}}\\\\\n\\vdots\\\\\n\\frac{\\partial u_{k}}{\\partial p_{j}}\n\\end{array}\\right)"],"type":"node"},{"attributes":{},"tag":"p","children":["is the vector of sensitivities. Since this ODE is dependent on the values of the independent variables themselves, this ODE is computed simultaneously with the actual ODE system."],"type":"node"},{"attributes":{},"tag":"p","children":["Note that the Jacobian-vector product"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\frac{\\partial f}{\\partial u}\\frac{\\partial u}{\\partial p_{j}}"],"type":"node"},{"attributes":{},"tag":"p","children":["can be computed without forming the Jacobian. With finite differences, this through using the following formula for the directional derivative"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["Jv \\approx \\frac{f(x+v \\epsilon) - f(x)}{\\epsilon},"],"type":"node"},{"attributes":{},"tag":"p","children":["or, alternatively and without truncation error, by using a dual number with a single partial dimension, ",{"attributes":{},"tag":"math","children":["d = x + v \\epsilon"],"type":"node"}," we get that"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["f(d) = f(x) + Jv \\epsilon"],"type":"node"},{"attributes":{},"tag":"p","children":["as a fast way to calcuate ",{"attributes":{},"tag":"math","children":["Jv"],"type":"node"},". Thus, except when a sufficiently good function for ",{"attributes":{},"tag":"code","children":["J"],"type":"node"}," is given by the user, the Jacobian is never formed. For more details, consult the ",{"attributes":{"href":"https://mitmath.github.io/18337/lecture8/automatic_differentiation.html","title":""},"tag":"a","children":["MIT 18.337 lecture notes on forward mode AD"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h2","children":["Adjoint Sensitivity Analysis"],"type":"node"},{"attributes":{},"tag":"p","children":["This adjoint requires the definition of some scalar functional ",{"attributes":{},"tag":"math","children":["g(u,p)"],"type":"node"}," where ",{"attributes":{},"tag":"math","children":["u(t,p)"],"type":"node"}," is the (numerical) solution to the differential equation ",{"attributes":{},"tag":"math","children":["d/dt u(t,p)=f(t,u,p)"],"type":"node"}," with ",{"attributes":{},"tag":"math","children":["t\\in [0,T]"],"type":"node"}," and ",{"attributes":{},"tag":"math","children":["u(t_0,p)=u_0"],"type":"node"},". Adjoint sensitivity analysis finds the gradient of"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["G(u,p)=G(u(\\cdot,p))=\\int_{t_{0}}^{T}g(u(t,p),p)dt"],"type":"node"},{"attributes":{},"tag":"p","children":["some integral of the solution. It does so by solving the adjoint problem"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\frac{d\\lambda^{\\star}}{dt}=g_{u}(u(t,p),p)-\\lambda^{\\star}(t)f_{u}(t,u(t,p),p),\\thinspace\\thinspace\\thinspace\\lambda^{\\star}(T)=0"],"type":"node"},{"attributes":{},"tag":"p","children":["where ",{"attributes":{},"tag":"math","children":["f_u"],"type":"node"}," is the Jacobian of the system with respect to the state ",{"attributes":{},"tag":"math","children":["u"],"type":"node"}," while ",{"attributes":{},"tag":"math","children":["f_p"],"type":"node"}," is the Jacobian with respect to the parameters. The adjoint problem's solution gives the sensitivities through the integral:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\frac{dG}{dp}=\\int_{t_{0}}^{T}\\lambda^{\\star}(t)f_{p}(t)+g_{p}(t)dt+\\lambda^{\\star}(t_{0})u_{p}(t_{0})"],"type":"node"},{"attributes":{},"tag":"p","children":["Notice that since the adjoints require the Jacobian of the system at the state, it requires the ability to evaluate the state at any point in time. Thus it requires the continuous forward solution in order to solve the adjoint solution, and the adjoint solution is required to be continuous in order to calculate the resulting integral."],"type":"node"},{"attributes":{},"tag":"p","children":["There is one extra detail to consider. In many cases we would like to calculate the adjoint sensitivity of some discontinuous functional of the solution. One canonical function is the L2 loss against some data points, that is:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["L(u,p)=\\sum_{i=1}^{n}\\Vert\\tilde{u}(t_{i})-u(t_{i},p)\\Vert^{2}"],"type":"node"},{"attributes":{},"tag":"p","children":["In this case, we can reinterpret our summation as the distribution integral:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["G(u,p)=\\int_{0}^{T}\\sum_{i=1}^{n}\\Vert\\tilde{u}(t_{i})-u(t_{i},p)\\Vert^{2}\\delta(t_{i}-t)dt"],"type":"node"},{"attributes":{},"tag":"p","children":["where ",{"attributes":{},"tag":"math","children":["Î´"],"type":"node"}," is the Dirac distribution. In this case, the integral is continuous except at finitely many points. Thus it can be calculated between each ",{"attributes":{},"tag":"math","children":["t_i"],"type":"node"},". At a given ",{"attributes":{},"tag":"math","children":["t_i"],"type":"node"},", given that the ",{"attributes":{},"tag":"math","children":["t_i"],"type":"node"}," are unique, we have that"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["g_{u}(t_{i})=2\\left(\\tilde{u}(t_{i})-u(t_{i},p)\\right)"],"type":"node"},{"attributes":{},"tag":"p","children":["Thus the adjoint solution ",{"attributes":{},"tag":"math","children":["\\lambda^{\\star}(t)"],"type":"node"}," is given by integrating between the integrals and applying the jump function ",{"attributes":{},"tag":"math","children":["g_u"],"type":"node"}," at every data point ",{"attributes":{},"tag":"math","children":["t_i"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["We note that"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\lambda^{\\star}(t)f_{u}(t)"],"type":"node"},{"attributes":{},"tag":"p","children":["is a vector-transpose Jacobian product, also known as a ",{"attributes":{},"tag":"code","children":["vjp"],"type":"node"},", which can be efficiently computed using the pullback of backpropogation on the user function ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," with a forward pass at ",{"attributes":{},"tag":"code","children":["u"],"type":"node"}," with a pullback vector ",{"attributes":{},"tag":"math","children":["\\lambda^{\\star}"],"type":"node"},". For more information, consult the ",{"attributes":{"href":"https://mitmath.github.io/18337/lecture10/estimation_identification","title":""},"tag":"a","children":["MIT 18.337 lecture notes on reverse mode AD"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}