{"attributes":{"kind":"function","backlinks":[{"tag":"sourcefile","title":"NeuralPDE/src/rode_solve.jl","docid":"sourcefiles/NeuralPDE/src/rode_solve.jl"},{"tag":"sourcefile","title":"NeuralPDE/src/param_kolmogorov_solve.jl","docid":"sourcefiles/NeuralPDE/src/param_kolmogorov_solve.jl"},{"tag":"document","title":"Solving Kolmogorov Equations with Neural Networks","docid":"NeuralPDE/examples/kolmogorovbackwards.md"},{"tag":"sourcefile","title":"NeuralPDE/src/ode_solve.jl","docid":"sourcefiles/NeuralPDE/src/ode_solve.jl"},{"tag":"document","title":"Integro Differential Equations","docid":"NeuralPDE/pinn/integro_diff.md"},{"tag":"document","title":"1D Wave Equation with Dirichlet boundary conditions","docid":"NeuralPDE/pinn/wave.md"},{"tag":"document","title":"2-dimensional PDEs with GPU","docid":"NeuralPDE/pinn/2D.md"},{"tag":"sourcefile","title":"PolyChaos/src/recurrence_coefficients_monic.jl","docid":"sourcefiles/PolyChaos/src/recurrence_coefficients_monic.jl"},{"tag":"document","title":"Physics-Informed Neural Networks","docid":"NeuralPDE/solvers/pinns.md"},{"tag":"document","title":"ODE with a 3rd-Order Derivative","docid":"NeuralPDE/pinn/3rd.md"},{"tag":"sourcefile","title":"GlobalSensitivity/src/eFAST_sensitivity.jl","docid":"sourcefiles/GlobalSensitivity/src/eFAST_sensitivity.jl"},{"tag":"document","title":"Controlling Stochastic Differential Equations","docid":"DiffEqSensitivity/optimal_control/SDE_control.md"},{"tag":"sourcefile","title":"NeuralPDE/src/kolmogorov_solve.jl","docid":"sourcefiles/NeuralPDE/src/kolmogorov_solve.jl"},{"tag":"sourcefile","title":"PolyChaos/src/densities.jl","docid":"sourcefiles/PolyChaos/src/densities.jl"},{"tag":"document","title":"Neural Network Solvers for Kolmogorov Backwards Equations","docid":"NeuralPDE/solvers/kolmogorovbackwards_solver.md"},{"tag":"document","title":"Systems of PDEs","docid":"NeuralPDE/pinn/system.md"},{"tag":"sourcefile","title":"ExponentialUtilities/src/ExponentialUtilities.jl","docid":"sourcefiles/ExponentialUtilities/src/ExponentialUtilities.jl"},{"tag":"sourcefile","title":"NeuralPDE/src/pinns_pde_solve.jl","docid":"sourcefiles/NeuralPDE/src/pinns_pde_solve.jl"},{"tag":"document","title":"Optimising Parameters of a Lorenz System","docid":"NeuralPDE/pinn/parm_estim.md"},{"tag":"document","title":"Fokker-Planck Equation","docid":"NeuralPDE/pinn/fp.md"},{"tag":"sourcefile","title":"Surrogates/src/Radials.jl","docid":"sourcefiles/Surrogates/src/Radials.jl"},{"tag":"document","title":"1-D Burgers' Equation With Low-Level API","docid":"NeuralPDE/pinn/low_level.md"},{"tag":"sourcefile","title":"NeuralPDE/src/NeuralPDE.jl","docid":"sourcefiles/NeuralPDE/src/NeuralPDE.jl"},{"tag":"sourcefile","title":"Surrogates/src/GEK.jl","docid":"sourcefiles/Surrogates/src/GEK.jl"},{"tag":"sourcefile","title":"Surrogates/src/Kriging.jl","docid":"sourcefiles/Surrogates/src/Kriging.jl"},{"tag":"document","title":"Kuramotoâ€“Sivashinsky equation","docid":"NeuralPDE/pinn/ks.md"},{"tag":"document","title":"Transfer Learning with Neural Adapter","docid":"NeuralPDE/pinn/neural_adapter.md"},{"tag":"sourcefile","title":"ExponentialUtilities/src/phi.jl","docid":"sourcefiles/ExponentialUtilities/src/phi.jl"},{"tag":"document","title":"Poisson Equation","docid":"NeuralPDE/pinn/poisson.md"}],"methods":[{"line":20,"file":"/Users/lorenz/.julia/packages/ExponentialUtilities/j8g4q/src/phi.jl","method_id":"ExponentialUtilities.phi_1","symbol_id":"ExponentialUtilities.phi","filedoc":"sourcefiles/ExponentialUtilities/src/phi.jl","signature":"phi(z::T, k::Integer; cache, expmethod)"},{"line":105,"file":"/Users/lorenz/.julia/packages/ExponentialUtilities/j8g4q/src/phi.jl","method_id":"ExponentialUtilities.phi_2","symbol_id":"ExponentialUtilities.phi","filedoc":"sourcefiles/ExponentialUtilities/src/phi.jl","signature":"phi(A::AbstractMatrix{T}, k; kwargs...)"}],"name":"phi","title":"phi","symbol_id":"ExponentialUtilities.phi","public":true,"module_id":"ExponentialUtilities"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["phi(z,k[;cache]) -> [phi_0(z),phi_1(z),...,phi_k(z)]\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Compute the scalar phi functions for all orders up to k."],"type":"node"},{"attributes":{},"tag":"p","children":["The phi functions are defined as"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\varphi_0(z) = \\exp(z),\\quad \\varphi_{k+1}(z) = \\frac{\\varphi_k(z) - 1}{z}"],"type":"node"},{"attributes":{},"tag":"p","children":["Instead of using the recurrence relation, which is numerically unstable, a formula given by Sidje is used (Sidje, R. B. (1998). Expokit: a software package for computing matrix exponentials. ACM Transactions on Mathematical Software (TOMS), 24(1), 130-156. Theorem 1)."],"type":"node"},{"attributes":{},"tag":"hr","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["phi(A,k[;cache]) -> [phi_0(A),phi_1(A),...,phi_k(A)]\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Compute the matrix phi functions for all orders up to k. ",{"attributes":{},"tag":"code","children":["k"],"type":"node"}," >= 1."],"type":"node"},{"attributes":{},"tag":"p","children":["The phi functions are defined as"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\varphi_0(z) = \\exp(z),\\quad \\varphi_{k+1}(z) = \\frac{\\varphi_k(z) - 1}{z}"],"type":"node"},{"attributes":{},"tag":"p","children":["Calls ",{"attributes":{},"tag":"code","children":["phiv_dense"],"type":"node"}," on each of the basis vectors to obtain the answer. If A is ",{"attributes":{},"tag":"code","children":["Diagonal"],"type":"node"},", instead calls the scalar ",{"attributes":{},"tag":"code","children":["phi"],"type":"node"}," on each diagonal element and the return values are also ",{"attributes":{},"tag":"code","children":["Diagonal"],"type":"node"},"s"],"type":"node"}],"type":"node"}],"type":"node"}