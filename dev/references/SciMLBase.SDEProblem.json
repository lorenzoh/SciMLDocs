{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"NeuralPDE/src/param_kolmogorov_solve.jl","docid":"sourcefiles/NeuralPDE/src/param_kolmogorov_solve.jl"},{"tag":"sourcefile","title":"Catalyst/src/Catalyst.jl","docid":"sourcefiles/Catalyst/src/Catalyst.jl"},{"tag":"document","title":"Solving Kolmogorov Equations with Neural Networks","docid":"NeuralPDE/examples/kolmogorovbackwards.md"},{"tag":"document","title":"Optimal Stopping Times of American Options","docid":"NeuralPDE/examples/optimal_stopping_american.md"},{"tag":"sourcefile","title":"NeuralPDE/src/pde_solve_ns.jl","docid":"sourcefiles/NeuralPDE/src/pde_solve_ns.jl"},{"tag":"document","title":"Catalyst.jl API","docid":"Catalyst/api/catalyst_api.md"},{"tag":"sourcefile","title":"NeuralPDE/src/pde_solve.jl","docid":"sourcefiles/NeuralPDE/src/pde_solve.jl"},{"tag":"sourcefile","title":"SciMLBase/src/SciMLBase.jl","docid":"sourcefiles/SciMLBase/src/SciMLBase.jl"},{"tag":"sourcefile","title":"DiffEqFlux/src/neural_de.jl","docid":"sourcefiles/DiffEqFlux/src/neural_de.jl"},{"tag":"document","title":"Modeling with Stochasticity","docid":"ModelingToolkit/tutorials/stochastic_diffeq.md"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/backsolve_adjoint.jl","docid":"sourcefiles/DiffEqSensitivity/src/backsolve_adjoint.jl"},{"tag":"document","title":"Controlling Stochastic Differential Equations","docid":"DiffEqSensitivity/optimal_control/SDE_control.md"},{"tag":"sourcefile","title":"NeuralPDE/src/kolmogorov_solve.jl","docid":"sourcefiles/NeuralPDE/src/kolmogorov_solve.jl"},{"tag":"sourcefile","title":"ModelingToolkit/src/systems/diffeqs/sdesystem.jl","docid":"sourcefiles/ModelingToolkit/src/systems/diffeqs/sdesystem.jl"},{"tag":"sourcefile","title":"NeuralPDE/src/stopping_solve.jl","docid":"sourcefiles/NeuralPDE/src/stopping_solve.jl"},{"tag":"sourcefile","title":"ModelingToolkit/src/systems/diffeqs/modelingtoolkitize.jl","docid":"sourcefiles/ModelingToolkit/src/systems/diffeqs/modelingtoolkitize.jl"},{"tag":"sourcefile","title":"Catalyst/src/reactionsystem.jl","docid":"sourcefiles/Catalyst/src/reactionsystem.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/concrete_solve.jl","docid":"sourcefiles/DiffEqSensitivity/src/concrete_solve.jl"},{"tag":"document","title":"Neural Network Solvers for Kolmogorov Backwards Equations","docid":"NeuralPDE/solvers/kolmogorovbackwards_solver.md"},{"tag":"documentation","title":"NoiseWrapper","docid":"references/DiffEqNoiseProcess.NoiseWrapper"},{"tag":"document","title":"Basic Chemical Reaction Network Examples","docid":"Catalyst/tutorials/basic_examples.md"},{"tag":"document","title":"DiffEqNoiseProcess.jl: Noise Processes for Stochastic Modeling","docid":"DiffEqNoiseProcess/index.md"},{"tag":"documentation","title":"NoiseApproximation","docid":"references/DiffEqNoiseProcess.NoiseApproximation"},{"tag":"document","title":"Neural Stochastic Differential Equations","docid":"DiffEqSensitivity/sde_fitting/neural_sde.md"},{"tag":"sourcefile","title":"ModelingToolkit/src/ModelingToolkit.jl","docid":"sourcefiles/ModelingToolkit/src/ModelingToolkit.jl"},{"tag":"document","title":"Using Catalyst","docid":"Catalyst/tutorials/using_catalyst.md"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/sensitivity_interface.jl","docid":"sourcefiles/DiffEqSensitivity/src/sensitivity_interface.jl"},{"tag":"sourcefile","title":"SciMLBase/src/problems/sde_problems.jl","docid":"sourcefiles/SciMLBase/src/problems/sde_problems.jl"},{"tag":"document","title":"Optimization of Stochastic Differential Equations","docid":"DiffEqSensitivity/sde_fitting/optimization_sde.md"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/interpolating_adjoint.jl","docid":"sourcefiles/DiffEqSensitivity/src/interpolating_adjoint.jl"}],"methods":[{"line":124,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/problems/sde_problems.jl","method_id":"SciMLBase.SDEProblem_1","symbol_id":"SciMLBase.SDEProblem","filedoc":"sourcefiles/SciMLBase/src/problems/sde_problems.jl","signature":"SDEProblem(f::SciMLBase.AbstractSDEFunction, g, u0, tspan)"},{"line":124,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/problems/sde_problems.jl","method_id":"SciMLBase.SDEProblem_2","symbol_id":"SciMLBase.SDEProblem","filedoc":"sourcefiles/SciMLBase/src/problems/sde_problems.jl","signature":"SDEProblem(f::SciMLBase.AbstractSDEFunction, g, u0, tspan, p; kwargs...)"},{"line":1214,"file":"/Users/lorenz/.julia/packages/Catalyst/2UqoT/src/reactionsystem.jl","method_id":"SciMLBase.SDEProblem_3","symbol_id":"SciMLBase.SDEProblem","filedoc":"sourcefiles/SciMLBase/src/reactionsystem.jl","signature":"SDEProblem(rs::Catalyst.ReactionSystem, u0, tspan)"},{"line":1214,"file":"/Users/lorenz/.julia/packages/Catalyst/2UqoT/src/reactionsystem.jl","method_id":"SciMLBase.SDEProblem_4","symbol_id":"SciMLBase.SDEProblem","filedoc":"sourcefiles/SciMLBase/src/reactionsystem.jl","signature":"SDEProblem(rs::Catalyst.ReactionSystem, u0, tspan, p, args...; noise_scaling, name, combinatoric_ratelaws, include_zero_odes, checks, check_length, remove_conserved, kwargs...)"},{"line":413,"file":"/Users/lorenz/.julia/packages/ModelingToolkit/fp90z/src/systems/diffeqs/sdesystem.jl","method_id":"SciMLBase.SDEProblem_5","symbol_id":"SciMLBase.SDEProblem","filedoc":"sourcefiles/SciMLBase/src/systems/diffeqs/sdesystem.jl","signature":"SDEProblem(sys::ModelingToolkit.SDESystem, args...; kwargs...)"},{"line":128,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/problems/sde_problems.jl","method_id":"SciMLBase.SDEProblem_6","symbol_id":"SciMLBase.SDEProblem","filedoc":"sourcefiles/SciMLBase/src/problems/sde_problems.jl","signature":"SDEProblem(f, g, u0, tspan)"},{"line":128,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/problems/sde_problems.jl","method_id":"SciMLBase.SDEProblem_7","symbol_id":"SciMLBase.SDEProblem","filedoc":"sourcefiles/SciMLBase/src/problems/sde_problems.jl","signature":"SDEProblem(f, g, u0, tspan, p; kwargs...)"}],"name":"SDEProblem","title":"SDEProblem","symbol_id":"SciMLBase.SDEProblem","public":true,"module_id":"SciMLBase"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["Defines an stochastic differential equation (SDE) problem. Documentation Page: https://diffeq.sciml.ai/stable/types/sde_types/"],"type":"node"},{"attributes":{},"tag":"h2","children":["Mathematical Specification of a SDE Problem"],"type":"node"},{"attributes":{},"tag":"p","children":["To define an SDE Problem, you simply need to give the forcing function ",{"attributes":{},"tag":"code","children":["f"],"type":"node"},", the noise function ",{"attributes":{},"tag":"code","children":["g"],"type":"node"},", and the initial condition ",{"attributes":{},"tag":"code","children":["u₀"],"type":"node"}," which define an SDE:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["du = f(u,p,t)dt + Σgᵢ(u,p,t)dWⁱ"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["f"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["g"],"type":"node"}," should be specified as ",{"attributes":{},"tag":"code","children":["f(u,p,t)"],"type":"node"}," and  ",{"attributes":{},"tag":"code","children":["g(u,p,t)"],"type":"node"}," respectively, and ",{"attributes":{},"tag":"code","children":["u₀"],"type":"node"}," should be an AbstractArray whose geometry matches the desired geometry of ",{"attributes":{},"tag":"code","children":["u"],"type":"node"},". Note that we are not limited to numbers or vectors for ",{"attributes":{},"tag":"code","children":["u₀"],"type":"node"},"; one is allowed to provide ",{"attributes":{},"tag":"code","children":["u₀"],"type":"node"}," as arbitrary matrices / higher dimension tensors as well. A vector of ",{"attributes":{},"tag":"code","children":["g"],"type":"node"},"s can also be defined to determine an SDE of higher Ito dimension."],"type":"node"},{"attributes":{},"tag":"h2","children":["Problem Type"],"type":"node"},{"attributes":{},"tag":"p","children":["Wraps the data which defines an SDE problem"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["u = f(u,p,t)dt + Σgᵢ(u,p,t)dWⁱ"],"type":"node"},{"attributes":{},"tag":"p","children":["with initial condition ",{"attributes":{},"tag":"code","children":["u0"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h3","children":["Constructors"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["SDEProblem(f::SDEFunction,g,u0,tspan,p=NullParameters();noise=WHITE_NOISE,noise_rate_prototype=nothing)"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["SDEProblem{isinplace}(f,g,u0,tspan,p=NullParameters();noise=WHITE_NOISE,noise_rate_prototype=nothing)"],"type":"node"}," : Defines the SDE with the specified functions. The default noise is ",{"attributes":{},"tag":"code","children":["WHITE_NOISE"],"type":"node"},". ",{"attributes":{},"tag":"code","children":["isinplace"],"type":"node"}," optionally sets whether the function is inplace or not. This is determined automatically, but not inferred."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Parameters are optional, and if not given then a ",{"attributes":{},"tag":"code","children":["NullParameters()"],"type":"node"}," singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a ",{"attributes":{},"tag":"code","children":["callback"],"type":"node"}," in the problem, then that ",{"attributes":{},"tag":"code","children":["callback"],"type":"node"}," will be added in every solve call."],"type":"node"},{"attributes":{},"tag":"p","children":["For specifying Jacobians and mass matrices, see the [DiffEqFunctions](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," performance_overloads) page."],"type":"node"},{"attributes":{},"tag":"h3","children":["Fields"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["f"],"type":"node"},": The drift function in the SDE."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["g"],"type":"node"},": The noise function in the SDE."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["u0"],"type":"node"},": The initial condition."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["tspan"],"type":"node"},": The timespan for the problem."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["p"],"type":"node"},": The optional parameters for the problem. Defaults to ",{"attributes":{},"tag":"code","children":["NullParameters"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["noise"],"type":"node"},": The noise process applied to the noise upon generation. Defaults to Gaussian white noise. For information on defining different noise processes, see [the noise process documentation page](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," noise_process)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["noise_rate_prototype"],"type":"node"},": A prototype type instance for the noise rates, that is the output ",{"attributes":{},"tag":"code","children":["g"],"type":"node"},". It can be any type which overloads ",{"attributes":{},"tag":"code","children":["A_mul_B!"],"type":"node"}," with itself being the middle argument. Commonly, this is a matrix or sparse matrix. If this is not given, it defaults to ",{"attributes":{},"tag":"code","children":["nothing"],"type":"node"},", which means the problem should be interpreted as having diagonal noise."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["kwargs"],"type":"node"},": The keyword arguments passed onto the solves."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Example Problems"],"type":"node"},{"attributes":{},"tag":"p","children":["Examples problems can be found in ",{"attributes":{"href":"https://github.com/JuliaDiffEq/DiffEqProblemLibrary.jl/blob/master/src/sde_premade_problems.jl","title":""},"tag":"a","children":["DiffEqProblemLibrary.jl"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["To use a sample problem, such as ",{"attributes":{},"tag":"code","children":["prob_sde_linear"],"type":"node"},", you can do something like:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"COMMENT","children":["#] add DiffEqProblemLibrary"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"USING","children":[{"attributes":{},"tag":"USING","children":["using"],"type":"node"},{"attributes":{},"tag":"DOT","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["DiffEqProblemLibrary"],"type":"node"},{"attributes":{},"tag":"DOT","children":["."],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["SDEProblemLibrary"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"COMMENT","children":["# load problems"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"DOT","children":[{"attributes":{},"tag":"IDENTIFIER","children":["SDEProblemLibrary"],"type":"node"},{"attributes":{},"tag":"DOT","children":["."],"type":"node"},{"attributes":{},"tag":"QUOTE","children":[{"attributes":{},"tag":"IDENTIFIER","children":["importsdeproblems"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["prob"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"DOT","children":[{"attributes":{},"tag":"IDENTIFIER","children":["SDEProblemLibrary"],"type":"node"},{"attributes":{},"tag":"DOT","children":["."],"type":"node"},{"attributes":{},"tag":"QUOTE","children":[{"attributes":{},"tag":"IDENTIFIER","children":["prob_sde_linear"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["sol"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/CommonSolve.solve"},"tag":"reference","children":["solve"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["prob"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}