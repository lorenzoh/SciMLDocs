{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"DiffEqSensitivity/src/forward_sensitivity.jl","docid":"sourcefiles/DiffEqSensitivity/src/forward_sensitivity.jl"},{"tag":"sourcefile","title":"SciMLBase/src/SciMLBase.jl","docid":"sourcefiles/SciMLBase/src/SciMLBase.jl"},{"tag":"sourcefile","title":"SciMLBase/src/callbacks.jl","docid":"sourcefiles/SciMLBase/src/callbacks.jl"},{"tag":"sourcefile","title":"ModelingToolkit/src/systems/diffeqs/abstractodesystem.jl","docid":"sourcefiles/ModelingToolkit/src/systems/diffeqs/abstractodesystem.jl"},{"tag":"document","title":"Bouncing Ball Hybrid ODE Optimization","docid":"DiffEqSensitivity/hybrid_jump_fitting/bouncing_ball.md"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/callback_tracking.jl","docid":"sourcefiles/DiffEqSensitivity/src/callback_tracking.jl"}],"methods":[{"line":135,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/callbacks.jl","method_id":"SciMLBase.ContinuousCallback_1","symbol_id":"SciMLBase.ContinuousCallback","filedoc":"sourcefiles/SciMLBase/src/callbacks.jl","signature":"ContinuousCallback(condition, affect!; initialize, finalize, idxs, rootfind, save_positions, affect_neg!, interp_points, dtrelax, abstol, reltol, repeat_nudge)"},{"line":128,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/callbacks.jl","method_id":"SciMLBase.ContinuousCallback_2","symbol_id":"SciMLBase.ContinuousCallback","filedoc":"sourcefiles/SciMLBase/src/callbacks.jl","signature":"ContinuousCallback(condition, affect!, affect_neg!; initialize, finalize, idxs, rootfind, save_positions, interp_points, dtrelax, abstol, reltol, repeat_nudge)"},{"line":111,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/callbacks.jl","method_id":"SciMLBase.ContinuousCallback_3","symbol_id":"SciMLBase.ContinuousCallback","filedoc":"sourcefiles/SciMLBase/src/callbacks.jl","signature":"ContinuousCallback(condition::F1, affect!::F2, affect_neg!::F3, initialize::F4, finalize::F5, idxs::I, rootfind, interp_points, save_positions, dtrelax::R, abstol::T, reltol::T2, repeat_nudge::T3)"}],"name":"ContinuousCallback","title":"ContinuousCallback","symbol_id":"SciMLBase.ContinuousCallback","public":true,"module_id":"SciMLBase"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/SciMLBase.ContinuousCallback"},"tag":"reference","children":["ContinuousCallback"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["condition"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["affect!"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["affect_neg!"],"type":"node"},{"attributes":{},"tag":"PARAMETERS","children":[{"attributes":{},"tag":"SEMICOLON","children":[";"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                   "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["initialize"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/SciMLBase.INITIALIZE_DEFAULT"},"tag":"reference","children":["INITIALIZE_DEFAULT"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                   "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["finalize"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/SciMLBase.FINALIZE_DEFAULT"},"tag":"reference","children":["FINALIZE_DEFAULT"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                   "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["idxs"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                   "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["rootfind"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/SciMLBase.LeftRootFind"},"tag":"reference","children":["LeftRootFind"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                   "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["save_positions"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"TUPLE","children":[{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"TRUE","children":["true"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"TRUE","children":["true"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                   "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["interp_points"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["10"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                   "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["abstol"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"INTEGER","children":["10"],"type":"node"},{"attributes":{},"tag":"STAR","children":[""],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["eps"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["reltol"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["0"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["repeat_nudge"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"INTEGER","children":["1"],"type":"node"},{"attributes":{},"tag":"FWDFWD_SLASH","children":["//"],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["100"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":["function ContinuousCallback(condition,affect!;\n                   initialize = INITIALIZE_DEFAULT,\n                   finalize = FINALIZE_DEFAULT,\n                   idxs = nothing,\n                   rootfind=LeftRootFind,\n                   save_positions=(true,true),\n                   affect_neg! = affect!,\n                   interp_points=10,\n                   abstol=10eps(),reltol=0,repeat_nudge=1//100)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Contains a single callback whose ",{"attributes":{},"tag":"code","children":["condition"],"type":"node"}," is a continuous function. The callback is triggered when this function evaluates to 0."],"type":"node"},{"attributes":{},"tag":"h1","children":["Arguments"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["condition"],"type":"node"},": This is a function ",{"attributes":{},"tag":"code","children":["condition(u,t,integrator)"],"type":"node"}," for declaring when the callback should be used. A callback is initiated if the condition hits ",{"attributes":{},"tag":"code","children":["0"],"type":"node"}," within the time interval. See the [Integrator Interface](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," integrator) documentation for information about ",{"attributes":{},"tag":"code","children":["integrator"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["affect!"],"type":"node"},": This is the function ",{"attributes":{},"tag":"code","children":["affect!(integrator)"],"type":"node"}," where one is allowed to modify the current state of the integrator. If you do not pass an ",{"attributes":{},"tag":"code","children":["affect_neg!"],"type":"node"}," function, it is called when ",{"attributes":{},"tag":"code","children":["condition"],"type":"node"}," is found to be ",{"attributes":{},"tag":"code","children":["0"],"type":"node"}," (at a root) and the cross is either an upcrossing (from negative to positive) or a downcrossing (from positive to negative). You need to explicitly pass ",{"attributes":{},"tag":"code","children":["nothing"],"type":"node"}," as the ",{"attributes":{},"tag":"code","children":["affect_neg!"],"type":"node"}," argument if it should only be called at upcrossings, e.g. ",{"attributes":{},"tag":"code","children":["ContinuousCallback(condition, affect!, nothing)"],"type":"node"},". For more information on what can be done, see the [Integrator Interface](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," integrator) manual page. Modifications to ",{"attributes":{},"tag":"code","children":["u"],"type":"node"}," are safe in this function."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["affect_neg!=affect!"],"type":"node"},": This is the function ",{"attributes":{},"tag":"code","children":["affect_neg!(integrator)"],"type":"node"}," where one is allowed to modify the current state of the integrator. This is called when ",{"attributes":{},"tag":"code","children":["condition"],"type":"node"}," is found to be ",{"attributes":{},"tag":"code","children":["0"],"type":"node"}," (at a root) and the cross is an downcrossing (from positive to negative). For more information on what can be done, see the [Integrator Interface](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," integrator) manual page. Modifications to ",{"attributes":{},"tag":"code","children":["u"],"type":"node"}," are safe in this function."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["rootfind=LeftRootFind"],"type":"node"},": This is a flag to specify the type of rootfinding to do for finding event location. If this is set to ",{"attributes":{},"tag":"code","children":["LeftRootfind"],"type":"node"},", the solution will be backtracked to the point where ",{"attributes":{},"tag":"code","children":["condition==0"],"type":"node"}," and if the solution isn't exact, the left limit of root is used. If set to ",{"attributes":{},"tag":"code","children":["RightRootFind"],"type":"node"},", the solution would be set to the right limit of the root. Otherwise the systems and the ",{"attributes":{},"tag":"code","children":["affect!"],"type":"node"}," will occur at ",{"attributes":{},"tag":"code","children":["t+dt"],"type":"node"},". Note that these enums are not exported and thus one needs to reference them as ",{"attributes":{},"tag":"code","children":["SciMLBase.LeftRootFind"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["SciMLBase.RightRootFind"],"type":"node"},", or ",{"attributes":{},"tag":"code","children":["SciMLBase.NoRootFind"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["interp_points=10"],"type":"node"},": The number of interpolated points to check the condition. The condition is found by checking whether any interpolation point / endpoint has a different sign. If ",{"attributes":{},"tag":"code","children":["interp_points=0"],"type":"node"},", then conditions will only be noticed if the sign of ",{"attributes":{},"tag":"code","children":["condition"],"type":"node"}," is different at ",{"attributes":{},"tag":"code","children":["t"],"type":"node"}," than at ",{"attributes":{},"tag":"code","children":["t+dt"],"type":"node"},". This behavior is not robust when the solution is oscillatory, and thus it's recommended that one use some interpolation points (they're cheap to compute!). ",{"attributes":{},"tag":"code","children":["0"],"type":"node"}," within the time interval."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["save_positions=(true,true)"],"type":"node"},": Boolean tuple for whether to save before and after the ",{"attributes":{},"tag":"code","children":["affect!"],"type":"node"},". This saving will occur just before and after the event, only at event times, and does not depend on options like ",{"attributes":{},"tag":"code","children":["saveat"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["save_everystep"],"type":"node"},", etc. (i.e. if ",{"attributes":{},"tag":"code","children":["saveat=[1.0,2.0,3.0]"],"type":"node"},", this can still add a save point at ",{"attributes":{},"tag":"code","children":["2.1"],"type":"node"}," if true). For discontinuous changes like a modification to ",{"attributes":{},"tag":"code","children":["u"],"type":"node"}," to be handled correctly (without error), one should set ",{"attributes":{},"tag":"code","children":["save_positions=(true,true)"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["idxs=nothing"],"type":"node"},": The components which will be interpolated into the condition. Defaults to ",{"attributes":{},"tag":"code","children":["nothing"],"type":"node"}," which means ",{"attributes":{},"tag":"code","children":["u"],"type":"node"}," will be all components."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["initialize"],"type":"node"},": This is a function ",{"attributes":{},"tag":"code","children":["(c,u,t,integrator)"],"type":"node"}," which can be used to initialize the state of the callback ",{"attributes":{},"tag":"code","children":["c"],"type":"node"},". It should modify the argument ",{"attributes":{},"tag":"code","children":["c"],"type":"node"}," and the return is ignored."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["finalize"],"type":"node"},": This is a function ",{"attributes":{},"tag":"code","children":["(c,u,t,integrator)"],"type":"node"}," which can be used to finalize the state of the callback ",{"attributes":{},"tag":"code","children":["c"],"type":"node"},". It can modify the argument ",{"attributes":{},"tag":"code","children":["c"],"type":"node"}," and the return is ignored."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["abstol=1e-14"],"type":"node"}," & ",{"attributes":{},"tag":"code","children":["reltol=0"],"type":"node"},": These are used to specify a tolerance from zero for the rootfinder: if the starting condition is less than the tolerance from zero, then no root will be detected. This is to stop repeat events happening just after a previously rootfound event."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["repeat_nudge = 1//100"],"type":"node"},": This is used to set the next testing point after a previously found zero. Defaults to 1//100, which means after a callback the next sign check will take place at t + dt*1//100 instead of at t to avoid repeats."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}