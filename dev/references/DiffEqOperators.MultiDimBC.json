{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"DiffEqOperators/src/DiffEqOperators.jl","docid":"sourcefiles/DiffEqOperators/src/DiffEqOperators.jl"},{"tag":"sourcefile","title":"DiffEqOperators/src/derivative_operators/multi_dim_bc_operators.jl","docid":"sourcefiles/DiffEqOperators/src/derivative_operators/multi_dim_bc_operators.jl"}],"methods":[{"line":95,"file":"/Users/lorenz/.julia/packages/DiffEqOperators/NWEwW/src/derivative_operators/multi_dim_bc_operators.jl","method_id":"DiffEqOperators.MultiDimBC_1","symbol_id":"DiffEqOperators.MultiDimBC","filedoc":"sourcefiles/DiffEqOperators/src/derivative_operators/multi_dim_bc_operators.jl","signature":"DiffEqOperators.MultiDimBC(BC::B, s)"}],"name":"MultiDimBC","title":"MultiDimBC","symbol_id":"DiffEqOperators.MultiDimBC","public":true,"module_id":"DiffEqOperators"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["A multidimensional BC, supporting arbitrary BCs at each boundary point. To construct an arbitrary BC, pass an Array of BCs with dimension ",{"attributes":{},"tag":"code","children":["N-1"],"type":"node"},", if ",{"attributes":{},"tag":"code","children":["N"],"type":"node"}," is the dimensionality of your domain ",{"attributes":{},"tag":"code","children":["u"],"type":"node"}," with a size of ",{"attributes":{},"tag":"code","children":["size(u)[setdiff(1:N, dim)]"],"type":"node"},", where dim is the dimension orthogonal to the boundary that you want to extend."],"type":"node"},{"attributes":{},"tag":"p","children":["It is also possible to call Q_dim = MultiDimBC(YourBC, size(u), dim) to use YourBC for the whole boundary orthogonal to that dimension."],"type":"node"},{"attributes":{},"tag":"p","children":["Further, it is possible to call Qx, Qy, Qz... = MultiDimBC(YourBC, size(u)) to use YourBC for the whole boundary for all dimensions. Valid for any number of dimensions greater than 1. However, this is only valid for Robin/General type BCs (including neummann/dirichlet) when the grid steps are equal in each dimension - including uniform grid case."],"type":"node"},{"attributes":{},"tag":"p","children":["In the case where you want to extend the same Robin/GeneralBC to the whole boundary with a non-uniform grid, please use Qx, Qy, Qz... = RobinBC(l, r, (dx::Vector, dy::Vector, dz::Vector ...), approximation_order, size(u)) or Qx, Qy, Qz... = GeneralBC(αl, αr, (dx::Vector, dy::Vector, dz::Vector ...), approximation_order, size(u))"],"type":"node"},{"attributes":{},"tag":"p","children":["There are also constructors for NeumannBC, DirichletBC and Dirichlet0BC. Simply replace ",{"attributes":{},"tag":"code","children":["dx"],"type":"node"}," in the call with the tuple dxyz... as above, and append `size(u)`` to the argument signature. The order is a required argument in this case,"],"type":"node"},{"attributes":{},"tag":"p","children":["where dx, dy, and dz are vectors of grid steps."],"type":"node"},{"attributes":{},"tag":"p","children":["For Neumann0BC, please use Qx, Qy, Qz... = Neumann0BC(T::Type, (dx::Vector, dy::Vector, dz::Vector ...), approximation_order, size(u)) where T is the element type of the domain to be extended."],"type":"node"}],"type":"node"}],"type":"node"}