{"attributes":{"kind":"function","backlinks":[{"tag":"sourcefile","title":"ExponentialUtilities/src/ExponentialUtilities.jl","docid":"sourcefiles/ExponentialUtilities/src/ExponentialUtilities.jl"},{"tag":"sourcefile","title":"ExponentialUtilities/src/krylov_phiv_adaptive.jl","docid":"sourcefiles/ExponentialUtilities/src/krylov_phiv_adaptive.jl"}],"methods":[{"line":84,"file":"/Users/lorenz/.julia/packages/ExponentialUtilities/j8g4q/src/krylov_phiv_adaptive.jl","method_id":"ExponentialUtilities.phiv_timestep_1","symbol_id":"ExponentialUtilities.phiv_timestep","filedoc":"sourcefiles/ExponentialUtilities/src/krylov_phiv_adaptive.jl","signature":"phiv_timestep(ts::Vector{tType}, A, B; kwargs...)"},{"line":88,"file":"/Users/lorenz/.julia/packages/ExponentialUtilities/j8g4q/src/krylov_phiv_adaptive.jl","method_id":"ExponentialUtilities.phiv_timestep_2","symbol_id":"ExponentialUtilities.phiv_timestep","filedoc":"sourcefiles/ExponentialUtilities/src/krylov_phiv_adaptive.jl","signature":"phiv_timestep(t::tType, A, B; kwargs...)"}],"name":"phiv_timestep","title":"phiv_timestep","symbol_id":"ExponentialUtilities.phiv_timestep","public":true,"module_id":"ExponentialUtilities"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["phiv_timestep(ts,A,B[;adaptive,tol,kwargs...]) -> U\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Evaluates the linear combination of phi-vector products using time stepping"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["u = \\varphi_0(tA)b_0 + t\\varphi_1(tA)b_1 + \\cdots + t^p\\varphi_p(tA)b_p"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["ts"],"type":"node"}," is an array of time snapshots for u, with ",{"attributes":{},"tag":"code","children":["U[:,j] ≈ u(ts[j])"],"type":"node"},". ",{"attributes":{},"tag":"code","children":["ts"],"type":"node"}," can also be just one value, in which case only the end result is returned and ",{"attributes":{},"tag":"code","children":["U"],"type":"node"}," is a vector."],"type":"node"},{"attributes":{},"tag":"p","children":["The time stepping formula of Niesen & Wright is used ",{"attributes":{},"tag":"footnotelink","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"},". If the time step ",{"attributes":{},"tag":"code","children":["tau"],"type":"node"}," is not specified, it is chosen according to (17) of Neisen & Wright. If ",{"attributes":{},"tag":"code","children":["adaptive==true"],"type":"node"},", the time step and Krylov subsapce size adaptation scheme of Niesen & Wright is used, the relative tolerance of which can be set using the keyword parameter ",{"attributes":{},"tag":"code","children":["tol"],"type":"node"},". The delta and gamma parameter of the adaptation scheme can also be adjusted."],"type":"node"},{"attributes":{},"tag":"p","children":["Set ",{"attributes":{},"tag":"code","children":["verbose=true"],"type":"node"}," to print out the internal steps (for debugging). For the other keyword arguments, consult ",{"attributes":{},"tag":"code","children":["arnoldi"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["phiv"],"type":"node"},", which are used internally."],"type":"node"},{"attributes":{},"tag":"footnotedef","children":[{"attributes":{},"tag":"p","children":["Niesen, J., & Wright, W. (2009). A Krylov subspace algorithm for evaluating the φ-functions in exponential integrators. arXiv preprint arXiv:0907.4631."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}