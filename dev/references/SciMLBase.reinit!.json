{"attributes":{"kind":"function","backlinks":[{"tag":"sourcefile","title":"NonlinearSolve/src/solve.jl","docid":"sourcefiles/NonlinearSolve/src/solve.jl"},{"tag":"sourcefile","title":"SciMLBase/src/SciMLBase.jl","docid":"sourcefiles/SciMLBase/src/SciMLBase.jl"},{"tag":"sourcefile","title":"SciMLBase/src/integrator_interface.jl","docid":"sourcefiles/SciMLBase/src/integrator_interface.jl"}],"methods":[{"line":219,"file":"/home/runner/.julia/packages/SciMLBase/dYFnI/src/integrator_interface.jl","method_id":"SciMLBase.reinit!_1","symbol_id":"SciMLBase.reinit!","filedoc":"sourcefiles/SciMLBase/src/integrator_interface.jl","signature":"reinit!(integrator::SciMLBase.DEIntegrator, args...; kwargs...)"},{"line":113,"file":"/home/runner/.julia/packages/NonlinearSolve/kBzny/src/solve.jl","method_id":"SciMLBase.reinit!_2","symbol_id":"SciMLBase.reinit!","filedoc":"sourcefiles/SciMLBase/src/solve.jl","signature":"reinit!(solver::NonlinearSolve.NewtonImmutableSolver, prob::SciMLBase.NonlinearProblem{uType, false})"},{"line":106,"file":"/home/runner/.julia/packages/NonlinearSolve/kBzny/src/solve.jl","method_id":"SciMLBase.reinit!_3","symbol_id":"SciMLBase.reinit!","filedoc":"sourcefiles/SciMLBase/src/solve.jl","signature":"reinit!(solver::NonlinearSolve.NewtonImmutableSolver, prob::SciMLBase.NonlinearProblem{uType, true})"}],"name":"reinit!","title":"reinit!","symbol_id":"SciMLBase.reinit!","public":true,"module_id":"SciMLBase"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["reinit!(integrator::DEIntegrator,args...; kwargs...)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["The reinit function lets you restart the integration at a new value."],"type":"node"},{"attributes":{},"tag":"h1","children":["Arguments"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["u0"],"type":"node"},": Value of ",{"attributes":{},"tag":"code","children":["u"],"type":"node"}," to start at. Default value is ",{"attributes":{},"tag":"code","children":["integrator.sol.prob.u0"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h1","children":["Keyword Arguments"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["t0"],"type":"node"},": Starting timepoint. Default value is ",{"attributes":{},"tag":"code","children":["integrator.sol.prob.tspan[1]"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["tf"],"type":"node"},": Ending timepoint. Default value is ",{"attributes":{},"tag":"code","children":["integrator.sol.prob.tspan[2]"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["erase_sol=true"],"type":"node"},": Whether to start with no other values in the solution, or keep the previous solution."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["tstops"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["d_discontinuities"],"type":"node"},", & ",{"attributes":{},"tag":"code","children":["saveat"],"type":"node"},": Cache where these are stored. Default is the original cache."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["reset_dt"],"type":"node"},": Set whether to reset the current value of ",{"attributes":{},"tag":"code","children":["dt"],"type":"node"}," using the automatic ",{"attributes":{},"tag":"code","children":["dt"],"type":"node"}," determination algorithm. Default is ",{"attributes":{},"tag":"code","children":["(integrator.dtcache == zero(integrator.dt)) && integrator.opts.adaptive"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["reinit_callbacks"],"type":"node"},": Set whether to run the callback initializations again (and ",{"attributes":{},"tag":"code","children":["initialize_save"],"type":"node"}," is for that). Default is ",{"attributes":{},"tag":"code","children":["true"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["reinit_cache"],"type":"node"},": Set whether to re-run the cache initialization function (i.e. resetting FSAL, not allocating vectors) which should usually be true for correctness. Default is ",{"attributes":{},"tag":"code","children":["true"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Additionally, once can access ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["auto_dt_reset!"],"type":"node"}],"type":"node"}," which will run the auto ",{"attributes":{},"tag":"code","children":["dt"],"type":"node"}," initialization algorithm."],"type":"node"}],"type":"node"}],"type":"node"}