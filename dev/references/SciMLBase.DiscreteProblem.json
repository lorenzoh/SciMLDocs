{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"ModelingToolkit/src/systems/jumps/jumpsystem.jl","docid":"sourcefiles/ModelingToolkit/src/systems/jumps/jumpsystem.jl"},{"tag":"sourcefile","title":"Catalyst/src/Catalyst.jl","docid":"sourcefiles/Catalyst/src/Catalyst.jl"},{"tag":"document","title":"Catalyst.jl API","docid":"Catalyst/api/catalyst_api.md"},{"tag":"sourcefile","title":"SciMLBase/src/SciMLBase.jl","docid":"sourcefiles/SciMLBase/src/SciMLBase.jl"},{"tag":"documentation","title":"DiscreteProblemExpr","docid":"references/ModelingToolkit.DiscreteProblemExpr"},{"tag":"sourcefile","title":"Catalyst/src/reactionsystem.jl","docid":"sourcefiles/Catalyst/src/reactionsystem.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/concrete_solve.jl","docid":"sourcefiles/DiffEqSensitivity/src/concrete_solve.jl"},{"tag":"document","title":"Basic Chemical Reaction Network Examples","docid":"Catalyst/tutorials/basic_examples.md"},{"tag":"sourcefile","title":"ModelingToolkit/src/systems/discrete_system/discrete_system.jl","docid":"sourcefiles/ModelingToolkit/src/systems/discrete_system/discrete_system.jl"},{"tag":"sourcefile","title":"ModelingToolkit/src/ModelingToolkit.jl","docid":"sourcefiles/ModelingToolkit/src/ModelingToolkit.jl"},{"tag":"document","title":"Using Catalyst","docid":"Catalyst/tutorials/using_catalyst.md"},{"tag":"sourcefile","title":"SciMLBase/src/problems/discrete_problems.jl","docid":"sourcefiles/SciMLBase/src/problems/discrete_problems.jl"},{"tag":"document","title":"Smoluchowski Coagulation Equation","docid":"Catalyst/tutorials/generating_reactions_programmatically.md"}],"methods":[{"line":125,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/problems/discrete_problems.jl","method_id":"SciMLBase.DiscreteProblem_1","symbol_id":"SciMLBase.DiscreteProblem","filedoc":"sourcefiles/SciMLBase/src/problems/discrete_problems.jl","signature":"DiscreteProblem(u0::Union{Number, AbstractArray}, tspan::Tuple)"},{"line":125,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/problems/discrete_problems.jl","method_id":"SciMLBase.DiscreteProblem_2","symbol_id":"SciMLBase.DiscreteProblem","filedoc":"sourcefiles/SciMLBase/src/problems/discrete_problems.jl","signature":"DiscreteProblem(u0::Union{Number, AbstractArray}, tspan::Tuple, p; kwargs...)"},{"line":234,"file":"/Users/lorenz/.julia/packages/ModelingToolkit/fp90z/src/systems/jumps/jumpsystem.jl","method_id":"SciMLBase.DiscreteProblem_3","symbol_id":"SciMLBase.DiscreteProblem","filedoc":"sourcefiles/SciMLBase/src/systems/jumps/jumpsystem.jl","signature":"DiscreteProblem(sys::ModelingToolkit.JumpSystem, u0map, tspan::Union{Nothing, Tuple})"},{"line":234,"file":"/Users/lorenz/.julia/packages/ModelingToolkit/fp90z/src/systems/jumps/jumpsystem.jl","method_id":"SciMLBase.DiscreteProblem_4","symbol_id":"SciMLBase.DiscreteProblem","filedoc":"sourcefiles/SciMLBase/src/systems/jumps/jumpsystem.jl","signature":"DiscreteProblem(sys::ModelingToolkit.JumpSystem, u0map, tspan::Union{Nothing, Tuple}, parammap; checkbounds, use_union, kwargs...)"},{"line":111,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/problems/discrete_problems.jl","method_id":"SciMLBase.DiscreteProblem_5","symbol_id":"SciMLBase.DiscreteProblem","filedoc":"sourcefiles/SciMLBase/src/problems/discrete_problems.jl","signature":"DiscreteProblem(f::SciMLBase.AbstractDiscreteFunction, u0, tspan::Tuple)"},{"line":111,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/problems/discrete_problems.jl","method_id":"SciMLBase.DiscreteProblem_6","symbol_id":"SciMLBase.DiscreteProblem","filedoc":"sourcefiles/SciMLBase/src/problems/discrete_problems.jl","signature":"DiscreteProblem(f::SciMLBase.AbstractDiscreteFunction, u0, tspan::Tuple, p; kwargs...)"},{"line":115,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/problems/discrete_problems.jl","method_id":"SciMLBase.DiscreteProblem_7","symbol_id":"SciMLBase.DiscreteProblem","filedoc":"sourcefiles/SciMLBase/src/problems/discrete_problems.jl","signature":"DiscreteProblem(f::Union{Function, Type}, u0, tspan::Tuple)"},{"line":115,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/problems/discrete_problems.jl","method_id":"SciMLBase.DiscreteProblem_8","symbol_id":"SciMLBase.DiscreteProblem","filedoc":"sourcefiles/SciMLBase/src/problems/discrete_problems.jl","signature":"DiscreteProblem(f::Union{Function, Type}, u0, tspan::Tuple, p; kwargs...)"},{"line":1229,"file":"/Users/lorenz/.julia/packages/Catalyst/2UqoT/src/reactionsystem.jl","method_id":"SciMLBase.DiscreteProblem_9","symbol_id":"SciMLBase.DiscreteProblem","filedoc":"sourcefiles/SciMLBase/src/reactionsystem.jl","signature":"DiscreteProblem(rs::Catalyst.ReactionSystem, u0, tspan::Tuple)"},{"line":1229,"file":"/Users/lorenz/.julia/packages/Catalyst/2UqoT/src/reactionsystem.jl","method_id":"SciMLBase.DiscreteProblem_10","symbol_id":"SciMLBase.DiscreteProblem","filedoc":"sourcefiles/SciMLBase/src/reactionsystem.jl","signature":"DiscreteProblem(rs::Catalyst.ReactionSystem, u0, tspan::Tuple, p, args...; name, combinatoric_ratelaws, checks, kwargs...)"},{"line":175,"file":"/Users/lorenz/.julia/packages/ModelingToolkit/fp90z/src/systems/discrete_system/discrete_system.jl","method_id":"SciMLBase.DiscreteProblem_11","symbol_id":"SciMLBase.DiscreteProblem","filedoc":"sourcefiles/SciMLBase/src/systems/discrete_system/discrete_system.jl","signature":"DiscreteProblem(sys::ModelingToolkit.DiscreteSystem, u0map, tspan)"},{"line":175,"file":"/Users/lorenz/.julia/packages/ModelingToolkit/fp90z/src/systems/discrete_system/discrete_system.jl","method_id":"SciMLBase.DiscreteProblem_12","symbol_id":"SciMLBase.DiscreteProblem","filedoc":"sourcefiles/SciMLBase/src/systems/discrete_system/discrete_system.jl","signature":"DiscreteProblem(sys::ModelingToolkit.DiscreteSystem, u0map, tspan, parammap; eval_module, eval_expression, use_union, kwargs...)"}],"name":"DiscreteProblem","title":"DiscreteProblem","symbol_id":"SciMLBase.DiscreteProblem","public":true,"module_id":"SciMLBase"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["Defines a discrete dynamical system problem. Documentation Page: https://diffeq.sciml.ai/stable/types/discrete_types/"],"type":"node"},{"attributes":{},"tag":"h2","children":["Mathematical Specification of a Discrete Problem"],"type":"node"},{"attributes":{},"tag":"p","children":["To define an Discrete Problem, you simply need to give the function ",{"attributes":{},"tag":"math","children":["f"],"type":"node"}," and the initial condition ",{"attributes":{},"tag":"math","children":["u_0"],"type":"node"}," which define a function map:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["u_{n+1} = f(u_{n},p,t_{n+1})"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["f"],"type":"node"}," should be specified as ",{"attributes":{},"tag":"code","children":["f(un,p,t)"],"type":"node"}," (or in-place as ",{"attributes":{},"tag":"code","children":["f(unp1,un,p,t)"],"type":"node"},"), and ",{"attributes":{},"tag":"code","children":["u_0"],"type":"node"}," should be an AbstractArray (or number) whose geometry matches the desired geometry of ",{"attributes":{},"tag":"code","children":["u"],"type":"node"},". Note that we are not limited to numbers or vectors for ",{"attributes":{},"tag":"code","children":["u₀"],"type":"node"},"; one is allowed to provide ",{"attributes":{},"tag":"code","children":["u₀"],"type":"node"}," as arbitrary matrices / higher dimension tensors as well. ",{"attributes":{},"tag":"math","children":["u_{n+1}"],"type":"node"}," only depends on the previous iteration ",{"attributes":{},"tag":"math","children":["u_{n}"],"type":"node"}," and ",{"attributes":{},"tag":"math","children":["t_{n+1}"],"type":"node"},". The default ",{"attributes":{},"tag":"math","children":["t_{n+1}"],"type":"node"}," of ",{"attributes":{},"tag":"code","children":["FunctionMap"],"type":"node"}," is ",{"attributes":{},"tag":"math","children":["t_n = t_0 + n*dt"],"type":"node"}," (with ",{"attributes":{},"tag":"code","children":["dt=1"],"type":"node"}," being the default). For continuous-time Markov chains this is the time at which the change is occuring."],"type":"node"},{"attributes":{},"tag":"p","children":["Note that if the discrete solver is set to have ",{"attributes":{},"tag":"code","children":["scale_by_time=true"],"type":"node"},", then the problem is interpreted as the map:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["u_{n+1} = u_n + dt f(u_{n},p,t_{n+1})"],"type":"node"},{"attributes":{},"tag":"h2","children":["Problem Type"],"type":"node"},{"attributes":{},"tag":"h3","children":["Constructors"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["DiscreteProblem{isinplace}(f::ODEFunction,u0,tspan,p=NullParameters();kwargs...)"],"type":"node"}," : Defines the discrete problem with the specified functions."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["DiscreteProblem{isinplace}(f,u0,tspan,p=NullParameters();kwargs...)"],"type":"node"}," : Defines the discrete problem with the specified functions."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["DiscreteProblem{isinplace}(u0,tspan,p=NullParameters();kwargs...)"],"type":"node"}," : Defines the discrete problem with the identity map."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Parameters are optional, and if not given then a ",{"attributes":{},"tag":"code","children":["NullParameters()"],"type":"node"}," singleton will be used which will throw nice errors if you try to index non-existent parameters. Any extra keyword arguments are passed on to the solvers. For example, if you set a ",{"attributes":{},"tag":"code","children":["callback"],"type":"node"}," in the problem, then that ",{"attributes":{},"tag":"code","children":["callback"],"type":"node"}," will be added in every solve call."],"type":"node"},{"attributes":{},"tag":"p","children":["For specifying Jacobians and mass matrices, see the [DiffEqFunctions](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," performance_overloads) page."],"type":"node"},{"attributes":{},"tag":"h3","children":["Fields"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["f"],"type":"node"},": The function in the map."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["u0"],"type":"node"},": The initial condition."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["tspan"],"type":"node"},": The timespan for the problem."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["p"],"type":"node"},": The parameters for the problem. Defaults to ",{"attributes":{},"tag":"code","children":["NullParameters"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["kwargs"],"type":"node"},": The keyword arguments passed onto the solves."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h4","children":["Note About Timing"],"type":"node"},{"attributes":{},"tag":"p","children":["Note that if no ",{"attributes":{},"tag":"code","children":["dt"],"type":"node"}," and not ",{"attributes":{},"tag":"code","children":["tstops"],"type":"node"}," is given, it's assumed that ",{"attributes":{},"tag":"code","children":["dt=1"],"type":"node"}," and thus ",{"attributes":{},"tag":"code","children":["tspan=(0,n)"],"type":"node"}," will solve for ",{"attributes":{},"tag":"code","children":["n"],"type":"node"}," iterations. If in the solver ",{"attributes":{},"tag":"code","children":["dt"],"type":"node"}," is given, then the number of iterations will change. And if ",{"attributes":{},"tag":"code","children":["tstops"],"type":"node"}," is not empty, the solver will revert to the standard behavior of fixed timestep methods, which is \"step to each tstop\"."],"type":"node"},{"attributes":{},"tag":"hr","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["DiscreteProblem{isinplace}(f,u0,tspan,p=NullParameters(),callback=nothing)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Defines a discrete problem with the specified functions."],"type":"node"},{"attributes":{},"tag":"hr","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"},{"attributes":{},"tag":"p","children":["DocStringExtensions.MethodSignatures()"],"type":"node"},{"attributes":{},"tag":"p","children":["Define a discrete problem with the identity map."],"type":"node"}],"type":"node"}],"type":"node"}