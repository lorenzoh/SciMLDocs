{"attributes":{"kind":"function","backlinks":[{"tag":"sourcefile","title":"ExponentialUtilities/src/ExponentialUtilities.jl","docid":"sourcefiles/ExponentialUtilities/src/ExponentialUtilities.jl"},{"tag":"sourcefile","title":"ExponentialUtilities/src/krylov_phiv_adaptive.jl","docid":"sourcefiles/ExponentialUtilities/src/krylov_phiv_adaptive.jl"}],"methods":[{"line":33,"file":"/Users/lorenz/.julia/packages/ExponentialUtilities/j8g4q/src/krylov_phiv_adaptive.jl","method_id":"ExponentialUtilities.expv_timestep_1","symbol_id":"ExponentialUtilities.expv_timestep","filedoc":"sourcefiles/ExponentialUtilities/src/krylov_phiv_adaptive.jl","signature":"expv_timestep(ts::Vector{tType}, A, b; kwargs...)"},{"line":37,"file":"/Users/lorenz/.julia/packages/ExponentialUtilities/j8g4q/src/krylov_phiv_adaptive.jl","method_id":"ExponentialUtilities.expv_timestep_2","symbol_id":"ExponentialUtilities.expv_timestep","filedoc":"sourcefiles/ExponentialUtilities/src/krylov_phiv_adaptive.jl","signature":"expv_timestep(t::tType, A, b; kwargs...)"}],"name":"expv_timestep","title":"expv_timestep","symbol_id":"ExponentialUtilities.expv_timestep","public":true,"module_id":"ExponentialUtilities"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["exp_timestep(ts,A,b[;adaptive,tol,kwargs...]) -> U\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Evaluates the matrix exponentiation-vector product using time stepping"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["u = \\exp(tA)b"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["ts"],"type":"node"}," is an array of time snapshots for u, with ",{"attributes":{},"tag":"code","children":["U[:,j] ≈ u(ts[j])"],"type":"node"},". ",{"attributes":{},"tag":"code","children":["ts"],"type":"node"}," can also be just one value, in which case only the end result is returned and ",{"attributes":{},"tag":"code","children":["U"],"type":"node"}," is a vector."],"type":"node"},{"attributes":{},"tag":"p","children":["The time stepping formula of Niesen & Wright is used ",{"attributes":{},"tag":"footnotelink","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"},". If the time step ",{"attributes":{},"tag":"code","children":["tau"],"type":"node"}," is not specified, it is chosen according to (17) of Neisen & Wright. If ",{"attributes":{},"tag":"code","children":["adaptive==true"],"type":"node"},", the time step and Krylov subsapce size adaptation scheme of Niesen & Wright is used, the relative tolerance of which can be set using the keyword parameter ",{"attributes":{},"tag":"code","children":["tol"],"type":"node"},". The delta and gamma parameter of the adaptation scheme can also be adjusted."],"type":"node"},{"attributes":{},"tag":"p","children":["Set ",{"attributes":{},"tag":"code","children":["verbose=true"],"type":"node"}," to print out the internal steps (for debugging). For the other keyword arguments, consult ",{"attributes":{},"tag":"code","children":["arnoldi"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["phiv"],"type":"node"},", which are used internally."],"type":"node"},{"attributes":{},"tag":"p","children":["Note that this function is just a special case of ",{"attributes":{},"tag":"code","children":["phiv_timestep"],"type":"node"}," with a more intuitive interface (vector ",{"attributes":{},"tag":"code","children":["b"],"type":"node"}," instead of a n-by-1 matrix ",{"attributes":{},"tag":"code","children":["B"],"type":"node"},")."],"type":"node"},{"attributes":{},"tag":"footnotedef","children":[{"attributes":{},"tag":"p","children":["Niesen, J., & Wright, W. (2009). A Krylov subspace algorithm for evaluating the φ-functions in exponential integrators. arXiv preprint arXiv:0907.4631."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}