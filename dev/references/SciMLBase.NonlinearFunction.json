{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"SciMLBase/src/problems/basic_problems.jl","docid":"sourcefiles/SciMLBase/src/problems/basic_problems.jl"},{"tag":"sourcefile","title":"SciMLBase/src/scimlfunctions.jl","docid":"sourcefiles/SciMLBase/src/scimlfunctions.jl"},{"tag":"sourcefile","title":"SciMLBase/src/SciMLBase.jl","docid":"sourcefiles/SciMLBase/src/SciMLBase.jl"},{"tag":"documentation","title":"NonlinearProblem","docid":"references/SciMLBase.NonlinearProblem"}],"methods":[{"line":2532,"file":"/home/runner/.julia/packages/SciMLBase/dYFnI/src/scimlfunctions.jl","method_id":"SciMLBase.NonlinearFunction_1","symbol_id":"SciMLBase.NonlinearFunction","filedoc":"sourcefiles/SciMLBase/src/scimlfunctions.jl","signature":"SciMLBase.NonlinearFunction(f::SciMLBase.NonlinearFunction; kwargs...)"},{"line":2531,"file":"/home/runner/.julia/packages/SciMLBase/dYFnI/src/scimlfunctions.jl","method_id":"SciMLBase.NonlinearFunction_2","symbol_id":"SciMLBase.NonlinearFunction","filedoc":"sourcefiles/SciMLBase/src/scimlfunctions.jl","signature":"SciMLBase.NonlinearFunction(f; kwargs...)"}],"name":"NonlinearFunction","title":"NonlinearFunction","symbol_id":"SciMLBase.NonlinearFunction","public":true,"module_id":"SciMLBase"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["NonlinearFunction <: AbstractNonlinearFunction"],"type":"node"},{"attributes":{},"tag":"p","children":["A representation of an nonlinear system of equations ",{"attributes":{},"tag":"code","children":["f"],"type":"node"},", defined by:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["0 = f(u,p)"],"type":"node"},{"attributes":{},"tag":"p","children":["and all of its related functions, such as the Jacobian of ",{"attributes":{},"tag":"code","children":["f"],"type":"node"},", its gradient with respect to time, and more. For all cases, ",{"attributes":{},"tag":"code","children":["u0"],"type":"node"}," is the initial condition, ",{"attributes":{},"tag":"code","children":["p"],"type":"node"}," are the parameters, and ",{"attributes":{},"tag":"code","children":["t"],"type":"node"}," is the independent variable."],"type":"node"},{"attributes":{},"tag":"h2","children":["Constructor"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"CURLY","children":[{"attributes":{"reftype":"symbol","document_id":"references/SciMLBase.NonlinearFunction"},"tag":"reference","children":["NonlinearFunction"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["iip"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["recompile"],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["f"],"type":"node"},{"attributes":{},"tag":"PARAMETERS","children":[{"attributes":{},"tag":"SEMICOLON","children":[";"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                           "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["analytic"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                           "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["jac"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                           "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["jvp"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                           "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["vjp"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                           "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["jac_prototype"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                           "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["sparsity"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["jac_prototype"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                           "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["paramjac"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                           "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["syms"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                           "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["indepsym"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                           "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["colorvec"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Note that only the function ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," itself is required. This function should be given as ",{"attributes":{},"tag":"code","children":["f!(du,u,p)"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["du = f(u,p)"],"type":"node"},". See the section on ",{"attributes":{},"tag":"code","children":["iip"],"type":"node"}," for more details on in-place vs out-of-place handling."],"type":"node"},{"attributes":{},"tag":"p","children":["All of the remaining functions are optional for improving or accelerating  the usage of ",{"attributes":{},"tag":"code","children":["f"],"type":"node"},". These include:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["analytic(u0,p)"],"type":"node"},": used to pass an analytical solution function for the analytical  solution of the ODE. Generally only used for testing and development of the solvers."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["jac(J,u,p)"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["J=jac(u,p)"],"type":"node"},": returns ",{"attributes":{},"tag":"math","children":["\\frac{df}{du}"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["jvp(Jv,v,u,p)"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["Jv=jvp(v,u,p)"],"type":"node"},": returns the directional derivative",{"attributes":{},"tag":"math","children":["\\frac{df}{du} v"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["vjp(Jv,v,u,p)"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["Jv=vjp(v,u,p)"],"type":"node"},": returns the adjoint derivative",{"attributes":{},"tag":"math","children":["\\frac{df}{du}^\\ast v"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["jac_prototype"],"type":"node"},": a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized ",{"attributes":{},"tag":"code","children":["Tridiagonal"],"type":"node"}," matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a ",{"attributes":{},"tag":"code","children":["SparseMatrixCSC"],"type":"node"}," with a correct sparsity pattern for the Jacobian. The default is ",{"attributes":{},"tag":"code","children":["nothing"],"type":"node"},", which means a dense Jacobian."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["paramjac(pJ,u,p)"],"type":"node"},": returns the parameter Jacobian ",{"attributes":{},"tag":"math","children":["\\frac{df}{dp}"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["syms"],"type":"node"},": the symbol names for the elements of the equation. This should match ",{"attributes":{},"tag":"code","children":["u0"],"type":"node"}," in size. For example, if ",{"attributes":{},"tag":"code","children":["u0 = [0.0,1.0]"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["syms = [:x, :y]"],"type":"node"},", this will apply a canonical naming to the values, allowing ",{"attributes":{},"tag":"code","children":["sol[:x]"],"type":"node"}," in the solution and automatically naming values in plots."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["indepsym"],"type":"node"},": the canonical naming for the independent variable. Defaults to nothing, which internally uses ",{"attributes":{},"tag":"code","children":["t"],"type":"node"}," as the representation in any plots."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["colorvec"],"type":"node"},": a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the ",{"attributes":{},"tag":"code","children":["jac_prototype"],"type":"node"},". This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to ",{"attributes":{},"tag":"code","children":["nothing"],"type":"node"},", which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["iip: In-Place vs Out-Of-Place"],"type":"node"},{"attributes":{},"tag":"p","children":["For more details on this argument, see the ODEFunction documentation."],"type":"node"},{"attributes":{},"tag":"h2","children":["recompile: Controlling Compilation and Specialization"],"type":"node"},{"attributes":{},"tag":"p","children":["For more details on this argument, see the ODEFunction documentation."],"type":"node"},{"attributes":{},"tag":"h2","children":["Fields"],"type":"node"},{"attributes":{},"tag":"p","children":["The fields of the NonlinearFunction type directly match the names of the inputs."],"type":"node"}],"type":"node"}],"type":"node"}