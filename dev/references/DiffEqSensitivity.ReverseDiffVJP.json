{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"DiffEqSensitivity/src/derivative_wrappers.jl","docid":"sourcefiles/DiffEqSensitivity/src/derivative_wrappers.jl"},{"tag":"document","title":"Parameter Estimation on Highly Stiff Systems","docid":"DiffEqSensitivity/ode_fitting/stiff_ode_fit.md"},{"tag":"sourcefile","title":"Integrals/src/Integrals.jl","docid":"sourcefiles/Integrals/src/Integrals.jl"},{"tag":"document","title":"[Solving Optimal Control Problems with Universal Differential Equations]( optcontrol)","docid":"DiffEqSensitivity/optimal_control/optimal_control.md"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/quadrature_adjoint.jl","docid":"sourcefiles/DiffEqSensitivity/src/quadrature_adjoint.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/concrete_solve.jl","docid":"sourcefiles/DiffEqSensitivity/src/concrete_solve.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/adjoint_common.jl","docid":"sourcefiles/DiffEqSensitivity/src/adjoint_common.jl"},{"tag":"document","title":"Universal Differential Equations for Neural Feedback Control","docid":"DiffEqSensitivity/optimal_control/feedback_control.md"},{"tag":"document","title":"Benchmarks","docid":"DiffEqSensitivity/Benchmark.md"},{"tag":"documentation","title":"NeuralODEMM","docid":"references/DiffEqFlux.NeuralODEMM"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/DiffEqSensitivity.jl","docid":"sourcefiles/DiffEqSensitivity/src/DiffEqSensitivity.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/sensitivity_algorithms.jl","docid":"sourcefiles/DiffEqSensitivity/src/sensitivity_algorithms.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/sensitivity_interface.jl","docid":"sourcefiles/DiffEqSensitivity/src/sensitivity_interface.jl"},{"tag":"document","title":"Simultaneous Fitting of Multiple Neural Networks","docid":"DiffEqSensitivity/training_tips/multiple_nn.md"},{"tag":"documentation","title":"NeuralODE","docid":"references/DiffEqFlux.NeuralODE"}],"methods":[{"line":1005,"file":"/Users/lorenz/.julia/packages/DiffEqSensitivity/GjhZ8/src/sensitivity_algorithms.jl","method_id":"DiffEqSensitivity.ReverseDiffVJP_1","symbol_id":"DiffEqSensitivity.ReverseDiffVJP","filedoc":"sourcefiles/DiffEqSensitivity/src/sensitivity_algorithms.jl","signature":"DiffEqSensitivity.ReverseDiffVJP()"},{"line":1005,"file":"/Users/lorenz/.julia/packages/DiffEqSensitivity/GjhZ8/src/sensitivity_algorithms.jl","method_id":"DiffEqSensitivity.ReverseDiffVJP_2","symbol_id":"DiffEqSensitivity.ReverseDiffVJP","filedoc":"sourcefiles/DiffEqSensitivity/src/sensitivity_algorithms.jl","signature":"DiffEqSensitivity.ReverseDiffVJP(compile)"}],"name":"ReverseDiffVJP","title":"ReverseDiffVJP","symbol_id":"DiffEqSensitivity.ReverseDiffVJP","public":true,"module_id":"DiffEqSensitivity"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["ReverseDiffVJP <: VJPChoice"],"type":"node"},{"attributes":{},"tag":"p","children":["Uses ReverseDiff.jl to compute the vector-Jacobian products. If ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," is in-place, then it uses a array of structs formulation to do scalarized reverse mode, while if ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," is out-of-place then it uses an array-based reverse mode."],"type":"node"},{"attributes":{},"tag":"p","children":["Usually the fastest when scalarized operations exist in the f function (like in scientific machine learning applications like Universal Differential Equations) and the boolean compilation is enabled (i.e. ReverseDiffVJP(true)), if EnzymeVJP fails on a given choice of ",{"attributes":{},"tag":"code","children":["f"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["Does not support GPUs (CuArrays)."],"type":"node"},{"attributes":{},"tag":"h2","children":["Constructor"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/DiffEqSensitivity.ReverseDiffVJP"},"tag":"reference","children":["ReverseDiffVJP"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["compile"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"FALSE","children":["false"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Keyword Arguments"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["compile"],"type":"node"},": Whether to cache the compilation of the reverse tape. This heavily increases the performance of the method but requires that the ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," function of the ODE/DAE/SDE/DDE has no branching."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}