{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/NeuralPDE/y7uHG/docs/src/pinn/debugging.md","title":"Debugging PINN Solutions"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Debugging PINN Solutions"],"type":"node"},{"attributes":{},"tag":"p","children":["Let's walk through debugging functions for the physics-informed neural network PDE solvers."],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":["using NeuralPDE, ModelingToolkit, Flux, DiffEqFlux, Zygote\nimport ModelingToolkit: Interval, infimum, supremum\n# 2d wave equation, neumann boundary condition\n@parameters x, t\n@variables u(..)\nDxx = Differential(x)^2\nDtt = Differential(t)^2\nDt = Differential(t)\n#2D PDE\nC=1\neq  = Dtt(u(x,t)) ~ C^2*Dxx(u(x,t))\n\n# Initial and boundary conditions\nbcs = [u(0,t) ~ 0.,\n       u(1,t) ~ 0.,\n       u(x,0) ~ x*(1. - x),\n       Dt(u(x,0)) ~ 0. ]\n\n# Space and time domains\ndomains = [x ∈ Interval(0.0,1.0),\n           t ∈ Interval(0.0,1.0)]\n\n# Neural network\nchain = FastChain(FastDense(2,16,Flux.σ),FastDense(16,16,Flux.σ),FastDense(16,1))\ninitθ = DiffEqFlux.initial_params(chain)\n\neltypeθ = eltype(initθ)\nparameterless_type_θ = DiffEqBase.parameterless_type(initθ)\nphi = NeuralPDE.get_phi(chain,parameterless_type_θ)\nderivative = NeuralPDE.get_numeric_derivative()\n\nu_ = (cord, θ, phi)->sum(phi(cord, θ))\n\nphi([1,2], initθ)\n\nphi_ = (p) -> phi(p, initθ)[1]\ndphi = Zygote.gradient(phi_,[1.,2.])\n\ndphi1 = derivative(phi,u_,[1.,2.],[[ 0.0049215667, 0.0]],1,initθ)\ndphi2 = derivative(phi,u_,[1.,2.],[[0.0,  0.0049215667]],1,initθ)\nisapprox(dphi[1][1], dphi1, atol=1e-8)\nisapprox(dphi[1][2], dphi2, atol=1e-8)\n\n\nindvars = [x,t]\ndepvars = [u(x, t)]\ndict_depvars_input = Dict(:u => [:x, :t])\ndim = length(domains)\ndx = 0.1\nstrategy = NeuralPDE.GridTraining(dx)\nintegral = NeuralPDE.get_numeric_integral(strategy, indvars, depvars, chain, derivative)\n\n_pde_loss_function = NeuralPDE.build_loss_function(eq,indvars,depvars,phi,derivative,integral,chain,initθ,strategy)\n\njulia> expr_pde_loss_function = NeuralPDE.build_symbolic_loss_function(eq,indvars,depvars,dict_depvars_input,phi,derivative,integral,chain,initθ,strategy)\n\n:((cord, var\"##θ#529\", phi, derivative, integral, u)->begin\n          begin\n              let (x, t) = (cord[[1], :], cord[[2], :])\n                  derivative.(phi, u, cord, Array{Float32,1}[[0.0, 0.0049215667], [0.0, 0.0049215667]], 2, var\"##θ#529\") .- derivative.(phi, u, cord, Array{Float32,1}[[0.0049215667, 0.0], [0.0049215667, 0.0]], 2, var\"##θ#529\")\n              end\n          end\n      end)\n\njulia> bc_indvars = NeuralPDE.get_variables(bcs,indvars,depvars)\n4-element Array{Array{Any,1},1}:\n [:t]\n [:t]\n [:x]\n [:x]\n\n_bc_loss_functions = [NeuralPDE.build_loss_function(bc,indvars,depvars,\n                                                     phi,derivative,integral,chain,initθ,strategy,\n                                                     bc_indvars = bc_indvar) for (bc,bc_indvar) in zip(bcs,bc_indvars)]\n\njulia> expr_bc_loss_functions = [NeuralPDE.build_symbolic_loss_function(bc,indvars,depvars,dict_depvars_input,\n                                                                        phi,derivative,integral,chain,initθ,strategy,\n                                                                        bc_indvars = bc_indvar) for (bc,bc_indvar) in zip(bcs,bc_indvars)]\n4-element Array{Expr,1}:\n :((cord, var\"##θ#529\", phi, derivative, integral, u)->begin\n          begin\n              let (x, t) = (cord[[1], :], cord[[2], :])\n                  u.(cord, var\"##θ#529\", phi) .- 0.0\n              end\n          end\n      end)\n :((cord, var\"##θ#529\", phi, derivative, integral, u)->begin\n          begin\n              let (x, t) = (cord[[1], :], cord[[2], :])\n                  u.(cord, var\"##θ#529\", phi) .- 0.0\n              end\n          end\n      end)\n :((cord, var\"##θ#529\", phi, derivative, integral, u)->begin\n          begin\n              let (x, t) = (cord[[1], :], cord[[2], :])\n                  u.(cord, var\"##θ#529\", phi) .- (*).(x, (+).(1.0, (*).(-1, x)))\n              end\n          end\n      end)\n :((cord, var\"##θ#529\", phi, derivative, integral, u)->begin\n          begin\n              let (x, t) = (cord[[1], :], cord[[2], :])\n                  derivative.(phi, u, cord, Array{Float32,1}[[0.0, 0.0049215667]], 1, var\"##θ#529\") .- 0.0\n              end\n          end\n      end)\n\ntrain_sets = NeuralPDE.generate_training_sets(domains,dx,[eq],bcs,eltypeθ,indvars,depvars)\npde_train_set,bcs_train_set = train_sets\n\njulia> pde_train_set\n1-element Array{Array{Float32,2},1}:\n [0.1 0.2 … 0.8 0.9; 0.1 0.1 … 1.0 1.0]\n\n\njulia> bcs_train_set\n4-element Array{Array{Float32,2},1}:\n [0.0 0.0 … 0.0 0.0; 0.0 0.1 … 0.9 1.0]\n [1.0 1.0 … 1.0 1.0; 0.0 0.1 … 0.9 1.0]\n [0.0 0.1 … 0.9 1.0; 0.0 0.0 … 0.0 0.0]\n [0.0 0.1 … 0.9 1.0; 0.0 0.0 … 0.0 0.0]\n\n\npde_bounds, bcs_bounds = NeuralPDE.get_bounds(domains,[eq],bcs,eltypeθ,indvars,depvars,NeuralPDE.StochasticTraining(100))\n\njulia> pde_bounds\n1-element Vector{Vector{Any}}:\n [Float32[0.01, 0.99], Float32[0.01, 0.99]]\n\njulia> bcs_bounds\n4-element Vector{Vector{Any}}:\n [0, Float32[0.0, 1.0]]\n [1, Float32[0.0, 1.0]]\n [Float32[0.0, 1.0], 0]\n [Float32[0.0, 1.0], 0]\n\ndiscretization = NeuralPDE.PhysicsInformedNN(chain,strategy)\n\n@named pde_system = PDESystem(eq,bcs,domains,indvars,depvars)\nprob = NeuralPDE.discretize(pde_system,discretization)\n\nexpr_prob = NeuralPDE.symbolic_discretize(pde_system,discretization)\nexpr_pde_loss_function , expr_bc_loss_functions = expr_prob"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}