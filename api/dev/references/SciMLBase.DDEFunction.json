{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"SciMLBase/src/scimlfunctions.jl","docid":"sourcefiles/SciMLBase/src/scimlfunctions.jl"},{"tag":"sourcefile","title":"SciMLBase/src/SciMLBase.jl","docid":"sourcefiles/SciMLBase/src/SciMLBase.jl"},{"tag":"sourcefile","title":"DiffEqFlux/src/neural_de.jl","docid":"sourcefiles/DiffEqFlux/src/neural_de.jl"},{"tag":"sourcefile","title":"SciMLBase/src/problems/dde_problems.jl","docid":"sourcefiles/SciMLBase/src/problems/dde_problems.jl"}],"methods":[{"line":2306,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/scimlfunctions.jl","method_id":"SciMLBase.DDEFunction_1","symbol_id":"SciMLBase.DDEFunction","filedoc":"sourcefiles/SciMLBase/src/scimlfunctions.jl","signature":"DDEFunction(f::DDEFunction; kwargs...)"},{"line":2305,"file":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/src/scimlfunctions.jl","method_id":"SciMLBase.DDEFunction_2","symbol_id":"SciMLBase.DDEFunction","filedoc":"sourcefiles/SciMLBase/src/scimlfunctions.jl","signature":"DDEFunction(f; kwargs...)"}],"name":"DDEFunction","title":"DDEFunction","symbol_id":"SciMLBase.DDEFunction","public":true,"module_id":"SciMLBase"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["DDEFunction <: AbstractDDEFunction"],"type":"node"},{"attributes":{},"tag":"p","children":["A representation of a DDE function ",{"attributes":{},"tag":"code","children":["f"],"type":"node"},", defined by:"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["M \\frac{du}{dt} = f(u,h,p,t)"],"type":"node"},{"attributes":{},"tag":"p","children":["and all of its related functions, such as the Jacobian of ",{"attributes":{},"tag":"code","children":["f"],"type":"node"},", its gradient with respect to time, and more. For all cases, ",{"attributes":{},"tag":"code","children":["u0"],"type":"node"}," is the initial condition, ",{"attributes":{},"tag":"code","children":["p"],"type":"node"}," are the parameters, and ",{"attributes":{},"tag":"code","children":["t"],"type":"node"}," is the independent variable."],"type":"node"},{"attributes":{},"tag":"h2","children":["Constructor"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"CURLY","children":[{"attributes":{"reftype":"symbol","document_id":"references/SciMLBase.DDEFunction"},"tag":"reference","children":["DDEFunction"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["iip"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["recompile"],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["f"],"type":"node"},{"attributes":{},"tag":"PARAMETERS","children":[{"attributes":{},"tag":"SEMICOLON","children":[";"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                 "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["mass_matrix"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["I"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                 "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["analytic"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                 "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["tgrad"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                 "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["jac"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                 "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["jvp"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                 "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["vjp"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                 "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["jac_prototype"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                 "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["sparsity"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["jac_prototype"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                 "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["paramjac"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                 "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["syms"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                 "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["indepsym"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                 "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["colorvec"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Note that only the function ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," itself is required. This function should be given as ",{"attributes":{},"tag":"code","children":["f!(du,u,h,p,t)"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["du = f(u,h,p,t)"],"type":"node"},". See the section on ",{"attributes":{},"tag":"code","children":["iip"],"type":"node"}," for more details on in-place vs out-of-place handling. The histroy function ",{"attributes":{},"tag":"code","children":["h"],"type":"node"}," acts as an interpolator over time, i.e. ",{"attributes":{},"tag":"code","children":["h(t)"],"type":"node"}," with options matching the solution interface, i.e. ",{"attributes":{},"tag":"code","children":["h(t; save_idxs = 2)"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["All of the remaining functions are optional for improving or accelerating  the usage of ",{"attributes":{},"tag":"code","children":["f"],"type":"node"},". These include:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["mass_matrix"],"type":"node"},": the mass matrix ",{"attributes":{},"tag":"code","children":["M"],"type":"node"}," represented in the ODE function. Can be used to determine that the equation is actually a differential-algebraic equation (DAE) if ",{"attributes":{},"tag":"code","children":["M"],"type":"node"}," is singular. Note that in this case special solvers are required, see the DAE solver page for more details: https://diffeq.sciml.ai/stable/solvers/dae_solve/. Must be an AbstractArray or an AbstractSciMLOperator."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["analytic(u0,p,t)"],"type":"node"},": used to pass an analytical solution function for the analytical  solution of the ODE. Generally only used for testing and development of the solvers."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["tgrad(dT,u,h,p,t)"],"type":"node"}," or dT=tgrad(u,p,t): returns ",{"attributes":{},"tag":"math","children":["\\frac{\\partial f(u,p,t)}{\\partial t}"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["jac(J,u,h,p,t)"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["J=jac(u,p,t)"],"type":"node"},": returns ",{"attributes":{},"tag":"math","children":["\\frac{df}{du}"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["jvp(Jv,v,h,u,p,t)"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["Jv=jvp(v,u,p,t)"],"type":"node"},": returns the directional derivative",{"attributes":{},"tag":"math","children":["\\frac{df}{du} v"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["vjp(Jv,v,h,u,p,t)"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["Jv=vjp(v,u,p,t)"],"type":"node"},": returns the adjoint derivative",{"attributes":{},"tag":"math","children":["\\frac{df}{du}^\\ast v"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["jac_prototype"],"type":"node"},": a prototype matrix matching the type that matches the Jacobian. For example, if the Jacobian is tridiagonal, then an appropriately sized ",{"attributes":{},"tag":"code","children":["Tridiagonal"],"type":"node"}," matrix can be used as the prototype and integrators will specialize on this structure where possible. Non-structured sparsity patterns should use a ",{"attributes":{},"tag":"code","children":["SparseMatrixCSC"],"type":"node"}," with a correct sparsity pattern for the Jacobian. The default is ",{"attributes":{},"tag":"code","children":["nothing"],"type":"node"},", which means a dense Jacobian."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["paramjac(pJ,h,u,p,t)"],"type":"node"},": returns the parameter Jacobian ",{"attributes":{},"tag":"math","children":["\\frac{df}{dp}"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["syms"],"type":"node"},": the symbol names for the elements of the equation. This should match ",{"attributes":{},"tag":"code","children":["u0"],"type":"node"}," in size. For example, if ",{"attributes":{},"tag":"code","children":["u0 = [0.0,1.0]"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["syms = [:x, :y]"],"type":"node"},", this will apply a canonical naming to the values, allowing ",{"attributes":{},"tag":"code","children":["sol[:x]"],"type":"node"}," in the solution and automatically naming values in plots."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["indepsym"],"type":"node"},": the canonical naming for the independent variable. Defaults to nothing, which internally uses ",{"attributes":{},"tag":"code","children":["t"],"type":"node"}," as the representation in any plots."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["colorvec"],"type":"node"},": a color vector according to the SparseDiffTools.jl definition for the sparsity pattern of the ",{"attributes":{},"tag":"code","children":["jac_prototype"],"type":"node"},". This specializes the Jacobian construction when using finite differences and automatic differentiation to be computed in an accelerated manner based on the sparsity pattern. Defaults to ",{"attributes":{},"tag":"code","children":["nothing"],"type":"node"},", which means a color vector will be internally computed on demand when required. The cost of this operation is highly dependent on the sparsity pattern."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["iip: In-Place vs Out-Of-Place"],"type":"node"},{"attributes":{},"tag":"p","children":["For more details on this argument, see the ODEFunction documentation."],"type":"node"},{"attributes":{},"tag":"h2","children":["recompile: Controlling Compilation and Specialization"],"type":"node"},{"attributes":{},"tag":"p","children":["For more details on this argument, see the ODEFunction documentation."],"type":"node"},{"attributes":{},"tag":"h2","children":["Fields"],"type":"node"},{"attributes":{},"tag":"p","children":["The fields of the DDEFunction type directly match the names of the inputs."],"type":"node"}],"type":"node"}],"type":"node"}