{"attributes":{"kind":"struct","backlinks":[{"tag":"document","title":"NeuralOperators","docid":"NeuralOperators/index.md"},{"tag":"sourcefile","title":"NeuralOperators/src/model.jl","docid":"sourcefiles/NeuralOperators/src/model.jl"},{"tag":"sourcefile","title":"NeuralOperators/src/operator_kernel.jl","docid":"sourcefiles/NeuralOperators/src/operator_kernel.jl"}],"methods":[{"line":142,"file":"/Users/lorenz/.julia/packages/NeuralOperators/yBMmF/src/operator_kernel.jl","method_id":"NeuralOperators.OperatorKernel_1","symbol_id":"NeuralOperators.OperatorKernel","filedoc":"sourcefiles/NeuralOperators/src/operator_kernel.jl","signature":"NeuralOperators.OperatorKernel(ch::Pair{S, S}, modes::Tuple{Vararg{S, N}}, Transform::Type{<:NeuralOperators.AbstractTransform})"},{"line":142,"file":"/Users/lorenz/.julia/packages/NeuralOperators/yBMmF/src/operator_kernel.jl","method_id":"NeuralOperators.OperatorKernel_2","symbol_id":"NeuralOperators.OperatorKernel","filedoc":"sourcefiles/NeuralOperators/src/operator_kernel.jl","signature":"NeuralOperators.OperatorKernel(ch::Pair{S, S}, modes::Tuple{Vararg{S, N}}, Transform::Type{<:NeuralOperators.AbstractTransform}, σ; permuted)"},{"line":111,"file":"/Users/lorenz/.julia/packages/NeuralOperators/yBMmF/src/operator_kernel.jl","method_id":"NeuralOperators.OperatorKernel_3","symbol_id":"NeuralOperators.OperatorKernel","filedoc":"sourcefiles/NeuralOperators/src/operator_kernel.jl","signature":"NeuralOperators.OperatorKernel(linear::L, conv::C, σ::F)"}],"name":"OperatorKernel","title":"OperatorKernel","symbol_id":"NeuralOperators.OperatorKernel","public":true,"module_id":"NeuralOperators"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["OperatorKernel(ch, modes, σ=identity; permuted=false)\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["Arguments"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["ch"],"type":"node"},": Input and output channel size for spectral convolution, e.g. ",{"attributes":{},"tag":"code","children":["64=>64"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["modes"],"type":"node"},": The Fourier modes to be preserved for spectral convolution."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["σ"],"type":"node"},": Activation function."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["permuted"],"type":"node"},": Whether the dim is permuted. If ",{"attributes":{},"tag":"code","children":["permuted=true"],"type":"node"},", layer accepts data in the order of ",{"attributes":{},"tag":"code","children":["(ch, ..., batch)"],"type":"node"},", otherwise the order is ",{"attributes":{},"tag":"code","children":["(..., ch, batch)"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Example"],"type":"node"},{"attributes":{"lang":"jldoctest"},"tag":"codeblock","children":["julia> OperatorKernel(2=>5, (16, ), FourierTransform)\nOperatorKernel(2 => 5, (16,), FourierTransform, σ=identity, permuted=false)\n\njulia> using Flux\n\njulia> OperatorKernel(2=>5, (16, ), FourierTransform, relu)\nOperatorKernel(2 => 5, (16,), FourierTransform, σ=relu, permuted=false)\n\njulia> OperatorKernel(2=>5, (16, ), FourierTransform, relu, permuted=true)\nOperatorKernel(2 => 5, (16,), FourierTransform, σ=relu, permuted=true)\n"],"type":"node"}],"type":"node"}],"type":"node"}