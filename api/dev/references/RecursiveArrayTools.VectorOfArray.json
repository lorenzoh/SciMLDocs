{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"SciMLBase/src/ensemble/ensemble_solutions.jl","docid":"sourcefiles/SciMLBase/src/ensemble/ensemble_solutions.jl"},{"tag":"sourcefile","title":"RecursiveArrayTools/src/RecursiveArrayTools.jl","docid":"sourcefiles/RecursiveArrayTools/src/RecursiveArrayTools.jl"},{"tag":"document","title":"PoissonRandom.jl: Fast Poisson Random Numbers","docid":"PoissonRandom/index.md"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/concrete_solve.jl","docid":"sourcefiles/DiffEqSensitivity/src/concrete_solve.jl"},{"tag":"sourcefile","title":"SciMLBase/src/solutions/ode_solutions.jl","docid":"sourcefiles/SciMLBase/src/solutions/ode_solutions.jl"},{"tag":"sourcefile","title":"RecursiveArrayTools/src/vector_of_array.jl","docid":"sourcefiles/RecursiveArrayTools/src/vector_of_array.jl"},{"tag":"sourcefile","title":"SciMLBase/src/ensemble/ensemble_analysis.jl","docid":"sourcefiles/SciMLBase/src/ensemble/ensemble_analysis.jl"},{"tag":"sourcefile","title":"SciMLBase/src/solutions/dae_solutions.jl","docid":"sourcefiles/SciMLBase/src/solutions/dae_solutions.jl"},{"tag":"sourcefile","title":"SciMLBase/src/solutions/solution_interface.jl","docid":"sourcefiles/SciMLBase/src/solutions/solution_interface.jl"},{"tag":"sourcefile","title":"RecursiveArrayTools/src/zygote.jl","docid":"sourcefiles/RecursiveArrayTools/src/zygote.jl"}],"methods":[{"line":91,"file":"/Users/lorenz/.julia/packages/RecursiveArrayTools/YoTgv/src/vector_of_array.jl","method_id":"RecursiveArrayTools.VectorOfArray_1","symbol_id":"RecursiveArrayTools.VectorOfArray","filedoc":"sourcefiles/RecursiveArrayTools/src/vector_of_array.jl","signature":"VectorOfArray(vec::AbstractVector{VT})"},{"line":90,"file":"/Users/lorenz/.julia/packages/RecursiveArrayTools/YoTgv/src/vector_of_array.jl","method_id":"RecursiveArrayTools.VectorOfArray_2","symbol_id":"RecursiveArrayTools.VectorOfArray","filedoc":"sourcefiles/RecursiveArrayTools/src/vector_of_array.jl","signature":"VectorOfArray(vec::AbstractVector)"},{"line":88,"file":"/Users/lorenz/.julia/packages/RecursiveArrayTools/YoTgv/src/vector_of_array.jl","method_id":"RecursiveArrayTools.VectorOfArray_3","symbol_id":"RecursiveArrayTools.VectorOfArray","filedoc":"sourcefiles/RecursiveArrayTools/src/vector_of_array.jl","signature":"VectorOfArray(vec::AbstractVector{T}, ::Tuple{Vararg{T, N}} where T)"}],"name":"VectorOfArray","title":"VectorOfArray","symbol_id":"RecursiveArrayTools.VectorOfArray","public":true,"module_id":"RecursiveArrayTools"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/RecursiveArrayTools.VectorOfArray"},"tag":"reference","children":["VectorOfArray"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":[{"attributes":{},"tag":"IDENTIFIER","children":["u"],"type":"node"},{"attributes":{},"tag":"DECLARATION","children":["::"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["AbstractVector"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["A ",{"attributes":{},"tag":"code","children":["VectorOfArray"],"type":"node"}," is an array which has the underlying data structure ",{"attributes":{},"tag":"code","children":["Vector{AbstractArray{T}}"],"type":"node"}," (but, hopefully, concretely typed!). This wrapper over such data structures allows one to lazily act like it's a higher-dimensional vector, and easily convert to different forms. The indexing structure is:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":["A[i] # Returns the ith array in the vector of arrays\nA[j,i] # Returns the jth component in the ith array\nA[j1,...,jN,i] # Returns the (j1,...,jN) component of the ith array"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["which presents itself as a column-major matrix with the columns being the arrays from the vector. The ",{"attributes":{},"tag":"code","children":["AbstractArray"],"type":"node"}," interface is implemented, giving access to ",{"attributes":{},"tag":"code","children":["copy"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["push"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["append!"],"type":"node"},", etc. functions, which act appropriately. Points to note are:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["The length is the number of vectors, or ",{"attributes":{},"tag":"code","children":["length(A.u)"],"type":"node"}," where ",{"attributes":{},"tag":"code","children":["u"],"type":"node"}," is the vector of arrays."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Iteration follows the linear index and goes over the vectors"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Additionally, the ",{"attributes":{},"tag":"code","children":["convert(Array,VA::AbstractVectorOfArray)"],"type":"node"}," function is provided, which transforms the ",{"attributes":{},"tag":"code","children":["VectorOfArray"],"type":"node"}," into a matrix/tensor. Also, ",{"attributes":{},"tag":"code","children":["vecarr_to_vectors(VA::AbstractVectorOfArray)"],"type":"node"}," returns a vector of the series for each component, that is, ",{"attributes":{},"tag":"code","children":["A[i,:]"],"type":"node"}," for each ",{"attributes":{},"tag":"code","children":["i"],"type":"node"},". A plot recipe is provided, which plots the ",{"attributes":{},"tag":"code","children":["A[i,:]"],"type":"node"}," series."],"type":"node"}],"type":"node"}],"type":"node"}