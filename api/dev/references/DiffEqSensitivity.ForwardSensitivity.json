{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"DiffEqSensitivity/src/nilss.jl","docid":"sourcefiles/DiffEqSensitivity/src/nilss.jl"},{"tag":"documentation","title":"ODEForwardSensitivityProblem","docid":"references/DiffEqSensitivity.ODEForwardSensitivityProblem"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/forward_sensitivity.jl","docid":"sourcefiles/DiffEqSensitivity/src/forward_sensitivity.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/DiffEqSensitivity.jl","docid":"sourcefiles/DiffEqSensitivity/src/DiffEqSensitivity.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/sensitivity_algorithms.jl","docid":"sourcefiles/DiffEqSensitivity/src/sensitivity_algorithms.jl"}],"methods":[{"line":59,"file":"/Users/lorenz/.julia/packages/DiffEqSensitivity/GjhZ8/src/sensitivity_algorithms.jl","method_id":"DiffEqSensitivity.ForwardSensitivity_1","symbol_id":"DiffEqSensitivity.ForwardSensitivity","filedoc":"sourcefiles/DiffEqSensitivity/src/sensitivity_algorithms.jl","signature":"DiffEqSensitivity.ForwardSensitivity(; chunk_size, autodiff, diff_type, autojacvec, autojacmat)"}],"name":"ForwardSensitivity","title":"ForwardSensitivity","symbol_id":"DiffEqSensitivity.ForwardSensitivity","public":true,"module_id":"DiffEqSensitivity"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["ForwardSensitivity <: AbstractForwardSensitivityAlgorithm"],"type":"node"},{"attributes":{},"tag":"p","children":["An implementation of continuous forward sensitivity analysis for propagating derivatives by solving the extended ODE. When used within adjoint differentiation (i.e. via Zygote), this will cause forward differentiation of the ",{"attributes":{},"tag":"code","children":["solve"],"type":"node"}," call within the reverse-mode automatic differentiation environment."],"type":"node"},{"attributes":{},"tag":"h2","children":["Constructor"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":["function ForwardSensitivity(;\n                            chunk_size=0,autodiff=true,\n                            diff_type=Val{:central},\n                            autojacvec=autodiff,\n                            autojacmat=false)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Keyword Arguments"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["autodiff"],"type":"node"},": Use automatic differentiation in the internal sensitivity algorithm computations. Default is ",{"attributes":{},"tag":"code","children":["true"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["chunk_size"],"type":"node"},": Chunk size for forward mode differentiation if full Jacobians are built (",{"attributes":{},"tag":"code","children":["autojacvec=false"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["autodiff=true"],"type":"node"},"). Default is ",{"attributes":{},"tag":"code","children":["0"],"type":"node"}," for automatic choice of chunk size."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["autojacvec"],"type":"node"},": Calculate the Jacobian-vector product via automatic differentiation with special seeding."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["diff_type"],"type":"node"},": The method used by FiniteDiff.jl for constructing the Jacobian if the full Jacobian is required with ",{"attributes":{},"tag":"code","children":["autodiff=false"],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Further details:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If ",{"attributes":{},"tag":"code","children":["autodiff=true"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["autojacvec=true"],"type":"node"},", then the one chunk ",{"attributes":{},"tag":"code","children":["J*v"],"type":"node"}," forward-mode directional derivative calculation trick is used to compute the product without constructing the Jacobian (via ForwardDiff.jl)."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If ",{"attributes":{},"tag":"code","children":["autodiff=false"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["autojacvec=true"],"type":"node"},", then the numerical direction derivative trick ",{"attributes":{},"tag":"code","children":["(f(x+epsilon*v)-f(x))/epsilon"],"type":"node"}," is used to compute ",{"attributes":{},"tag":"code","children":["J*v"],"type":"node"}," without constructing the Jacobian."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If ",{"attributes":{},"tag":"code","children":["autodiff=true"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["autojacvec=false"],"type":"node"},", then the Jacobian is constructed via chunked forward-mode automatic differentiation (via ForwardDiff.jl)."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If ",{"attributes":{},"tag":"code","children":["autodiff=false"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["autojacvec=false"],"type":"node"},", then the Jacobian is constructed via finite differences via FiniteDiff.jl."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["SciMLProblem Support"],"type":"node"},{"attributes":{},"tag":"p","children":["This ",{"attributes":{},"tag":"code","children":["sensealg"],"type":"node"}," only supports ",{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"},"s without callbacks (events)."],"type":"node"}],"type":"node"}],"type":"node"}