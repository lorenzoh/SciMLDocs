{"attributes":{"kind":"struct","backlinks":[{"tag":"document","title":"Parameter Estimation on Highly Stiff Systems","docid":"DiffEqSensitivity/ode_fitting/stiff_ode_fit.md"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/quadrature_adjoint.jl","docid":"sourcefiles/DiffEqSensitivity/src/quadrature_adjoint.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/concrete_solve.jl","docid":"sourcefiles/DiffEqSensitivity/src/concrete_solve.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/adjoint_common.jl","docid":"sourcefiles/DiffEqSensitivity/src/adjoint_common.jl"},{"tag":"document","title":"[Differentiating an ODE Solution with Automatic Differentiation]( auto_diff)","docid":"DiffEqSensitivity/ad_examples/differentiating_ode.md"},{"tag":"document","title":"Benchmarks","docid":"DiffEqSensitivity/Benchmark.md"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/callback_tracking.jl","docid":"sourcefiles/DiffEqSensitivity/src/callback_tracking.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/DiffEqSensitivity.jl","docid":"sourcefiles/DiffEqSensitivity/src/DiffEqSensitivity.jl"},{"tag":"sourcefile","title":"DiffEqSensitivity/src/sensitivity_algorithms.jl","docid":"sourcefiles/DiffEqSensitivity/src/sensitivity_algorithms.jl"}],"methods":[{"line":451,"file":"/Users/lorenz/.julia/packages/DiffEqSensitivity/GjhZ8/src/sensitivity_algorithms.jl","method_id":"DiffEqSensitivity.QuadratureAdjoint_1","symbol_id":"DiffEqSensitivity.QuadratureAdjoint","filedoc":"sourcefiles/DiffEqSensitivity/src/sensitivity_algorithms.jl","signature":"DiffEqSensitivity.QuadratureAdjoint(; chunk_size, autodiff, diff_type, autojacvec, abstol, reltol, compile)"}],"name":"QuadratureAdjoint","title":"QuadratureAdjoint","symbol_id":"DiffEqSensitivity.QuadratureAdjoint","public":true,"module_id":"DiffEqSensitivity"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":["QuadratureAdjoint <: AbstractAdjointSensitivityAlgorithm"],"type":"node"},{"attributes":{},"tag":"p","children":["An implementation of adjoint sensitivity analysis which develops a full continuous solution of the reverse solve in order to perform a post-ODE quadrature. This method requires the the dense solution and will ignore saving arguments during the gradient calculation. The tolerances in the constructor control the inner quadrature. The inner quadrature uses a ReverseDiff vjp if autojacvec, and ",{"attributes":{},"tag":"code","children":["compile=false"],"type":"node"}," by default but can compile the tape under the same circumstances as ",{"attributes":{},"tag":"code","children":["ReverseDiffVJP"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["This method is O(n^3 + p) for stiff / implicit equations (as opposed to the O((n+p)^3) scaling of BacksolveAdjoint and InterpolatingAdjoint), and thus is much more compute efficient. However, it requires holding a dense reverse pass and is thus memory intensive."],"type":"node"},{"attributes":{},"tag":"h2","children":["Constructor"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":["function QuadratureAdjoint(;chunk_size=0,autodiff=true,\n                            diff_type=Val{:central},\n                            autojacvec=autodiff,abstol=1e-6,\n                            reltol=1e-3,compile=false)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Keyword Arguments"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["autodiff"],"type":"node"},": Use automatic differentiation for constructing the Jacobian if the Jacobian needs to be constructed.  Defaults to ",{"attributes":{},"tag":"code","children":["true"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["chunk_size"],"type":"node"},": Chunk size for forward-mode differentiation if full Jacobians are built (",{"attributes":{},"tag":"code","children":["autojacvec=false"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["autodiff=true"],"type":"node"},"). Default is ",{"attributes":{},"tag":"code","children":["0"],"type":"node"}," for automatic choice of chunk size."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["diff_type"],"type":"node"},": The method used by FiniteDiff.jl for constructing the Jacobian if the full Jacobian is required with ",{"attributes":{},"tag":"code","children":["autodiff=false"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["autojacvec"],"type":"node"},": Calculate the vector-Jacobian product (",{"attributes":{},"tag":"code","children":["J'*v"],"type":"node"},") via automatic differentiation with special seeding. The default is ",{"attributes":{},"tag":"code","children":["true"],"type":"node"},". The total set of choices are:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["false"],"type":"node"},": the Jacobian is constructed via FiniteDiff.jl"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["true"],"type":"node"},": the Jacobian is constructed via ForwardDiff.jl"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["TrackerVJP"],"type":"node"},": Uses Tracker.jl for the vjp."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["ZygoteVJP"],"type":"node"},": Uses Zygote.jl for the vjp."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["EnzymeVJP"],"type":"node"},": Uses Enzyme.jl for the vjp."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["ReverseDiffVJP(compile=false)"],"type":"node"},": Uses ReverseDiff.jl for the vjp. ",{"attributes":{},"tag":"code","children":["compile"],"type":"node"}," is a boolean for whether to precompile the tape, which should only be done if there are no branches (",{"attributes":{},"tag":"code","children":["if"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["while"],"type":"node"}," statements) in the ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," function."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["abstol"],"type":"node"},": absolute tolerance for the quadrature calculation"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["reltol"],"type":"node"},": relative tolerance for the quadrature calculation"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["compile"],"type":"node"},": whether to compile the vjp calculation for the integrand calculation. See ",{"attributes":{},"tag":"code","children":["ReverseDiffVJP"],"type":"node"}," for more details."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["For more details on the vjp choices, please consult the sensitivity algorithms documentation page or the docstrings of the vjp types."],"type":"node"},{"attributes":{},"tag":"h2","children":["SciMLProblem Support"],"type":"node"},{"attributes":{},"tag":"p","children":["This ",{"attributes":{},"tag":"code","children":["sensealg"],"type":"node"}," only supports ",{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"},"s. This ",{"attributes":{},"tag":"code","children":["sensealg"],"type":"node"}," supports events (callbacks)."],"type":"node"},{"attributes":{},"tag":"h2","children":["References"],"type":"node"},{"attributes":{},"tag":"p","children":["Rackauckas, C. and Ma, Y. and Martensen, J. and Warner, C. and Zubov, K. and Supekar, R. and Skinner, D. and Ramadhana, A. and Edelman, A., Universal Differential Equations for Scientific Machine Learning,\tarXiv:2001.04385"],"type":"node"},{"attributes":{},"tag":"p","children":["Hindmarsh, A. C. and Brown, P. N. and Grant, K. E. and Lee, S. L. and Serban, R. and Shumaker, D. E. and Woodward, C. S., SUNDIALS: Suite of nonlinear and differential/algebraic equation solvers, ACM Transactions on Mathematical Software (TOMS), 31, pp:363â€“396 (2005)"],"type":"node"},{"attributes":{},"tag":"p","children":["Rackauckas, C. and Ma, Y. and Dixit, V. and Guo, X. and Innes, M. and Revels, J. and Nyberg, J. and Ivaturi, V., A comparison of automatic differentiation and continuous sensitivity analysis for derivatives of differential equation solutions, arXiv:1812.01892"],"type":"node"},{"attributes":{},"tag":"p","children":["Kim, S., Ji, W., Deng, S., Ma, Y., & Rackauckas, C. (2021). Stiff neural ordinary differential equations. Chaos: An Interdisciplinary Journal of Nonlinear Science, 31(9), 093122."],"type":"node"}],"type":"node"}],"type":"node"}