{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"NeuralOperators/src/DeepONet.jl","docid":"sourcefiles/NeuralOperators/src/DeepONet.jl"},{"tag":"sourcefile","title":"NeuralOperators/src/NeuralOperators.jl","docid":"sourcefiles/NeuralOperators/src/NeuralOperators.jl"},{"tag":"document","title":"NeuralOperators","docid":"NeuralOperators/index.md"}],"methods":[{"line":86,"file":"/Users/lorenz/.julia/packages/NeuralOperators/yBMmF/src/DeepONet.jl","method_id":"NeuralOperators.DeepONet_1","symbol_id":"NeuralOperators.DeepONet","filedoc":"sourcefiles/NeuralOperators/src/DeepONet.jl","signature":"NeuralOperators.DeepONet(architecture_branch::Tuple, architecture_trunk::Tuple)"},{"line":86,"file":"/Users/lorenz/.julia/packages/NeuralOperators/yBMmF/src/DeepONet.jl","method_id":"NeuralOperators.DeepONet_2","symbol_id":"NeuralOperators.DeepONet","filedoc":"sourcefiles/NeuralOperators/src/DeepONet.jl","signature":"NeuralOperators.DeepONet(architecture_branch::Tuple, architecture_trunk::Tuple, act_branch)"},{"line":86,"file":"/Users/lorenz/.julia/packages/NeuralOperators/yBMmF/src/DeepONet.jl","method_id":"NeuralOperators.DeepONet_3","symbol_id":"NeuralOperators.DeepONet","filedoc":"sourcefiles/NeuralOperators/src/DeepONet.jl","signature":"NeuralOperators.DeepONet(architecture_branch::Tuple, architecture_trunk::Tuple, act_branch, act_trunk; init_branch, init_trunk, bias_branch, bias_trunk)"},{"line":81,"file":"/Users/lorenz/.julia/packages/NeuralOperators/yBMmF/src/DeepONet.jl","method_id":"NeuralOperators.DeepONet_4","symbol_id":"NeuralOperators.DeepONet","filedoc":"sourcefiles/NeuralOperators/src/DeepONet.jl","signature":"NeuralOperators.DeepONet(branch_net::T1, trunk_net::T2)"}],"name":"DeepONet","title":"DeepONet","symbol_id":"NeuralOperators.DeepONet","public":true,"module_id":"NeuralOperators"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["DeepONet(architecture_branch::Tuple, architecture_trunk::Tuple, act_branch = identity, act_trunk = identity; init_branch = Flux.glorot_uniform, init_trunk = Flux.glorot_uniform, bias_branch=true, bias_trunk=true)"],"type":"node"}," ",{"attributes":{},"tag":"code","children":["DeepONet(branch_net::Flux.Chain, trunk_net::Flux.Chain)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Create an (unstacked) DeepONet architecture as proposed by Lu et al. arXiv:1910.03193"],"type":"node"},{"attributes":{},"tag":"p","children":["The model works as follows:"],"type":"node"},{"attributes":{},"tag":"p","children":["x --- branch -- | -⊠--u- | y --- trunk ---"],"type":"node"},{"attributes":{},"tag":"p","children":["Where ",{"attributes":{},"tag":"code","children":["x"],"type":"node"}," represents the input function, discretely evaluated at its respective sensors. So the ipnut is of shape [m] for one instance or [m x b] for a training set. ",{"attributes":{},"tag":"code","children":["y"],"type":"node"}," are the probing locations for the operator to be trained. It has shape [N x n] for N different variables in the PDE (i.e. spatial and temporal coordinates) with each n distinct evaluation points. ",{"attributes":{},"tag":"code","children":["u"],"type":"node"}," is the solution of the queried instance of the PDE, given by the specific choice of parameters."],"type":"node"},{"attributes":{},"tag":"p","children":["Both inputs ",{"attributes":{},"tag":"code","children":["x"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["y"],"type":"node"}," are multiplied together via dot product Σᵢ bᵢⱼ tᵢₖ."],"type":"node"},{"attributes":{},"tag":"p","children":["You can set up this architecture in two ways:"],"type":"node"},{"attributes":{},"tag":"ol","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["By Specifying the architecture and all its parameters as given above. This always creates ",{"attributes":{},"tag":"code","children":["Dense"],"type":"node"}," layers for the branch and trunk net and corresponds to the DeepONet proposed by Lu et al."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["By passing two architectures in the form of two Chain structs directly. Do this if you want more flexibility and e.g. use an RNN or CNN instead of simple ",{"attributes":{},"tag":"code","children":["Dense"],"type":"node"}," layers."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Strictly speaking, DeepONet does not imply either of the branch or trunk net to be a simple DNN. Usually though, this is the case which is why it's treated as the default case here."],"type":"node"},{"attributes":{},"tag":"h1","children":["Example"],"type":"node"},{"attributes":{},"tag":"p","children":["Consider a transient 1D advection problem ∂ₜu + u ⋅ ∇u = 0, with an IC u(x,0) = g(x). We are given several (b = 200) instances of the IC, discretized at 50 points each and want to query the solution for 100 different locations and times [0;1]."],"type":"node"},{"attributes":{},"tag":"p","children":["That makes the branch input of shape [50 x 200] and the trunk input of shape [2 x 100]. So the input for the branch net is 50 and 100 for the trunk net."],"type":"node"},{"attributes":{},"tag":"h1","children":["Usage"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":["julia> model = DeepONet((32,64,72), (24,64,72))\nDeepONet with\nbranch net: (Chain(Dense(32, 64), Dense(64, 72)))\nTrunk net: (Chain(Dense(24, 64), Dense(64, 72)))\n\njulia> model = DeepONet((32,64,72), (24,64,72), σ, tanh; init_branch=Flux.glorot_normal, bias_trunk=false)\nDeepONet with\nbranch net: (Chain(Dense(32, 64, σ), Dense(64, 72, σ)))\nTrunk net: (Chain(Dense(24, 64, tanh; bias=false), Dense(64, 72, tanh; bias=false)))\n\njulia> branch = Chain(Dense(2,128),Dense(128,64),Dense(64,72))\nChain(\n  Dense(2, 128),                        # 384 parameters\n  Dense(128, 64),                       # 8_256 parameters\n  Dense(64, 72),                        # 4_680 parameters\n)                   # Total: 6 arrays, 13_320 parameters, 52.406 KiB.\n\njulia> trunk = Chain(Dense(1,24),Dense(24,72))\nChain(\n  Dense(1, 24),                         # 48 parameters\n  Dense(24, 72),                        # 1_800 parameters\n)                   # Total: 4 arrays, 1_848 parameters, 7.469 KiB.\n\njulia> model = DeepONet(branch,trunk)\nDeepONet with\nbranch net: (Chain(Dense(2, 128), Dense(128, 64), Dense(64, 72)))\nTrunk net: (Chain(Dense(1, 24), Dense(24, 72)))"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}