{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"DiffEqNoiseProcess/src/noise_interfaces/simple_noise_process_interface.jl","docid":"sourcefiles/DiffEqNoiseProcess/src/noise_interfaces/simple_noise_process_interface.jl"},{"tag":"sourcefile","title":"DiffEqNoiseProcess/src/DiffEqNoiseProcess.jl","docid":"sourcefiles/DiffEqNoiseProcess/src/DiffEqNoiseProcess.jl"},{"tag":"sourcefile","title":"DiffEqNoiseProcess/src/types.jl","docid":"sourcefiles/DiffEqNoiseProcess/src/types.jl"},{"tag":"sourcefile","title":"DiffEqNoiseProcess/src/wiener.jl","docid":"sourcefiles/DiffEqNoiseProcess/src/wiener.jl"}],"methods":[{"line":303,"file":"/Users/lorenz/.julia/packages/DiffEqNoiseProcess/iWugD/src/types.jl","method_id":"DiffEqNoiseProcess.SimpleNoiseProcess_1","symbol_id":"DiffEqNoiseProcess.SimpleNoiseProcess","filedoc":"sourcefiles/DiffEqNoiseProcess/src/types.jl","signature":"SimpleNoiseProcess(t0, W0, Z0, dist, bridge; kwargs...)"}],"name":"SimpleNoiseProcess","title":"SimpleNoiseProcess","symbol_id":"DiffEqNoiseProcess.SimpleNoiseProcess","public":true,"module_id":"DiffEqNoiseProcess"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":["mutable struct SimpleNoiseProcess{T,N,Tt,T2,T3,ZType,F,F2,inplace,RNGType} <: AbstractNoiseProcess{T,N,Vector{T2},inplace}"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Like ",{"attributes":{},"tag":"code","children":["NoiseProcess"],"type":"node"}," but without support for adaptivity. This makes it lightweight and slightly faster."],"type":"node"},{"attributes":{"class":"warn"},"tag":"admonition","children":[{"attributes":{},"tag":"admonitiontitle","children":["Warn"],"type":"node"},{"attributes":{},"tag":"admonitionbody","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["SimpleNoiseProcess"],"type":"node"}," should not be used with adaptive SDE solvers as it will lead to incorrect results."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":["function SimpleNoiseProcess{iip}(t0,W0,Z0,dist,bridge;\n                                 save_everystep=true,\n                                 rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)),\n                                 reset = true, reseed = true) where iip"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["t0"],"type":"node"}," is the first timepoint"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["W0"],"type":"node"}," is the first value of the process."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["Z0"],"type":"node"}," is the first value of the pseudo-process. This is necessary for higher order algorithms. If it's not needed, set to ",{"attributes":{},"tag":"code","children":["nothing"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["dist"],"type":"node"}," the distribution for the steps over time."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["bridge"],"type":"node"}," the bridging distribution. Optional, but required for adaptivity and interpolating at new values."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["save_everystep"],"type":"node"}," whether to save every step of the Brownian timeseries."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["rng"],"type":"node"}," the local RNG used for generating the random numbers."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["reset"],"type":"node"}," whether to reset the process with each solve."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["reseed"],"type":"node"}," whether to reseed the process with each solve."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}