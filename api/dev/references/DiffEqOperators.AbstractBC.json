{"attributes":{"kind":"struct","backlinks":[{"tag":"sourcefile","title":"DiffEqOperators/src/derivative_operators/concretization.jl","docid":"sourcefiles/DiffEqOperators/src/derivative_operators/concretization.jl"},{"tag":"sourcefile","title":"DiffEqOperators/src/docstrings.jl","docid":"sourcefiles/DiffEqOperators/src/docstrings.jl"},{"tag":"sourcefile","title":"DiffEqOperators/src/derivative_operators/multi_dim_bc_operators.jl","docid":"sourcefiles/DiffEqOperators/src/derivative_operators/multi_dim_bc_operators.jl"},{"tag":"sourcefile","title":"DiffEqOperators/src/derivative_operators/ghost_derivative_operator.jl","docid":"sourcefiles/DiffEqOperators/src/derivative_operators/ghost_derivative_operator.jl"},{"tag":"sourcefile","title":"DiffEqOperators/src/derivative_operators/bc_operators.jl","docid":"sourcefiles/DiffEqOperators/src/derivative_operators/bc_operators.jl"}],"methods":[],"name":"AbstractBC","title":"AbstractBC","symbol_id":"DiffEqOperators.AbstractBC","public":false,"module_id":"DiffEqOperators"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":""},"tag":"codeblock","children":["abstract type AbstractBC{T}\n"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["T"],"type":"node"}," is the range type of the discretized function."],"type":"node"},{"attributes":{},"tag":"p","children":["Boundary condition operators extrapolate the discretized function as illustrated in the README, adding a ghost node at each end such that an interpolated polynomial satisfies the boundary condition."],"type":"node"},{"attributes":{},"tag":"p","children":["Some of these are affine operators with a constant term, not linear operators, so using ",{"attributes":{},"tag":"code","children":["*"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["\\"],"type":"node"}," is a minor abuse of notation. For example, when there is a non-zero Dirichlet boundary value, the value at the ghost node is constant, and does not scale proportional to the interior function values. Because boundary condition operators are not linear, they can not be concretized as matrices."],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["GhostDerivativeOperator"],"type":"node"}," somehow concretizes as a pair of matrices."],"type":"node"},{"attributes":{},"tag":"p","children":["The implementation of ",{"attributes":{},"tag":"code","children":["*(::AffineBC, ::Vector)"],"type":"node"}," returns a ",{"attributes":{},"tag":"code","children":["BoundaryPaddedVector"],"type":"node"},". This is a structure that stores the ghost values separately from the original vector. Presumably, this is to avoid allocations, although the ",{"attributes":{},"tag":"code","children":["mul!"],"type":"node"}," method for ",{"attributes":{},"tag":"code","children":["GhostDerivativeOperator"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["Matrix"],"type":"node"}," method allocates a new ",{"attributes":{},"tag":"code","children":["BoundaryPaddedArray"],"type":"node"}," for each column."],"type":"node"},{"attributes":{},"tag":"p","children":["In higher-dimensional cases, it might return a ",{"attributes":{},"tag":"code","children":["BoundaryPaddedArray"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["The ",{"attributes":{},"tag":"code","children":["*"],"type":"node"}," operator for a derivative multiplying a boundary condition packages them up as a ",{"attributes":{},"tag":"code","children":["GhostDerivativeOperator"],"type":"node"},". This cannot return a sparse matrix, because the operator is affine (not linear). When a vector is multiplied by one of those, it uses ",{"attributes":{},"tag":"code","children":["*(::AbstractBC, ::AbstractVector)"],"type":"node"}," to pad with ghost nodes, then ",{"attributes":{},"tag":"code","children":["mul!(::DerivativeOperator, ::AbstractVector)"],"type":"node"}," evaluates the derivative."],"type":"node"},{"attributes":{},"tag":"p","children":["See also: ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["DerivativeOperator"],"type":"node"}],"type":"node"},", ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["PeriodicBC"],"type":"node"}],"type":"node"}," ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["NeumannBC"],"type":"node"}],"type":"node"},", ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["DirichletBC"],"type":"node"}],"type":"node"},", ",{"attributes":{"reftype":"document","href":"@ref","title":"","document_id":"references/@ref"},"tag":"reference","children":[{"attributes":{},"tag":"code","children":["RobinBC"],"type":"node"}],"type":"node"},"."],"type":"node"}],"type":"node"}],"type":"node"}