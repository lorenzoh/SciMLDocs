{"attributes":{"kind":"function","backlinks":[{"tag":"sourcefile","title":"PolyChaos/src/polynomial_chaos.jl","docid":"sourcefiles/PolyChaos/src/polynomial_chaos.jl"},{"tag":"sourcefile","title":"PolyChaos/src/tensor.jl","docid":"sourcefiles/PolyChaos/src/tensor.jl"},{"tag":"sourcefile","title":"PolyChaos/src/scalar_product.jl","docid":"sourcefiles/PolyChaos/src/scalar_product.jl"}],"methods":[{"line":4,"file":"/Users/lorenz/.julia/packages/PolyChaos/THVqe/src/scalar_product.jl","method_id":"PolyChaos.computeSP_1","symbol_id":"PolyChaos.computeSP","filedoc":"sourcefiles/PolyChaos/src/scalar_product.jl","signature":"computeSP(a_::AbstractVector{<:Int64}, α::AbstractVector{<:AbstractVector{<:Real}}, β::AbstractVector{<:AbstractVector{<:Real}}, nodes::AbstractVector{<:AbstractVector{<:Real}}, weights::AbstractVector{<:AbstractVector{<:Real}}, ind::Matrix{<:Int64}; issymmetric, zerotol)"},{"line":39,"file":"/Users/lorenz/.julia/packages/PolyChaos/THVqe/src/scalar_product.jl","method_id":"PolyChaos.computeSP_2","symbol_id":"PolyChaos.computeSP","filedoc":"sourcefiles/PolyChaos/src/scalar_product.jl","signature":"computeSP(a::AbstractVector{<:Int64}, op::AbstractVector, ind::Matrix{<:Int64})"},{"line":45,"file":"/Users/lorenz/.julia/packages/PolyChaos/THVqe/src/scalar_product.jl","method_id":"PolyChaos.computeSP_3","symbol_id":"PolyChaos.computeSP","filedoc":"sourcefiles/PolyChaos/src/scalar_product.jl","signature":"computeSP(a::AbstractVector{<:Int64}, mop::PolyChaos.MultiOrthoPoly)"},{"line":86,"file":"/Users/lorenz/.julia/packages/PolyChaos/THVqe/src/scalar_product.jl","method_id":"PolyChaos.computeSP_4","symbol_id":"PolyChaos.computeSP","filedoc":"sourcefiles/PolyChaos/src/scalar_product.jl","signature":"computeSP(a_::AbstractVector{<:Int64}, α::AbstractVector{<:Real}, β::AbstractVector{<:Real}, nodes::AbstractVector{<:Real}, weights::AbstractVector{<:Real}; issymmetric)"},{"line":118,"file":"/Users/lorenz/.julia/packages/PolyChaos/THVqe/src/scalar_product.jl","method_id":"PolyChaos.computeSP_5","symbol_id":"PolyChaos.computeSP","filedoc":"sourcefiles/PolyChaos/src/scalar_product.jl","signature":"computeSP(a::AbstractVector{<:Int64}, op::PolyChaos.AbstractOrthoPoly)"}],"name":"computeSP","title":"computeSP","symbol_id":"PolyChaos.computeSP","public":true,"module_id":"PolyChaos"},"tag":"documentation","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"strong","children":["Univariate"],"type":"node"}],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["computeSP(a::AbstractVector{<:Int},α::AbstractVector{<:Real},β::AbstractVector{<:Real},nodes::AbstractVector{<:Real},weights::AbstractVector{<:Real};issymmetric::Bool=false)\ncomputeSP(a::AbstractVector{<:Int},op::AbstractOrthoPoly;issymmetric=issymmetric(op))\n"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"strong","children":["Multivariate"],"type":"node"}],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["computeSP( a::AbstractVector{<:Int},\n           α::AbstractVector{<:AbstractVector{<:Real}},β::AbstractVector{<:AbstractVector{<:Real}},\n           nodes::AbstractVector{<:AbstractVector{<:Real}},weights::AbstractVector{<:AbstractVector{<:Real}},\n           ind::Matrix{<:Int};\n           issymmetric::BitArray=falses(length(α)))\ncomputeSP(a::AbstractVector{<:Int},op::AbstractVector,ind::Matrix{<:Int})\ncomputeSP(a::AbstractVector{<:Int},mOP::MultiOrthoPoly)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Computes the scalar product"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\langle \\phi_{a_1},\\phi_{a_2},\\cdots,\\phi_{a_n} \\rangle,"],"type":"node"},{"attributes":{},"tag":"p","children":["where ",{"attributes":{},"tag":"code","children":["n = length(a)"],"type":"node"},". This requires to provide the recurrence coefficients ",{"attributes":{},"tag":"code","children":["(α,β)"],"type":"node"}," and the quadrature rule ",{"attributes":{},"tag":"code","children":["(nodes,weights)"],"type":"node"},", as well as the multi-index ",{"attributes":{},"tag":"code","children":["ind"],"type":"node"},". If provided via the keyword ",{"attributes":{},"tag":"code","children":["issymmetric"],"type":"node"},", symmetry of the weight function is exploited. All computations of the multivariate scalar products resort back to efficient computations of the univariate scalar products. Mathematically, this follows from Fubini's theorem."],"type":"node"},{"attributes":{},"tag":"p","children":["The function is dispatched to facilitate its use with ",{"attributes":{},"tag":"code","children":["AbstractOrthoPoly"],"type":"node"}," and its quadrature rule ",{"attributes":{},"tag":"code","children":["Quad"],"type":"node"},"."],"type":"node"},{"attributes":{"class":"note"},"tag":"admonition","children":[{"attributes":{},"tag":"admonitiontitle","children":["Note"],"type":"node"},{"attributes":{},"tag":"admonitionbody","children":[{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Zero entries of ",{"attributes":{},"tag":"math","children":["a"],"type":"node"}," are removed automatically to simplify computations, which follows from"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\langle \\phi_i, \\phi_j, \\phi_0,\\cdots,\\phi_0 \\rangle = \\langle \\phi_i, \\phi_j \\rangle,"],"type":"node"},{"attributes":{},"tag":"p","children":["because ",{"attributes":{},"tag":"code","children":["\\phi_0 = 1"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["It is checked whether enough quadrature points are supplied to solve the integral exactly."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}