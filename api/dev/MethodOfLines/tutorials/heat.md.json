{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/MethodOfLines/MxvKV/docs/src/tutorials/heat.md","title":"[Solving the Heat Equation]( heat)"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["[Solving the Heat Equation](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," heat)"],"type":"node"},{"attributes":{},"tag":"p","children":["In this tutorial we will use the symbolic interface to solve the heat equation."],"type":"node"},{"attributes":{},"tag":"h3","children":["Dirichlet boundary conditions"],"type":"node"},{"attributes":{"lang":"@example heatd"},"tag":"codeblock","children":["using OrdinaryDiffEq, ModelingToolkit, MethodOfLines, DomainSets\n# Method of Manufactured Solutions: exact solution\nu_exact = (x,t) -> exp.(-t) * cos.(x)\n\n# Parameters, variables, and derivatives\n@parameters t x\n@variables u(..)\nDt = Differential(t)\nDxx = Differential(x)^2\n\n# 1D PDE and boundary conditions\neq  = Dt(u(t, x)) ~ Dxx(u(t, x))\nbcs = [u(0, x) ~ cos(x),\n        u(t, 0) ~ exp(-t),\n        u(t, 1) ~ exp(-t) * cos(1)]\n\n# Space and time domains\ndomains = [t ∈ Interval(0.0, 1.0),\n           x ∈ Interval(0.0, 1.0)]\n\n# PDE system\n@named pdesys = PDESystem(eq, bcs, domains, [t, x], [u(t, x)])\n\n# Method of lines discretization\ndx = 0.1\norder = 2\ndiscretization = MOLFiniteDifference([x => dx], t)\n\n# Convert the PDE problem into an ODE problem\nprob = discretize(pdesys,discretization)\n\n# Solve ODE problem\nusing OrdinaryDiffEq\nsol = solve(prob, Tsit5(), saveat=0.2)\n\n# Plot results and compare with exact solution\ngrid = get_discrete(pdesys, discretization)\ndiscrete_x = grid[x]\ndiscrete_t = sol[t]\n\nusing Plots\nplt = plot()\n\nfor i in 1:length(discrete_t)\n    plot!(discrete_x, map(d -> sol[d][i], grid[u(t, x)]), label=\"Numerical, t=$(discrete_t[i])\")\n    scatter!(discrete_x, u_exact(x, discrete_t[i]), label=\"Exact, t=$(discrete_t[i])\")\nend\ndisplay(plt)\nsavefig(\"plot.png\")\n"],"type":"node"},{"attributes":{},"tag":"h3","children":["Neumann boundary conditions"],"type":"node"},{"attributes":{"lang":"@example heatn"},"tag":"codeblock","children":["using OrdinaryDiffEq, ModelingToolkit, MethodOfLines, DomainSets\n# Method of Manufactured Solutions: exact solution\nu_exact = (x,t) -> exp.(-t) * cos.(x)\n\n# Parameters, variables, and derivatives\n@parameters t x\n@variables u(..)\nDt = Differential(t)\nDx = Differential(x)\nDxx = Differential(x)^2\n\n# 1D PDE and boundary conditions\neq  = Dt(u(t, x)) ~ Dxx(u(t, x))\nbcs = [u(0, x) ~ cos(x),\n        Dx(u(t, 0)) ~ 0.0,\n        Dx(u(t, 1)) ~ -exp(-t) * sin(1)]\n\n# Space and time domains\ndomains = [t ∈ Interval(0.0, 1.0),\n        x ∈ Interval(0.0, 1.0)]\n\n# PDE system\n@named pdesys = PDESystem(eq, bcs, domains,[t, x],[u(t, x)])\n\n# Method of lines discretization\n# Need a small dx here for accuracy\ndx = 0.01\norder = 2\ndiscretization = MOLFiniteDifference([x => dx],t)\n\n# Convert the PDE problem into an ODE problem\nprob = discretize(pdesys, discretization)\n\n# Solve ODE problem\nusing OrdinaryDiffEq\nsol = solve(prob, Tsit5(), saveat=0.2)\n\n# Plot results and compare with exact solution\ngrid = get_discrete(pdesys, discretization)\ndiscrete_x = grid[x]\ndiscrete_t = sol[t]\n\nusing Plots\nplt = plot()\n\nfor i in 1:length(discrete_t)\n    plot!(discrete_x, map(d -> sol[d][i], grid[u(t, x)]), label=\"Numerical, t=$(discrete_t[i])\")\n    scatter!(discrete_x, u_exact(x, discrete_t[i]), label=\"Exact, t=$(discrete_t[i])\")\nend\ndisplay(plt)\nsavefig(\"plot.png\")\n"],"type":"node"},{"attributes":{},"tag":"h3","children":["Robin boundary conditions"],"type":"node"},{"attributes":{"lang":"@example heatr"},"tag":"codeblock","children":["using ModelingToolkit, MethodOfLines, DomainSets, OrdinaryDiffEq\n# Method of Manufactured Solutions\nu_exact = (x,t) -> exp.(-t) * sin.(x)\n\n# Parameters, variables, and derivatives\n@parameters t x\n@variables u(..)\nDt = Differential(t)\nDx = Differential(x)\nDxx = Differential(x)^2\n\n# 1D PDE and boundary conditions\neq  = Dt(u(t, x)) ~ Dxx(u(t, x))\nbcs = [u(0, x) ~ sin(x),\n        u(t, -1.0) + 3Dx(u(t, -1.0)) ~ exp(-t) * (sin(-1.0) + 3cos(-1.0)),\n        u(t, 1.0) + Dx(u(t, 1.0)) ~ exp(-t) * (sin(1.0) + cos(1.0))]\n\n# Space and time domains\ndomains = [t ∈ Interval(0.0, 1.0),\n        x ∈ Interval(-1.0, 1.0)]\n\n# PDE system\n@named pdesys = PDESystem(eq, bcs, domains, [t, x], [u(t, x)])\n\n# Method of lines discretization\n# Need a small dx here for accuracy\ndx = 0.05\norder = 2\ndiscretization = MOLFiniteDifference([x => dx], t)\n\n# Convert the PDE problem into an ODE problem\nprob = discretize(pdesys, discretization)\n\n# Solve ODE problem\nusing OrdinaryDiffEq\nsol = solve(prob, Tsit5(), saveat=0.2)\n\n# Plot results and compare with exact solution\ngrid = get_discrete(pdesys, discretization)\ndiscrete_x = grid[x]\ndiscrete_t = sol[t]\n\nusing Plots\nplt = plot()\n\nfor i in 1:length(discrete_t)\n    plot!(discrete_x, map(d -> sol[d][i], grid[u(t,x)]), label=\"Numerical, t=$(discrete_t[i])\")\n    scatter!(discrete_x, u_exact(x, discrete_t[i]), label=\"Exact, t=$(discrete_t[i])\")\nend\ndisplay(plt)\nsavefig(\"plot.png\")\n"],"type":"node"}],"type":"node"}],"type":"node"}