{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/ModelingToolkit/fp90z/docs/src/basics/AbstractSystem.md","title":"The AbstractSystem Interface"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["The AbstractSystem Interface"],"type":"node"},{"attributes":{},"tag":"h2","children":["Overview"],"type":"node"},{"attributes":{},"tag":"p","children":["The ",{"attributes":{},"tag":"code","children":["AbstractSystem"],"type":"node"}," interface is the core of the system level of ModelingToolkit.jl. It establishes a common set of functionality that is used between systems representing ODEs, PDEs, SDEs and more, allowing users to have a common framework for model manipulation and compilation."],"type":"node"},{"attributes":{},"tag":"h3","children":["Subtypes"],"type":"node"},{"attributes":{},"tag":"p","children":["There are three immediate subtypes of ",{"attributes":{},"tag":"code","children":["AbstractSystem"],"type":"node"},", classified by how many independent variables each type has:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["AbstractTimeIndependentSystem"],"type":"node"},": has no independent variable (eg: ",{"attributes":{},"tag":"code","children":["NonlinearSystem"],"type":"node"},")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["AbstractTimeDependentSystem"],"type":"node"},": has a single independent variable (eg: ",{"attributes":{},"tag":"code","children":["ODESystem"],"type":"node"},")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["AbstractMultivariateSystem"],"type":"node"},": may have multiple independent variables (eg: ",{"attributes":{},"tag":"code","children":["PDESystem"],"type":"node"},")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Constructors and Naming"],"type":"node"},{"attributes":{},"tag":"p","children":["The ",{"attributes":{},"tag":"code","children":["AbstractSystem"],"type":"node"}," interface has a consistent method for constructing systems. Generally it follows the order of:"],"type":"node"},{"attributes":{},"tag":"ol","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Equations"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Independent Variables"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Dependent Variables (or States)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Parameters"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["All other pieces are handled via keyword arguments. ",{"attributes":{},"tag":"code","children":["AbstractSystem"],"type":"node"},"s share the same keyword arguments, which are:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["system"],"type":"node"},": This is used for specifying subsystems for hierarchical modeling with reusable components. For more information, see the [components page](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," components)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Defaults: Keyword arguments like ",{"attributes":{},"tag":"code","children":["defaults"],"type":"node"}," are used for specifying default values which are used. If a value is not given at the ",{"attributes":{},"tag":"code","children":["SciMLProblem"],"type":"node"}," construction time, its numerical value will be the default."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Composition and Accessor Functions"],"type":"node"},{"attributes":{},"tag":"p","children":["Each ",{"attributes":{},"tag":"code","children":["AbstractSystem"],"type":"node"}," has lists of variables in context, such as distinguishing parameters vs states. In addition, an ",{"attributes":{},"tag":"code","children":["AbstractSystem"],"type":"node"}," also can hold other ",{"attributes":{},"tag":"code","children":["AbstractSystem"],"type":"node"}," types. Direct accessing of the values, such as ",{"attributes":{},"tag":"code","children":["sys.states"],"type":"node"},", gives the immediate list, while the accessor functions ",{"attributes":{},"tag":"code","children":["states(sys)"],"type":"node"}," gives the total set, which includes that of all systems held inside."],"type":"node"},{"attributes":{},"tag":"p","children":["The values which are common to all ",{"attributes":{},"tag":"code","children":["AbstractSystem"],"type":"node"},"s are:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["equations(sys)"],"type":"node"},": All equations that define the system and its subsystems."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["states(sys)"],"type":"node"},": All the states in the system and its subsystems."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["parameters(sys)"],"type":"node"},": All parameters of the system and its subsystems."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["nameof(sys)"],"type":"node"},": The name of the current-level system."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["get_eqs(sys)"],"type":"node"},": Equations that define the current-level system."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["get_states(sys)"],"type":"node"},": States that are in the current-level system."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["get_ps(sys)"],"type":"node"},": Parameters that are in the current-level system."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["get_systems(sys)"],"type":"node"},": Subsystems of the current-level system."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Optionally, a system could have:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["observed(sys)"],"type":"node"},": All observed equations of the system and its subsystems."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["get_observed(sys)"],"type":"node"},": Observed equations of the current-level system."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["get_continuous_events(sys)"],"type":"node"},": ",{"attributes":{},"tag":"code","children":["SymbolicContinuousCallback"],"type":"node"},"s of the current-level system."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["get_defaults(sys)"],"type":"node"},": A ",{"attributes":{},"tag":"code","children":["Dict"],"type":"node"}," that maps variables into their default values."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["independent_variables(sys)"],"type":"node"},": The independent variables of a system."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["get_noiseeqs(sys)"],"type":"node"},": Noise equations of the current-level system."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Note that if you know a system is an ",{"attributes":{},"tag":"code","children":["AbstractTimeDependentSystem"],"type":"node"}," you could use ",{"attributes":{},"tag":"code","children":["get_iv"],"type":"node"}," to get the unique independent variable directly, rather than using ",{"attributes":{},"tag":"code","children":["independent_variables(sys)[1]"],"type":"node"},", which is clunky and may cause problems if ",{"attributes":{},"tag":"code","children":["sys"],"type":"node"}," is an ",{"attributes":{},"tag":"code","children":["AbstractMultivariateSystem"],"type":"node"}," because there may be more than one independent variable. ",{"attributes":{},"tag":"code","children":["AbstractTimeIndependentSystem"],"type":"node"},"s do not have a method ",{"attributes":{},"tag":"code","children":["get_iv"],"type":"node"},", and ",{"attributes":{},"tag":"code","children":["independent_variables(sys)"],"type":"node"}," will return a size-zero result for such. For an ",{"attributes":{},"tag":"code","children":["AbstractMultivariateSystem"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["get_ivs"],"type":"node"}," is equivalent."],"type":"node"},{"attributes":{},"tag":"p","children":["A system could also have caches:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["get_jac(sys)"],"type":"node"},": The Jacobian of a system."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["get_tgrad(sys)"],"type":"node"},": The gradient with respect to time of a system."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Transformations"],"type":"node"},{"attributes":{},"tag":"p","children":["Transformations are functions which send a valid ",{"attributes":{},"tag":"code","children":["AbstractSystem"],"type":"node"}," definition to another ",{"attributes":{},"tag":"code","children":["AbstractSystem"],"type":"node"},". These are passes, like optimizations (e.g., Block-Lower Triangle transformations), or changes to the representation, which allow for alternative numerical methods to be utilized on the model (e.g., DAE index reduction)."],"type":"node"},{"attributes":{},"tag":"h2","children":["Analyses"],"type":"node"},{"attributes":{},"tag":"p","children":["Analyses are functions on a system which return information about the corresponding properties, like whether its parameters are structurally identifiable, or whether it's linear."],"type":"node"},{"attributes":{},"tag":"h2","children":["Function Calculation and Generation"],"type":"node"},{"attributes":{},"tag":"p","children":["The calculation and generation functions allow for calculating additional quantities to enhance the numerical methods applied to the resulting system. The calculations, like ",{"attributes":{},"tag":"code","children":["calculate_jacobian"],"type":"node"},", generate ModelingToolkit IR for the Jacobian of the system, while the generations, like ",{"attributes":{},"tag":"code","children":["generate_jacobian"],"type":"node"},", generate compiled output for the numerical solvers by applying ",{"attributes":{},"tag":"code","children":["build_function"],"type":"node"}," to the generated code. Additionally, many systems have function-type outputs, which cobble together the generation functionality for a system, for example, ",{"attributes":{},"tag":"code","children":["ODEFunction"],"type":"node"}," can be used to generate a DifferentialEquations-based ",{"attributes":{},"tag":"code","children":["ODEFunction"],"type":"node"}," with compiled version of the ODE itself, the Jacobian, the mass matrix, etc."],"type":"node"},{"attributes":{},"tag":"p","children":["Below are the possible calculation and generation functions:"],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["calculate_tgrad\ncalculate_gradient\ncalculate_jacobian\ncalculate_factorized_W\ncalculate_hessian\ngenerate_tgrad\ngenerate_gradient\ngenerate_jacobian\ngenerate_factorized_W\ngenerate_hessian\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Additionally, ",{"attributes":{},"tag":"code","children":["jacobian_sparsity(sys)"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["hessian_sparsity(sys)"],"type":"node"}," exist on the appropriate systems for fast generation of the sparsity patterns via an abstract interpretation without requiring differentiation."],"type":"node"},{"attributes":{},"tag":"h2","children":["Problem Constructors"],"type":"node"},{"attributes":{},"tag":"p","children":["At the end, the system types have ",{"attributes":{},"tag":"code","children":["DEProblem"],"type":"node"}," constructors, like ",{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"},", which allow for directly generating the problem types required for numerical methods. The first argument is always the ",{"attributes":{},"tag":"code","children":["AbstractSystem"],"type":"node"},", and the proceeding arguments match the argument order of their original constructors. Whenever an array would normally be provided, such as ",{"attributes":{},"tag":"code","children":["u0"],"type":"node"}," the initial condition of an ",{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"},", it is instead replaced with a variable map, i.e., an array of pairs ",{"attributes":{},"tag":"code","children":["var=>value"],"type":"node"},", which allows the user to designate the values without having to know the order that ModelingToolkit is internally using."],"type":"node"},{"attributes":{},"tag":"p","children":["For the value maps, the parameters are allowed to be functions of each other, and value maps of states can be functions of the parameters, i.e. you can do:"],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["u0 = [\n  lorenz1.x => 2.0\n  lorenz2.x => lorenz1.x * lorenz1.p\n]\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["Default Value Handling"],"type":"node"},{"attributes":{},"tag":"p","children":["The ",{"attributes":{},"tag":"code","children":["AbstractSystem"],"type":"node"}," types allow for specifying default values, for example ",{"attributes":{},"tag":"code","children":["defaults"],"type":"node"}," inside of them. At problem construction time, these values are merged into the value maps, where for any repeats the value maps override the default. In addition, defaults of a higher level in the system override the defaults of a lower level in the system."],"type":"node"}],"type":"node"}],"type":"node"}