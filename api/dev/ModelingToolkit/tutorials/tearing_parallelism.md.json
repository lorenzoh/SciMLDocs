{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/ModelingToolkit/fp90z/docs/src/tutorials/tearing_parallelism.md","title":"Exposing More Parallelism By Tearing Algebraic Equations in ODESystems"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Exposing More Parallelism By Tearing Algebraic Equations in ODESystems"],"type":"node"},{"attributes":{},"tag":"p","children":["Sometimes it can be very non-trivial to parallelize a system. In this tutorial we will demonstrate how to make use of ",{"attributes":{},"tag":"code","children":["structural_simplify"],"type":"node"}," to expose more parallelism in the solution process and parallelize the resulting simulation."],"type":"node"},{"attributes":{},"tag":"h2","children":["The Component Library"],"type":"node"},{"attributes":{},"tag":"p","children":["The following tutorial will use the following set of components describing electrical circuits:"],"type":"node"},{"attributes":{"lang":"@example tearing"},"tag":"codeblock","children":["using ModelingToolkit, OrdinaryDiffEq\n\n# Basic electric components\n@variables t\nconst D = Differential(t)\n@connector function Pin(;name)\n    @variables v(t)=1.0 i(t)=1.0 [connect = Flow]\n    ODESystem(Equation[], t, [v, i], [], name=name)\nend\n\nfunction Ground(;name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], [], name=name), g)\nend\n\nfunction ConstantVoltage(;name, V = 1.0)\n    val = V\n    @named p = Pin()\n    @named n = Pin()\n    @parameters V=V\n    eqs = [\n           V ~ p.v - n.v\n           0 ~ p.i + n.i\n          ]\n    compose(ODESystem(eqs, t, [], [V], name=name), p, n)\nend\n\n@connector function HeatPort(;name)\n    @variables T(t)=293.15 Q_flow(t)=0.0 [connect = Flow]\n    ODESystem(Equation[], t, [T, Q_flow], [], name=name)\nend\n\nfunction HeatingResistor(;name, R=1.0, TAmbient=293.15, alpha=1.0)\n    @named p = Pin()\n    @named n = Pin()\n    @named h = HeatPort()\n    @variables v(t) RTherm(t)\n    @parameters R=R TAmbient=TAmbient alpha=alpha\n    eqs = [\n           RTherm ~ R*(1 + alpha*(h.T - TAmbient))\n           v ~ p.i * RTherm\n           h.Q_flow ~ -v * p.i # -LossPower\n           v ~ p.v - n.v\n           0 ~ p.i + n.i\n          ]\n    compose(ODESystem(\n        eqs, t, [v, RTherm], [R, TAmbient, alpha],\n        name=name,\n    ), p, n, h)\nend\n\nfunction HeatCapacitor(;name, rho=8050, V=1, cp=460, TAmbient=293.15)\n    @parameters rho=rho V=V cp=cp\n    C = rho*V*cp\n    @named h = HeatPort()\n    eqs = [\n           D(h.T) ~ h.Q_flow / C\n          ]\n    compose(ODESystem(\n        eqs, t, [], [rho, V, cp],\n        name=name,\n    ), h)\nend\n\nfunction Capacitor(;name, C = 1.0)\n    @named p = Pin()\n    @named n = Pin()\n    @variables v(t)=0.0\n    @parameters C=C\n    eqs = [\n           v ~ p.v - n.v\n           0 ~ p.i + n.i\n           D(v) ~ p.i / C\n          ]\n    compose(ODESystem(\n        eqs, t, [v], [C],\n        name=name\n    ), p, n)\nend\n\nfunction parallel_rc_model(i; name, source, ground, R, C)\n    resistor = HeatingResistor(name=Symbol(:resistor, i), R=R)\n    capacitor = Capacitor(name=Symbol(:capacitor, i), C=C)\n    heat_capacitor = HeatCapacitor(name=Symbol(:heat_capacitor, i))\n\n    rc_eqs = [\n              connect(source.p, resistor.p)\n              connect(resistor.n, capacitor.p)\n              connect(capacitor.n, source.n, ground.g)\n              connect(resistor.h, heat_capacitor.h)\n             ]\n\n    compose(ODESystem(rc_eqs, t, name=Symbol(name, i)),\n            [resistor, capacitor, source, ground, heat_capacitor])\nend\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["The Model"],"type":"node"},{"attributes":{},"tag":"p","children":["Assuming that the components are defined, our model is 50 resistors and capacitors connected in parallel. Thus following the [acausal components tutorial](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," acausal), we can connect a bunch of RC components as follows:"],"type":"node"},{"attributes":{"lang":"@example tearing"},"tag":"codeblock","children":["V = 2.0\n@named source = ConstantVoltage(V=V)\n@named ground = Ground()\nN = 50\nRs = 10 .^range(0, stop=-4, length=N)\nCs = 10 .^range(-3, stop=0, length=N)\nrc_systems = map(1:N) do i\n    parallel_rc_model(i; name=:rc, source=source, ground=ground, R=Rs[i], C=Cs[i])\nend;\n@variables E(t)=0.0\neqs = [\n       D(E) ~ sum(((i, sys),)->getproperty(sys, Symbol(:resistor, i)).h.Q_flow, enumerate(rc_systems))\n      ]\n@named _big_rc = ODESystem(eqs, t, [E], [])\n@named big_rc = compose(_big_rc, rc_systems)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Now let's say we want to expose a bit more parallelism via running tearing. How do we do that?"],"type":"node"},{"attributes":{"lang":"@example tearing"},"tag":"codeblock","children":["sys = structural_simplify(big_rc)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Done, that's it. There's no more to it."],"type":"node"},{"attributes":{},"tag":"h2","children":["What Happened?"],"type":"node"},{"attributes":{},"tag":"p","children":["Yes, that's a good question! Let's investigate a little bit more what had happened. If you look at the system we defined:"],"type":"node"},{"attributes":{"lang":"@example tearing"},"tag":"codeblock","children":["length(equations(big_rc))\n"],"type":"node"},{"attributes":{},"tag":"p","children":["You see it started as a massive 1051 set of equations. However, after eliminating redundancies we arrive at 151 equations:"],"type":"node"},{"attributes":{"lang":"@example tearing"},"tag":"codeblock","children":["equations(sys)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["That's not all though. In addition, the tearing process has turned the sets of nonlinear equations into separate blocks and constructed a DAG for the dependencies between the blocks. We can use the bipartite graph functionality to dig in and investigate what this means:"],"type":"node"},{"attributes":{"lang":"@example tearing"},"tag":"codeblock","children":["using ModelingToolkit.BipartiteGraphs\nts = TearingState(expand_connections(big_rc))\ninc_org = BipartiteGraphs.incidence_matrix(ts.structure.graph)\nblt_org = StructuralTransformations.sorted_incidence_matrix(ts, only_algeqs=true, only_algvars=true)\nblt_reduced = StructuralTransformations.sorted_incidence_matrix(ModelingToolkit.get_tearing_state(sys), only_algeqs=true, only_algvars=true)\n"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"img","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String} with 2 entries:\n  :src => \"https://user-images.githubusercontent.com/1814174/110589027-d4ec9b00â€¦\n  :alt => \"\""},"type":"leaf"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The figure on the left is the original incidence matrix of the algebraic equations. Notice that the original formulation of the model has dependencies between different equations, and so the full set of equations must be solved together. That exposes no parallelism. However, the Block Lower Triangular (BLT) transformation exposes independent blocks. This is then further improved by the tearing process, which removes 90% of the equations and transforms the nonlinear equations into 50 independent blocks ",{"attributes":{},"tag":"em","children":["which can now all be solved in parallel"],"type":"node"},". The conclusion is that, your attempts to parallelize are neigh: performing parallelism after structural simplification greatly improves the problem that can be parallelized, so this is better than trying to do it by hand."],"type":"node"},{"attributes":{},"tag":"p","children":["After performing this, you can construct the ",{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"},"/",{"attributes":{},"tag":"code","children":["ODAEProblem"],"type":"node"}," and set ",{"attributes":{},"tag":"code","children":["parallel_form"],"type":"node"}," to use the exposed parallelism in multithreaded function constructions, but this showcases why ",{"attributes":{},"tag":"code","children":["structural_simplify"],"type":"node"}," is so important to that process."],"type":"node"}],"type":"node"}],"type":"node"}