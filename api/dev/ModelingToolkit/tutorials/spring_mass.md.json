{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/ModelingToolkit/fp90z/docs/src/tutorials/spring_mass.md","title":"Component-Based Modeling a Spring-Mass System"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Component-Based Modeling a Spring-Mass System"],"type":"node"},{"attributes":{},"tag":"p","children":["In this tutorial we will build a simple component-based model of a spring-mass system. A spring-mass system consists of one or more masses connected by springs. ",{"attributes":{"href":"https://en.wikipedia.org/wiki/Hooke%27s_law","title":""},"tag":"a","children":["Hooke's law"],"type":"node"}," gives the force exerted by a spring when it is extended or compressed by a given distance. This specifies a differential-equation system where the acceleration of the masses is specified using the forces acting on them."],"type":"node"},{"attributes":{},"tag":"h2","children":["Copy-Paste Example"],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["using ModelingToolkit, Plots, DifferentialEquations, LinearAlgebra\nusing Symbolics: scalarize\n\n@variables t\nD = Differential(t)\n\nfunction Mass(; name, m = 1.0, xy = [0., 0.], u = [0., 0.])\n    ps = @parameters m=m\n    sts = @variables pos[1:2](t)=xy v[1:2](t)=u\n    eqs = scalarize(D.(pos) .~ v)\n    ODESystem(eqs, t, [pos..., v...], ps; name)\nend\n\nfunction Spring(; name, k = 1e4, l = 1.)\n    ps = @parameters k=k l=l\n    @variables x(t), dir[1:2](t)\n    ODESystem(Equation[], t, [x, dir...], ps; name)\nend\n\nfunction connect_spring(spring, a, b)\n    [\n        spring.x ~ norm(scalarize(a .- b))\n        scalarize(spring.dir .~ scalarize(a .- b))\n    ]\nend\n\nspring_force(spring) = -spring.k .* scalarize(spring.dir) .* (spring.x - spring.l)  ./ spring.x\n\nm = 1.0\nxy = [1., -1.]\nk = 1e4\nl = 1.\ncenter = [0., 0.]\ng = [0., -9.81]\n@named mass = Mass(m=m, xy=xy)\n@named spring = Spring(k=k, l=l)\n\neqs = [\n    connect_spring(spring, mass.pos, center)\n    scalarize(D.(mass.v) .~ spring_force(spring) / mass.m .+ g)\n]\n\n@named _model = ODESystem(eqs, t, [spring.x; spring.dir; mass.pos], [])\n@named model = compose(_model, mass, spring)\nsys = structural_simplify(model)\n\nprob = ODEProblem(sys, [], (0., 3.))\nsol = solve(prob, Rosenbrock23())\nplot(sol)\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["Explanation"],"type":"node"},{"attributes":{},"tag":"h3","children":["Building the components"],"type":"node"},{"attributes":{},"tag":"p","children":["For each component we use a Julia function that returns an ",{"attributes":{},"tag":"code","children":["ODESystem"],"type":"node"},". At the top, we define the fundamental properties of a ",{"attributes":{},"tag":"code","children":["Mass"],"type":"node"},": it has a mass ",{"attributes":{},"tag":"code","children":["m"],"type":"node"},", a position ",{"attributes":{},"tag":"code","children":["pos"],"type":"node"}," and a velocity ",{"attributes":{},"tag":"code","children":["v"],"type":"node"},". We also define that the velocity is the rate of change of position with respect to time."],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["function Mass(; name, m = 1.0, xy = [0., 0.], u = [0., 0.])\n    ps = @parameters m=m\n    sts = @variables pos[1:2](t)=xy v[1:2](t)=u\n    eqs = scalarize(D.(pos) .~ v)\n    ODESystem(eqs, t, [pos..., v...], ps; name)\nend\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Note that this is an incompletely specified ",{"attributes":{},"tag":"code","children":["ODESystem"],"type":"node"},". It cannot be simulated on its own since the equations for the velocity ",{"attributes":{},"tag":"code","children":["v[1:2](t)"],"type":"node"}," are unknown. Notice the addition of a ",{"attributes":{},"tag":"code","children":["name"],"type":"node"}," keyword. This allows us to generate different masses with different names. A ",{"attributes":{},"tag":"code","children":["Mass"],"type":"node"}," can now be constructed as:"],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["Mass(name = :mass1)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Or using the ",{"attributes":{},"tag":"code","children":["@named"],"type":"node"}," helper macro"],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["@named mass1 = Mass()\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Next we build the spring component. It is characterised by the spring constant ",{"attributes":{},"tag":"code","children":["k"],"type":"node"}," and the length ",{"attributes":{},"tag":"code","children":["l"],"type":"node"}," of the spring when no force is applied to it. The state of a spring is defined by its current length and direction."],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["function Spring(; name, k = 1e4, l = 1.)\n    ps = @parameters k=k l=l\n    @variables x(t), dir[1:2](t)\n    ODESystem(Equation[], t, [x, dir...], ps; name)\nend\n"],"type":"node"},{"attributes":{},"tag":"p","children":["We now define functions that help construct the equations for a mass-spring system. First, the ",{"attributes":{},"tag":"code","children":["connect_spring"],"type":"node"}," function connects a ",{"attributes":{},"tag":"code","children":["spring"],"type":"node"}," between two positions ",{"attributes":{},"tag":"code","children":["a"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["b"],"type":"node"},". Note that ",{"attributes":{},"tag":"code","children":["a"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["b"],"type":"node"}," can be the ",{"attributes":{},"tag":"code","children":["pos"],"type":"node"}," of a ",{"attributes":{},"tag":"code","children":["Mass"],"type":"node"},", or just a fixed position such as ",{"attributes":{},"tag":"code","children":["[0., 0.]"],"type":"node"},". In that sense, the length of the spring ",{"attributes":{},"tag":"code","children":["x"],"type":"node"}," is given by the length of the vector ",{"attributes":{},"tag":"code","children":["dir"],"type":"node"}," joining ",{"attributes":{},"tag":"code","children":["a"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["b"],"type":"node"},"."],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["function connect_spring(spring, a, b)\n    [\n        spring.x ~ norm(scalarize(a .- b))\n        scalarize(spring.dir .~ scalarize(a .- b))\n    ]\nend\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Lastly, we define the ",{"attributes":{},"tag":"code","children":["spring_force"],"type":"node"}," function that takes a ",{"attributes":{},"tag":"code","children":["spring"],"type":"node"}," and returns the force exerted by this spring."],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["spring_force(spring) = -spring.k .* scalarize(spring.dir) .* (spring.x - spring.l)  ./ spring.x\n"],"type":"node"},{"attributes":{},"tag":"p","children":["To create our system, we will first create the components: a mass and a spring. This is done as follows:"],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["m = 1.0\nxy = [1., -1.]\nk = 1e4\nl = 1.\ncenter = [0., 0.]\ng = [0., -9.81]\n@named mass = Mass(m=m, xy=xy)\n@named spring = Spring(k=k, l=l)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["We can now create the equations describing this system, by connecting ",{"attributes":{},"tag":"code","children":["spring"],"type":"node"}," to ",{"attributes":{},"tag":"code","children":["mass"],"type":"node"}," and a fixed point."],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["eqs = [\n    connect_spring(spring, mass.pos, center)\n    scalarize(D.(mass.v) .~ spring_force(spring) / mass.m .+ g)\n]\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Finally, we can build the model using these equations and components."],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["@named _model = ODESystem(eqs, t, [spring.x; spring.dir; mass.pos], [])\n@named model = compose(_model, mass, spring)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["We can take a look at the equations in the model using the ",{"attributes":{},"tag":"code","children":["equations"],"type":"node"}," function."],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["equations(model)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["The states of this model are:"],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["states(model)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["And the parameters of this model are:"],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["parameters(model)\n"],"type":"node"},{"attributes":{},"tag":"h3","children":["Simplifying and solving this system"],"type":"node"},{"attributes":{},"tag":"p","children":["This system can be solved directly as a DAE using ",{"attributes":{"href":"https://diffeq.sciml.ai/stable/solvers/dae_solve/","title":""},"tag":"a","children":["one of the DAE solvers from DifferentialEquations.jl"],"type":"node"},". However, we can symbolically simplify the system first beforehand. Running ",{"attributes":{},"tag":"code","children":["structural_simplify"],"type":"node"}," eliminates unnecessary variables from the model to give the leanest numerical representation of the system."],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["sys = structural_simplify(model)\nequations(sys)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["We are left with only 4 equations involving 4 state variables (",{"attributes":{},"tag":"code","children":["mass.pos[1]"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["mass.pos[2]"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["mass.v[1]"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["mass.v[2]"],"type":"node"},"). We can solve the system by converting it to an ",{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"},". Some observed variables are not expanded by default. To view the complete equations, one can do"],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["full_equations(sys)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["This is done as follows:"],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["prob = ODEProblem(sys, [], (0., 3.))\nsol = solve(prob, Rosenbrock23())\nplot(sol)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["What if we want the timeseries of a different variable? That information is not lost! Instead, ",{"attributes":{},"tag":"code","children":["structural_simplify"],"type":"node"}," simply changes state variables into ",{"attributes":{},"tag":"code","children":["observed"],"type":"node"}," variables."],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["observed(sys)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["These are explicit algebraic equations which can be used to reconstruct the required variables on the fly. This leads to dramatic computational savings since implicitly solving an ODE scales as O(n^3), so fewer states are significantly better!"],"type":"node"},{"attributes":{},"tag":"p","children":["We can access these variables using the solution object. For example, let's retrieve the x-position of the mass over time:"],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["sol[mass.pos[1]]\n"],"type":"node"},{"attributes":{},"tag":"p","children":["We can also plot the path of the mass:"],"type":"node"},{"attributes":{"lang":"@example component"},"tag":"codeblock","children":["plot(sol, vars = (mass.pos[1], mass.pos[2]))\n"],"type":"node"}],"type":"node"}],"type":"node"}