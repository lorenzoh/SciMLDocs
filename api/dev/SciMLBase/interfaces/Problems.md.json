{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/SciMLBase/dYFnI/docs/src/interfaces/Problems.md","title":"SciMLProblems"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["SciMLProblems"],"type":"node"},{"attributes":{},"tag":"p","children":["The cornerstone of the SciML common interface is the problem type definition. These definitions are the encoding of mathematical problems into a numerically computable form."],"type":"node"},{"attributes":{},"tag":"h3","children":["Note About Symbolics and ModelingToolkit"],"type":"node"},{"attributes":{},"tag":"p","children":["The symbolic analog to the problem interface is the ModelingToolkit ",{"attributes":{},"tag":"code","children":["AbstractSystem"],"type":"node"},". For example, ",{"attributes":{},"tag":"code","children":["ODESystem"],"type":"node"}," is the symbolic analog to ",{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"},". Each of these system types have a method for constructing the associated problem and function types."],"type":"node"},{"attributes":{},"tag":"h2","children":["Definition of the SciMLProblem Interface"],"type":"node"},{"attributes":{},"tag":"p","children":["The following standard principles should be adhered to across all ",{"attributes":{},"tag":"code","children":["SciMLProblem"],"type":"node"}," instantiations."],"type":"node"},{"attributes":{},"tag":"h3","children":["In-place Specification"],"type":"node"},{"attributes":{},"tag":"p","children":["Each ",{"attributes":{},"tag":"code","children":["SciMLProblem"],"type":"node"}," type can be called with an \"is inplace\" (iip) choice. For example:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/SciMLBase.ODEProblem"},"tag":"reference","children":["ODEProblem"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["f"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["u0"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["tspan"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"CURLY","children":[{"attributes":{"reftype":"symbol","document_id":"references/SciMLBase.ODEProblem"},"tag":"reference","children":["ODEProblem"],"type":"node"},{"attributes":{},"tag":"LBRACE","children":["{"],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["iip"],"type":"node"},{"attributes":{},"tag":"RBRACE","children":["}"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["f"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["u0"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["tspan"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["which is a boolean for whether the function is in the inplace form (mutating to change the first value). This is automatically determined using the methods table but note that for full type-inferrability of the ",{"attributes":{},"tag":"code","children":["SciMLProblem"],"type":"node"}," this iip-ness should be specified."],"type":"node"},{"attributes":{},"tag":"p","children":["Additionally, the functions are fully specialized to reduce the runtimes. If one would instead like to not specialize on the functions to reduce compile time, then one can set ",{"attributes":{},"tag":"code","children":["recompile"],"type":"node"}," to false."],"type":"node"},{"attributes":{},"tag":"h3","children":["Default Parameters"],"type":"node"},{"attributes":{},"tag":"p","children":["By default, ",{"attributes":{},"tag":"code","children":["SciMLProblem"],"type":"node"}," types use the ",{"attributes":{},"tag":"code","children":["SciMLBase.NullParameters()"],"type":"node"}," singleton to define the absence of parameters by default. The reason is because this throws an informative error if the parameter is used or accessed within the user's function, for example, ",{"attributes":{},"tag":"code","children":["p[1]"],"type":"node"}," will throw an informative error about forgetting to pass parameters."],"type":"node"},{"attributes":{},"tag":"h3","children":["Keyword Argument Splatting"],"type":"node"},{"attributes":{},"tag":"p","children":["All ",{"attributes":{},"tag":"code","children":["SciMLProblem"],"type":"node"}," types allow for passing keyword arguments that would get forwarded to the solver. The reason for this is that in many cases, like in ",{"attributes":{},"tag":"code","children":["EnsembleProblem"],"type":"node"}," usage, a ",{"attributes":{},"tag":"code","children":["SciMLProblem"],"type":"node"}," might be associated with some solver configuration, such as a callback or tolerance. Thus, for flexibility the extra keyword arguments to the ",{"attributes":{},"tag":"code","children":["SciMLProblem"],"type":"node"}," are carried to the solver."],"type":"node"},{"attributes":{},"tag":"h3","children":["problem_type"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["SciMLProblem"],"type":"node"}," types include a non-public API definition of ",{"attributes":{},"tag":"code","children":["problem_type"],"type":"node"}," which holds a trait type corresponding to the way the ",{"attributes":{},"tag":"code","children":["SciMLProblem"],"type":"node"}," was constructed. For example, if a ",{"attributes":{},"tag":"code","children":["SecondOrderODEProblem"],"type":"node"}," constructor is used, the returned problem is simply a ",{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"}," for interopability with any ",{"attributes":{},"tag":"code","children":["ODEProblem"],"type":"node"}," algorithm. However, in this case the ",{"attributes":{},"tag":"code","children":["problem_type"],"type":"node"}," will be populated with the ",{"attributes":{},"tag":"code","children":["SecondOrderODEProblem"],"type":"node"}," type, indicating the original definition and extra structure."],"type":"node"},{"attributes":{},"tag":"h3","children":["Remake"],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["remake\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["Problem Traits"],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["SciMLBase.isinplace(prob::SciMLBase.DEProblem)\nSciMLBase.is_diagonal_noise\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["SciMLProblem API"],"type":"node"},{"attributes":{},"tag":"h3","children":["Abstract SciMLProblems"],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["SciMLBase.SciMLProblem\nSciMLBase.DEProblem\nSciMLBase.AbstractLinearProblem\nSciMLBase.AbstractNonlinearProblem\nSciMLBase.AbstractQuadratureProblem\nSciMLBase.AbstractOptimizationProblem\nSciMLBase.AbstractNoiseProblem\nSciMLBase.AbstractODEProblem\nSciMLBase.AbstractDiscreteProblem\nSciMLBase.AbstractAnalyticalProblem\nSciMLBase.AbstractRODEProblem\nSciMLBase.AbstractSDEProblem\nSciMLBase.AbstractDAEProblem\nSciMLBase.AbstractDDEProblem\nSciMLBase.AbstractConstantLagDDEProblem\nSciMLBase.AbstractSecondOrderODEProblem\nSciMLBase.AbstractBVProblem\nSciMLBase.AbstractJumpProblem\nSciMLBase.AbstractSDDEProblem\nSciMLBase.AbstractConstantLagSDDEProblem\nSciMLBase.AbstractPDEProblem\n"],"type":"node"},{"attributes":{},"tag":"h3","children":["Concrete SciMLProblems"],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["LinearProblem\nNonlinearProblem\nQuadratureProblem\nOptimizationProblem\nBVProblem\nDAEProblem\nDDEProblem\nDynamicalDDEProblem\nSecondOrderDDEProblem\nDiscreteProblem\nNoiseProblem\nODEProblem\nDynamicalODEProblem\nSecondOrderODEProblem\nSplitODEProblem\nIncrementingODEProblem\nRODEProblem\nSDDEProblem\nSplitSDEProblem\nDynamicalSDEProblem\nSteadyStateProblem\nPDEProblem\n"],"type":"node"}],"type":"node"}],"type":"node"}