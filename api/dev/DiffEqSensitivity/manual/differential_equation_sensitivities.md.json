{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/DiffEqSensitivity/GjhZ8/docs/src/manual/differential_equation_sensitivities.md","title":"[Sensitivity Algorithms for Differential Equations with Automatic Differentiation (AD)]( sensitivity_diffeq)"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["[Sensitivity Algorithms for Differential Equations with Automatic Differentiation (AD)](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," sensitivity_diffeq)"],"type":"node"},{"attributes":{},"tag":"p","children":["DiffEqSensitivity.jl's high level interface allows for specifying a sensitivity algorithm (",{"attributes":{},"tag":"code","children":["sensealg"],"type":"node"},") to control the method by which ",{"attributes":{},"tag":"code","children":["solve"],"type":"node"}," is differentiated in an automatic differentiation (AD) context by a compatible AD library. The underlying algorithms then use the direct interface methods, like ",{"attributes":{},"tag":"code","children":["ODEForwardSensitivityProblem"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["adjoint_sensitivities"],"type":"node"},", to compute the derivatives without requiring the user to do any of the setup."],"type":"node"},{"attributes":{},"tag":"p","children":["Current AD libraries whose calls are captured by the sensitivity system are:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://github.com/FluxML/Zygote.jl","title":""},"tag":"a","children":["Zygote.jl"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://github.com/JuliaDiff/Diffractor.jl","title":""},"tag":"a","children":["Diffractor.jl"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Using and Controlling Sensitivity Algorithms within AD"],"type":"node"},{"attributes":{},"tag":"p","children":["Take for example this simple differential equation solve on Lotka-Volterra:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"USING","children":[{"attributes":{},"tag":"USING","children":["using"],"type":"node"},{"attributes":{},"tag":"DOT","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/DiffEqSensitivity"},"tag":"reference","children":["DiffEqSensitivity"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"DOT","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["OrdinaryDiffEq"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"DOT","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["Zygote"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"FUNCTION","children":[{"attributes":{},"tag":"FUNCTION","children":["function"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["fiip"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["du"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["u"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["t"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"BLOCK","children":[{"attributes":{},"tag":"NEWLINE_WS","children":["\n  "],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["du"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["1"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["dx"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["1"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"STAR","children":["*"],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["u"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["1"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"MINUS","children":["-"],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["2"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"STAR","children":["*"],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["u"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["1"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"STAR","children":["*"],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["u"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["2"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n  "],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["du"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["2"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["dy"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"MINUS","children":["-"],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["3"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"STAR","children":["*"],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["u"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["2"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"PLUS","children":["+"],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["4"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"STAR","children":["*"],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["u"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["1"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"STAR","children":["*"],"type":"node"},{"attributes":{},"tag":"REF","children":[{"attributes":{},"tag":"IDENTIFIER","children":["u"],"type":"node"},{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"INTEGER","children":["2"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"END","children":["end"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"TOPLEVEL","children":[{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"VECT","children":[{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"FLOAT","children":["1.5"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"FLOAT","children":["1.0"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"FLOAT","children":["3.0"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"FLOAT","children":["1.0"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"SEMICOLON","children":[";"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["u0"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"VCAT","children":[{"attributes":{},"tag":"LSQUARE","children":["["],"type":"node"},{"attributes":{},"tag":"FLOAT","children":["1.0"],"type":"node"},{"attributes":{},"tag":"SEMICOLON","children":[";"],"type":"node"},{"attributes":{},"tag":"FLOAT","children":["1.0"],"type":"node"},{"attributes":{},"tag":"RSQUARE","children":["]"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["prob"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/SciMLBase.ODEProblem"},"tag":"reference","children":["ODEProblem"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["fiip"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["u0"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"TUPLE","children":[{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"FLOAT","children":["0.0"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"FLOAT","children":["10.0"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["sol"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/CommonSolve.solve"},"tag":"reference","children":["solve"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["prob"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["Tsit5"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["loss"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["u0"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["sum"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/CommonSolve.solve"},"tag":"reference","children":["solve"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["prob"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["Tsit5"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["u0"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["u0"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["saveat"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"FLOAT","children":["0.1"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"TUPLE","children":[{"attributes":{},"tag":"IDENTIFIER","children":["du0"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["dp"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"DOT","children":[{"attributes":{},"tag":"IDENTIFIER","children":["Zygote"],"type":"node"},{"attributes":{},"tag":"DOT","children":["."],"type":"node"},{"attributes":{},"tag":"QUOTE","children":[{"attributes":{},"tag":"IDENTIFIER","children":["gradient"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["loss"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["u0"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["This will compute the gradient of the loss function \"sum of the values of the solution to the ODE at timepoints dt=0.1\" using an adjoint method, where ",{"attributes":{},"tag":"code","children":["du0"],"type":"node"}," is the derivative of the loss function with respect to the initial condition and ",{"attributes":{},"tag":"code","children":["dp"],"type":"node"}," is the derivative of the loss function with respect to the parameters."],"type":"node"},{"attributes":{},"tag":"p","children":["Because the gradient is calculated by ",{"attributes":{},"tag":"code","children":["Zygote.gradient"],"type":"node"}," and Zygote.jl is one of the compatible AD libraries, this derivative calculation will be captured by the ",{"attributes":{},"tag":"code","children":["sensealg"],"type":"node"}," system, and one of DiffEqSensitivity.jl's adjoint overloads will be used to compute the derivative. By default, if the ",{"attributes":{},"tag":"code","children":["sensealg"],"type":"node"}," keyword argument is not defined, then a smart polyalgorithm is used to automatically determine the most appropriate method for a given equation."],"type":"node"},{"attributes":{},"tag":"p","children":["Likewise, the ",{"attributes":{},"tag":"code","children":["sensealg"],"type":"node"}," argument can be given to directly control the method by which the derivative is computed. For example:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["loss"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["u0"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["sum"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/CommonSolve.solve"},"tag":"reference","children":["solve"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["prob"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"IDENTIFIER","children":["Tsit5"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["u0"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["u0"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["saveat"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"FLOAT","children":["0.1"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"TUPLE","children":[{"attributes":{},"tag":"IDENTIFIER","children":["du0"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["dp"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{},"tag":"DOT","children":[{"attributes":{},"tag":"IDENTIFIER","children":["Zygote"],"type":"node"},{"attributes":{},"tag":"DOT","children":["."],"type":"node"},{"attributes":{},"tag":"QUOTE","children":[{"attributes":{},"tag":"IDENTIFIER","children":["gradient"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["loss"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["u0"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["p"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Choosing a Sensitivity Algorithm"],"type":"node"},{"attributes":{},"tag":"p","children":["There are two classes of algorithms: the continuous sensitivity analysis methods, and the discrete sensitivity analysis methods (direct automatic differentiation). Generally:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://arxiv.org/abs/2001.04385","title":""},"tag":"a","children":["Continuous sensitivity analysis are more efficient while the discrete"," ","sensitivity analysis is more stable"],"type":"node"}," (full discussion is in the appendix of that paper)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Continuous sensitivity analysis methods only support a subset of equations, which currently includes:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["ODEProblem (with mass matrices for differential-algebraic equations (DAEs)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["SDEProblem"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["SteadyStateProblem / NonlinearProblem"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Discrete sensitivity analysis methods only support a subset of algorithms, namely, the pure Julia solvers which are written generically."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["For an analysis of which methods will be most efficient for computing the solution derivatives for a given problem, consult our analysis ",{"attributes":{"href":"https://arxiv.org/abs/1812.01892","title":""},"tag":"a","children":["in this arxiv paper"],"type":"node"},". A general rule of thumb is:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["ForwardDiffSensitivity"],"type":"node"}," is the fastest for differential equations with small numbers of parameters (<100) and can be used on any differential equation solver that is native Julia. If the chosen ODE solver is not compatible with direct automatic differentiation, ",{"attributes":{},"tag":"code","children":["ForwardSensitivty"],"type":"node"}," may be used instead."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Adjoint senstivity analysis is the fastest when the number of parameters is sufficiently large. There are three configurations of note. Using ",{"attributes":{},"tag":"code","children":["QuadratureAdjoint"],"type":"node"}," is the fastest but uses the most memory, ",{"attributes":{},"tag":"code","children":["BacksolveAdjoint"],"type":"node"}," uses the least memory but on very stiff problems it may be unstable and require a lot of checkpoints, while ",{"attributes":{},"tag":"code","children":["InterpolatingAdjoint"],"type":"node"}," is in the middle, allowing checkpointing to control total memory use."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["The methods which use direct automatic differentiation (",{"attributes":{},"tag":"code","children":["ReverseDiffAdjoint"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["TrackerAdjoint"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["ForwardDiffSensitivity"],"type":"node"},", and ",{"attributes":{},"tag":"code","children":["ZygoteAdjoint"],"type":"node"},") support the full range of DifferentialEquations.jl features (SDEs, DDEs, events, etc.), but only work on native Julia solvers."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["For non-ODEs with large numbers of parameters, ",{"attributes":{},"tag":"code","children":["TrackerAdjoint"],"type":"node"}," in out-of-place form may be the best performer on GPUs, and ",{"attributes":{},"tag":"code","children":["ReverseDiffAdjoint"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["TrackerAdjoint"],"type":"node"}," is able to use a ",{"attributes":{},"tag":"code","children":["TrackedArray"],"type":"node"}," form with out-of-place functions ",{"attributes":{},"tag":"code","children":["du = f(u,p,t)"],"type":"node"}," but requires an ",{"attributes":{},"tag":"code","children":["Array{TrackedReal}"],"type":"node"}," form for ",{"attributes":{},"tag":"code","children":["f(du,u,p,t)"],"type":"node"}," mutating ",{"attributes":{},"tag":"code","children":["du"],"type":"node"},". The latter has much more overhead, and should be avoided if possible. Thus if solving non-ODEs with lots of parameters, using ",{"attributes":{},"tag":"code","children":["TrackerAdjoint"],"type":"node"}," with an out-of-place definition may be the current best option."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{"class":"note"},"tag":"admonition","children":[{"attributes":{},"tag":"admonitiontitle","children":["Note"],"type":"node"},{"attributes":{},"tag":"admonitionbody","children":[{"attributes":{},"tag":"p","children":["Compatibility with direct automatic differentiation algorithms (",{"attributes":{},"tag":"code","children":["ForwardDiffSensitivity"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["ReverseDiffAdjoint"],"type":"node"},", etc.) can be queried using the ",{"attributes":{},"tag":"code","children":["SciMLBase.isautodifferentiable(::SciMLAlgorithm)"],"type":"node"}," trait function."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["If the chosen algorithm is a continuous sensitivity analysis algorithm, then an ",{"attributes":{},"tag":"code","children":["autojacvec"],"type":"node"}," argument can be given for choosing how the Jacobian-vector product (",{"attributes":{},"tag":"code","children":["J*v"],"type":"node"},") or vector-Jacobian product (",{"attributes":{},"tag":"code","children":["J'*v"],"type":"node"},") calculation is computed. For the forward sensitivity methods, ",{"attributes":{},"tag":"code","children":["autojacvec=true"],"type":"node"}," is the most efficient, though ",{"attributes":{},"tag":"code","children":["autojacvec=false"],"type":"node"}," is slightly less accurate but very close in efficiency. For adjoint methods it's more complicated and dependent on the way that the user's ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," function is implemented:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["EnzymeVJP()"],"type":"node"}," is the most efficient if it's applicable on your equation."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If your function has no branching (no if statements) but uses mutation, ",{"attributes":{},"tag":"code","children":["ReverseDiffVJP(true)"],"type":"node"}," will be the most efficient after Enzyme. Otherwise ",{"attributes":{},"tag":"code","children":["ReverseDiffVJP()"],"type":"node"},", but you may wish to proceed with eliminating mutation as without compilation enabled this can be slow."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["If your on the CPU or GPU and your function is very vectorized and has no mutation, choose ",{"attributes":{},"tag":"code","children":["ZygoteVJP()"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Else fallback to ",{"attributes":{},"tag":"code","children":["TrackerVJP()"],"type":"node"}," if Zygote does not support the function."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Special Notes on Non-ODE Differential Equation Problems"],"type":"node"},{"attributes":{},"tag":"p","children":["While all of the choices are compatible with ordinary differential equations, specific notices apply to other forms:"],"type":"node"},{"attributes":{},"tag":"h3","children":["Differential-Algebraic Equations"],"type":"node"},{"attributes":{},"tag":"p","children":["We note that while all 3 are compatible with index-1 DAEs via the ",{"attributes":{"href":"https://arxiv.org/abs/2001.04385","title":""},"tag":"a","children":["derivation in the universal differential equations paper"],"type":"node"}," (note the reinitialization), we do not recommend ",{"attributes":{},"tag":"code","children":["BacksolveAdjoint"],"type":"node"}," one DAEs because the stiffness inherent in these problems tends to cause major difficulties with the accuracy of the backwards solution due to reinitialization of the algebraic variables."],"type":"node"},{"attributes":{},"tag":"h3","children":["Stochastic Differential Equations"],"type":"node"},{"attributes":{},"tag":"p","children":["We note that all of the adjoints except ",{"attributes":{},"tag":"code","children":["QuadratureAdjoint"],"type":"node"}," are applicable to stochastic differential equations."],"type":"node"},{"attributes":{},"tag":"h3","children":["Delay Differential Equations"],"type":"node"},{"attributes":{},"tag":"p","children":["We note that only the discretize-then-optimize methods are applicable to delay differential equations. Constant lag and variable lag delay differential equation parameters can be estimated, but the lag times themselves are unable to be estimated through these automatic differentiation techniques."],"type":"node"},{"attributes":{},"tag":"h3","children":["Hybrid Equations (Equations with events/callbacks) and Jump Equations"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["ForwardDiffSensitivity"],"type":"node"}," can differentiate code with callbacks when ",{"attributes":{},"tag":"code","children":["convert_tspan=true"],"type":"node"},". ",{"attributes":{},"tag":"code","children":["ForwardSensitivity"],"type":"node"}," is not compatible with hybrid equations. The shadowing methods are not compatible with callbacks. All methods based on discrete adjoint sensitivity analysis via automatic differentiation, like ",{"attributes":{},"tag":"code","children":["ReverseDiffAdjoint"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["TrackerAdjoint"],"type":"node"},", or ",{"attributes":{},"tag":"code","children":["QuadratureAdjoint"],"type":"node"}," are fully compatible with events. This applies to ODEs, SDEs, DAEs, and DDEs. The continuous adjoint sensitivities ",{"attributes":{},"tag":"code","children":["BacksolveAdjoint"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["InterpolatingAdjoint"],"type":"node"},", and ",{"attributes":{},"tag":"code","children":["QuadratureAdjoint"],"type":"node"}," are compatible with events for ODEs. ",{"attributes":{},"tag":"code","children":["BacksolveAdjoint"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["InterpolatingAdjoint"],"type":"node"}," can also handle events for SDEs. Use ",{"attributes":{},"tag":"code","children":["BacksolveAdjoint"],"type":"node"}," if the event terminates the time evolution and several states are saved. Currently, the continuous adjoint sensitivities do not support multiple events per time point."],"type":"node"},{"attributes":{},"tag":"h2","children":["Manual VJPs"],"type":"node"},{"attributes":{},"tag":"p","children":["Note that when defining your differential equation the vjp can be manually overwritten by providing the ",{"attributes":{},"tag":"code","children":["AbstractSciMLFunction"],"type":"node"}," definition with  a ",{"attributes":{},"tag":"code","children":["vjp(u,p,t)"],"type":"node"}," that returns a tuple ",{"attributes":{},"tag":"code","children":["f(u,p,t),v->J*v"],"type":"node"}," in the form of ",{"attributes":{"href":"https://www.juliadiff.org/ChainRulesCore.jl/stable/","title":""},"tag":"a","children":["ChainRules.jl"],"type":"node"},". When this is done, the choice of ",{"attributes":{},"tag":"code","children":["ZygoteVJP"],"type":"node"}," will utilize your VJP function during the internal steps of the adjoint. This is useful for models where automatic differentiation may have trouble producing optimal code. This can be paired with ",{"attributes":{"href":"https://github.com/SciML/ModelingToolkit.jl","title":""},"tag":"a","children":["ModelingToolkit.jl"],"type":"node"}," for producing hyper-optimized, sparse, and parallel VJP functions utilizing the automated symbolic conversions."],"type":"node"},{"attributes":{},"tag":"h2","children":["Sensitivity Algorithms"],"type":"node"},{"attributes":{},"tag":"p","children":["The following algorithm choices exist for ",{"attributes":{},"tag":"code","children":["sensealg"],"type":"node"},". See [the sensitivity mathematics page](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," sensitivity_math) for more details on the definition of the methods."],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["ForwardSensitivity\nForwardDiffSensitivity\nBacksolveAdjoint\nInterpolatingAdjoint\nQuadratureAdjoint\nReverseDiffAdjoint\nTrackerAdjoint\nZygoteAdjoint\nForwardLSS\nAdjointLSS\nNILSS\nNILSAS\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["Vector-Jacobian Product (VJP) Choices"],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["ZygoteVJP\nEnzymeVJP\nTrackerVJP\nReverseDiffVJP\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["Noise VJP Choices"],"type":"node"},{"attributes":{"lang":"@docs"},"tag":"codeblock","children":["DiffEqSensitivity.ZygoteNoise\nDiffEqSensitivity.ReverseDiffNoise\n"],"type":"node"},{"attributes":{},"tag":"h2","children":["More Details on Sensitivity Algorithm Choices"],"type":"node"},{"attributes":{},"tag":"p","children":["The following section describes a bit more details to consider when choosing a sensitivity algorithm."],"type":"node"},{"attributes":{},"tag":"h3","children":["Optimize-then-Discretize"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{"href":"https://arxiv.org/abs/1806.07366","title":""},"tag":"a","children":["The original neural ODE paper"],"type":"node"}," popularized optimize-then-discretize with O(1) adjoints via backsolve. This is the methodology ",{"attributes":{},"tag":"code","children":["BacksolveAdjoint"],"type":"node"}," When training non-stiff neural ODEs, ",{"attributes":{},"tag":"code","children":["BacksolveAdjoint"],"type":"node"}," with ",{"attributes":{},"tag":"code","children":["ZygoteVJP"],"type":"node"}," is generally the fastest method. Additionally, this method does not require storing the values of any intermediate points and is thus the most memory efficient. However, ",{"attributes":{},"tag":"code","children":["BacksolveAdjoint"],"type":"node"}," is prone to instabilities whenever the Lipschitz constant is sufficiently large, like in stiff equations, PDE discretizations, and many other contexts, so it is not used by default. When training a neural ODE for machine learning applications, the user should try ",{"attributes":{},"tag":"code","children":["BacksolveAdjoint"],"type":"node"}," and see if it is sufficiently accurate on their problem. More details on this topic can be found in ",{"attributes":{"href":"https://aip.scitation.org/doi/10.1063/5.0060697","title":""},"tag":"a","children":["Stiff Neural Ordinary Differential Equations"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Note that DiffEqFlux's implementation of ",{"attributes":{},"tag":"code","children":["BacksolveAdjoint"],"type":"node"}," includes an extra feature ",{"attributes":{},"tag":"code","children":["BacksolveAdjoint(checkpointing=true)"],"type":"node"}," which mixes checkpointing with ",{"attributes":{},"tag":"code","children":["BacksolveAdjoint"],"type":"node"},". What this method does is that, at ",{"attributes":{},"tag":"code","children":["saveat"],"type":"node"}," points, values from the forward pass are saved. Since the reverse solve should numerically be the same as the forward pass, issues with divergence of the reverse pass are mitigated by restarting the reverse pass at the ",{"attributes":{},"tag":"code","children":["saveat"],"type":"node"}," value from the forward pass. This reduces the divergence and can lead to better gradients at the cost of higher memory usage due to having to save some values of the forward pass. This can stabilize the adjoint in some applications, but for highly stiff applications the divergence can be too fast for this to work in practice."],"type":"node"},{"attributes":{},"tag":"p","children":["To avoid the issues of backwards solving the ODE, ",{"attributes":{},"tag":"code","children":["InterpolatingAdjoint"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["QuadratureAdjoint"],"type":"node"}," utilize information from the forward pass. By default these methods utilize the ",{"attributes":{"href":"https://diffeq.sciml.ai/latest/basics/solution/#Interpolations-1","title":""},"tag":"a","children":["continuous solution"],"type":"node"}," provided by DifferentialEquations.jl in the calculations of the adjoint pass. ",{"attributes":{},"tag":"code","children":["QuadratureAdjoint"],"type":"node"}," uses this to build a continuous function for the solution of adjoint equation and then performs an adaptive quadrature via ",{"attributes":{"href":"https://github.com/SciML/Quadrature.jl","title":""},"tag":"a","children":["Quadrature.jl"],"type":"node"},", while ",{"attributes":{},"tag":"code","children":["InterpolatingAdjoint"],"type":"node"}," appends the integrand to the ODE so it's computed simultaneously to the Lagrange multiplier. When memory is not an issue, we find that the ",{"attributes":{},"tag":"code","children":["QuadratureAdjoint"],"type":"node"}," approach tends to be the most efficient as it has a significantly smaller adjoint differential equation and the quadrature converges very fast, but this form requires holding the full continuous solution of the adjoint which can be a significant burden for large parameter problems. The ",{"attributes":{},"tag":"code","children":["InterpolatingAdjoint"],"type":"node"}," is thus a compromise between memory efficiency and compute efficiency, and is in the same spirit as ",{"attributes":{"href":"https://computing.llnl.gov/projects/sundials","title":""},"tag":"a","children":["CVODES"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["However, if the memory cost of the ",{"attributes":{},"tag":"code","children":["InterpolatingAdjoint"],"type":"node"}," is too high, checkpointing can be used via ",{"attributes":{},"tag":"code","children":["InterpolatingAdjoint(checkpointing=true)"],"type":"node"},". When this is used, the checkpoints default to ",{"attributes":{},"tag":"code","children":["sol.t"],"type":"node"}," of the forward pass (i.e. the saved timepoints usually set by ",{"attributes":{},"tag":"code","children":["saveat"],"type":"node"},"). Then in the adjoint, intervals of ",{"attributes":{},"tag":"code","children":["sol.t[i-1]"],"type":"node"}," to ",{"attributes":{},"tag":"code","children":["sol.t[i]"],"type":"node"}," are re-solved in order to obtain a short interpolation which can be utilized in the adjoints. This at most results in two full solves of the forward pass, but dramatically reduces the computational cost while being a low-memory format. This is the preferred method for highly stiff equations when memory is an issue, i.e. stiff PDEs or large neural DAEs."],"type":"node"},{"attributes":{},"tag":"p","children":["For forward-mode, the ",{"attributes":{},"tag":"code","children":["ForwardSensitivty"],"type":"node"}," is the version that performs the optimize-then-discretize approach. In this case, ",{"attributes":{},"tag":"code","children":["autojacvec"],"type":"node"}," corresponds to the method for computing ",{"attributes":{},"tag":"code","children":["J*v"],"type":"node"}," within the forward sensitivity equations, which is either ",{"attributes":{},"tag":"code","children":["true"],"type":"node"}," or ",{"attributes":{},"tag":"code","children":["false"],"type":"node"}," for whether to use Jacobian-free forward-mode AD (via ForwardDiff.jl) or Jacobian-free numerical differentiation."],"type":"node"},{"attributes":{},"tag":"h3","children":["Discretize-then-Optimize"],"type":"node"},{"attributes":{},"tag":"p","children":["In this approach the discretization is done first and then optimization is done on the discretized system. While traditionally this can be done discrete sensitivity analysis, this is can be equivalently done by automatic differentiation on the solver itself. ",{"attributes":{},"tag":"code","children":["ReverseDiffAdjoint"],"type":"node"}," performs reverse-mode automatic differentiation on the solver via ",{"attributes":{"href":"https://github.com/JuliaDiff/ReverseDiff.jl","title":""},"tag":"a","children":["ReverseDiff.jl"],"type":"node"},", ",{"attributes":{},"tag":"code","children":["ZygoteAdjoint"],"type":"node"}," performs reverse-mode automatic differentiation on the solver via ",{"attributes":{"href":"https://github.com/FluxML/Zygote.jl","title":""},"tag":"a","children":["Zygote.jl"],"type":"node"},", and ",{"attributes":{},"tag":"code","children":["TrackerAdjoint"],"type":"node"}," performs reverse-mode automatic differentiation on the solver via ",{"attributes":{"href":"https://github.com/FluxML/Tracker.jl","title":""},"tag":"a","children":["Tracker.jl"],"type":"node"},". In addition, ",{"attributes":{},"tag":"code","children":["ForwardDiffSensitivty"],"type":"node"}," performs forward-mode automatic differentiation on the solver via ",{"attributes":{"href":"https://github.com/JuliaDiff/ForwardDiff.jl","title":""},"tag":"a","children":["ForwardDiff.jl"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["We note that many studies have suggested that ",{"attributes":{"href":"https://arxiv.org/abs/2005.13420","title":""},"tag":"a","children":["this approach produces"," ","more accurate gradients than the optimize-than-discretize approach"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}