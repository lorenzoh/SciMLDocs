{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/GlobalSensitivity/Xw0Ui/docs/src/index.md","title":"Global Sensitivity Analysis"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Global Sensitivity Analysis"],"type":"node"},{"attributes":{},"tag":"p","children":["Global Sensitivity Analysis (GSA) methods are used to quantify the uncertainty in output of a model w.r.t. the parameters. These methods allow practitioners to measure both parameter's individual contributions and the contribution of their interactions to the output uncertainity."],"type":"node"},{"attributes":{},"tag":"h2","children":["Installation"],"type":"node"},{"attributes":{},"tag":"p","children":["To use this functionality, you must install GlobalSensitivity.jl:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":["]add GlobalSensitivity\nusing GlobalSensitivity"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Note: GlobalSensitivity.jl is unrelated to the GlobalSensitivityAnalysis.jl package."],"type":"node"},{"attributes":{},"tag":"h2","children":["General Interface"],"type":"node"},{"attributes":{},"tag":"p","children":["The general interface for calling a global sensitivity analysis is either:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["effects"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/GlobalSensitivity.gsa"},"tag":"reference","children":["gsa"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["f"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["method"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["param_range"],"type":"node"},{"attributes":{},"tag":"PARAMETERS","children":[{"attributes":{},"tag":"SEMICOLON","children":[";"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["N"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["batch"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"FALSE","children":["false"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["where:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["y=f(x)"],"type":"node"}," is a function that takes in a single vector and spits out a single vector or scalar. If ",{"attributes":{},"tag":"code","children":["batch=true"],"type":"node"},", then ",{"attributes":{},"tag":"code","children":["f"],"type":"node"}," takes in a matrix where each row is a set of parameters, and returns a matrix where each row is a the output for the corresponding row of parameters."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["method"],"type":"node"}," is one of the GSA methods below."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["param_range"],"type":"node"}," is a vector of tuples for the upper and lower bound for the given parameter ",{"attributes":{},"tag":"code","children":["i"],"type":"node"},"."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["N"],"type":"node"}," is a required keyword argument for the number of samples to take in the trajectories/design."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Note that for some methods there is a second interface where one can directly pass the design matrices:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["effects"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/GlobalSensitivity.gsa"},"tag":"reference","children":["gsa"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["f"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["method"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["A"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["B"],"type":"node"},{"attributes":{},"tag":"PARAMETERS","children":[{"attributes":{},"tag":"SEMICOLON","children":[";"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["batch"],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"FALSE","children":["false"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["where ",{"attributes":{},"tag":"code","children":["A"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["B"],"type":"node"}," are design matrices with each row being a set of parameters. Note that ",{"attributes":{},"tag":"code","children":["generate_design_matrices"],"type":"node"}," from ",{"attributes":{"href":"https://github.com/JuliaDiffEq/QuasiMonteCarlo.jl","title":""},"tag":"a","children":["QuasiMonteCarlo.jl"],"type":"node"}," can be used to generate the design matrices."],"type":"node"},{"attributes":{},"tag":"p","children":["The descriptions of the available methods can be found in the Methods section. The GSA interface allows for utilizing batched functions with the ",{"attributes":{},"tag":"code","children":["batch"],"type":"node"}," kwarg discussed above for parallel computation of GSA results."],"type":"node"}],"type":"node"}],"type":"node"}