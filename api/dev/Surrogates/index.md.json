{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/Surrogates/zwNvG/docs/src/index.md","title":"Overview"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"p","children":[{"attributes":{"src":"images/Surrogates.png","alt":""},"tag":"img","children":["SurrogatesLogo"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h1","children":["Overview"],"type":"node"},{"attributes":{},"tag":"p","children":["A surrogate model is an approximation method that mimics the behavior of a computationally expensive simulation. In more mathematical terms: suppose we are attempting to optimize a function ",{"attributes":{},"tag":"math","children":["\\; f(p)"],"type":"node"},", but each calculation of ",{"attributes":{},"tag":"math","children":["\\; f"],"type":"node"}," is very expensive. It may be the case that we need to solve a PDE for each point or use advanced numerical linear algebra machinery, which is usually costly. The idea is then to develop a surrogate model ",{"attributes":{},"tag":"math","children":["\\; g"],"type":"node"}," which approximates ",{"attributes":{},"tag":"math","children":["\\; f"],"type":"node"}," by training on previous data collected from evaluations of ",{"attributes":{},"tag":"math","children":["\\; f"],"type":"node"},". The construction of a surrogate model can be seen as a three-step process:"],"type":"node"},{"attributes":{},"tag":"ol","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Sample selection"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Construction of the surrogate model"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Surrogate optimization"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The sampling methods are super important for the behavior of the Surrogate. At the moment they are:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Grid sample"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Uniform sample"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Sobol sample"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Latin Hypercube sample"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Low discrepancy sample"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The available surrogates are:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Linear"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Radial Basis"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Kriging"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Custom Kriging provided with Stheno"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Neural Network"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Support Vector Machine"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Random Forest"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Second Order Polynomial"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Inverse Distance"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["After the surrogate is built, we need to optimize it with respect to some objective function. That is, simultaneously looking for a minimum ",{"attributes":{},"tag":"strong","children":["and"],"type":"node"}," sampling the most unknown region. The available optimization methods are:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Stochastic RBF (SRBF)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Lower confidence bound strategy (LCBS)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Expected improvement (EI)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Dynamic coordinate search (DYCORS)"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Multi-output Surrogates"],"type":"node"},{"attributes":{},"tag":"p","children":["In certain situations, the function being modeled may have a multi-dimensional output space. In such a case, the surrogate models can take advantage of correlations between the observed output variables to obtain more accurate predictions."],"type":"node"},{"attributes":{},"tag":"p","children":["When constructing the original surrogate, each element of the passed ",{"attributes":{},"tag":"code","children":["y"],"type":"node"}," vector should itself be a vector. For example, the following ",{"attributes":{},"tag":"code","children":["y"],"type":"node"}," are all valid."],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["using Surrogates\nusing StaticArrays\n\nx = sample(5, [0.0; 0.0], [1.0; 1.0], SobolSample())\nf_static = (x) -> StaticVector(x[1], log(x[2]*x[1]))\nf = (x) -> [x, log(x)/2]\n\ny = f_static.(x)\ny = f.(x)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Currently, the following are implemented as multi-output surrogates:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Radial Basis"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Neural Network (via Flux)"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Second Order Polynomial"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Inverse Distance"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":["Custom Kriging (via Stheno)"],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Gradients"],"type":"node"},{"attributes":{},"tag":"p","children":["The surrogates implemented here are all automatically differentiable via Zygote. Because of this property, surrogates are useful models for processes which aren't explicitly differentiable, and can be used as layers in, for instance, Flux models."],"type":"node"},{"attributes":{},"tag":"h1","children":["Installation"],"type":"node"},{"attributes":{},"tag":"p","children":["Surrogates is registered in the Julia General Registry. In the REPL:"],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["]add Surrogates\n"],"type":"node"},{"attributes":{},"tag":"p","children":["You can obtain the current master with:"],"type":"node"},{"attributes":{"lang":""},"tag":"codeblock","children":["]add https://github.com/JuliaDiffEq/Surrogates.jl#master\n"],"type":"node"},{"attributes":{},"tag":"h1","children":["Quick example"],"type":"node"},{"attributes":{"lang":"@example"},"tag":"codeblock","children":["using Surrogates\nnum_samples = 10\nlb = 0.0\nub = 10.0\n\n#Sampling\nx = sample(num_samples,lb,ub,SobolSample())\nf = x-> log(x)*x^2+x^3\ny = f.(x)\n\n#Creating surrogate\nalpha = 2.0\nn = 6\nmy_lobachevsky = LobachevskySurrogate(x,y,lb,ub,alpha=alpha,n=n)\n\n#Approximating value at 5.0\nvalue = my_lobachevsky(5.0)\n\n#Adding more data points\nsurrogate_optimize(f,SRBF(),lb,ub,my_lobachevsky,UniformSample())\n\n#New approximation\nvalue = my_lobachevsky(5.0)\n"],"type":"node"}],"type":"node"}],"type":"node"}