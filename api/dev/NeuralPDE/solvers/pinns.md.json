{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/NeuralPDE/y7uHG/docs/src/solvers/pinns.md","title":"Physics-Informed Neural Networks"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{},"tag":"h1","children":["Physics-Informed Neural Networks"],"type":"node"},{"attributes":{},"tag":"p","children":["Using the PINNs solver, we can solve general nonlinear PDEs:"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{"src":"https://user-images.githubusercontent.com/12683885/86625781-5648c800-bfce-11ea-9d99-fbcb5c37fe0c.png","alt":""},"tag":"img","children":["generalPDE"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["with suitable boundary conditions:"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{"src":"https://user-images.githubusercontent.com/12683885/86625874-8001ef00-bfce-11ea-9417-1a216c7d90aa.png","alt":""},"tag":"img","children":["bcs"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["where time t is a special component of x, and Ω contains the temporal domain."],"type":"node"},{"attributes":{},"tag":"p","children":["PDEs are defined using the ModelingToolkit.jl ",{"attributes":{},"tag":"code","children":["PDESystem"],"type":"node"},":"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"MACROCALL","children":[{"attributes":{},"tag":"AT_SIGN","children":["@"],"type":"node"},{"attributes":{},"tag":"MACRO_NAME","children":["named"],"type":"node"},{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["pde_system"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/ModelingToolkit.PDESystem"},"tag":"reference","children":["PDESystem"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["eq"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["bcs"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["domains"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["param"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/SymbolicNumericIntegration.var"},"tag":"reference","children":["var"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Here, ",{"attributes":{},"tag":"code","children":["eq"],"type":"node"}," is the equation, ",{"attributes":{},"tag":"code","children":["bcs"],"type":"node"}," represents the boundary conditions, ",{"attributes":{},"tag":"code","children":["param"],"type":"node"}," is the parameter of the equation (like ",{"attributes":{},"tag":"code","children":["[x,y]"],"type":"node"},"), and ",{"attributes":{},"tag":"code","children":["var"],"type":"node"}," represents variables (like ",{"attributes":{},"tag":"code","children":["[u]"],"type":"node"},")."],"type":"node"},{"attributes":{},"tag":"p","children":["The ",{"attributes":{},"tag":"code","children":["PhysicsInformedNN"],"type":"node"}," discretizer is defined as:"],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["discretization"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/NeuralPDE.PhysicsInformedNN"},"tag":"reference","children":["PhysicsInformedNN"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{"reftype":"symbol","document_id":"references/RecursiveArrayTools.chain"},"tag":"reference","children":["chain"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                                   "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["strategy"],"type":"node"},{"attributes":{},"tag":"PARAMETERS","children":[{"attributes":{},"tag":"SEMICOLON","children":[";"],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                                   "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["init_params"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                                   "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{"reftype":"symbol","document_id":"references/ExponentialUtilities.phi"},"tag":"reference","children":["phi"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                                   "],"type":"node"},{"attributes":{},"tag":"KW","children":[{"attributes":{},"tag":"IDENTIFIER","children":["derivative"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["nothing"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"NEWLINE_WS","children":["\n                                   "],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["Keyword arguments:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["chain"],"type":"node"}," is a Flux.jl chain, where the input of NN equals the number of dimensions and output equals the number of equations in the system,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["strategy"],"type":"node"}," determines which training strategy will be used,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["init_params"],"type":"node"}," is the initial parameter of the neural network. If nothing then automatically generated from the neural network,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["phi"],"type":"node"}," is a trial solution,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["derivative"],"type":"node"}," is a method that calculates the derivative."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["The method ",{"attributes":{},"tag":"code","children":["discretize"],"type":"node"}," interprets from the ModelingToolkit PDE form to the PINNs Problem."],"type":"node"},{"attributes":{"lang":"julia"},"tag":"codeblock","children":[{"attributes":{},"tag":"julia","children":[{"attributes":{},"tag":"EQ","children":[{"attributes":{},"tag":"IDENTIFIER","children":["prob"],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"EQ","children":["="],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"CALL","children":[{"attributes":{"reftype":"symbol","document_id":"references/SciMLBase.discretize"},"tag":"reference","children":["discretize"],"type":"node"},{"attributes":{},"tag":"LPAREN","children":["("],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["pde_system"],"type":"node"},{"attributes":{},"tag":"COMMA","children":[","],"type":"node"},{"attributes":{},"tag":"WHITESPACE","children":[" "],"type":"node"},{"attributes":{},"tag":"IDENTIFIER","children":["discretization"],"type":"node"},{"attributes":{},"tag":"RPAREN","children":[")"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["which outputs an ",{"attributes":{},"tag":"code","children":["OptimizationProblem"],"type":"node"}," for ",{"attributes":{"href":"https://Optimization.sciml.ai/dev/","title":""},"tag":"a","children":["Optimization.jl"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"h2","children":["Training strategy"],"type":"node"},{"attributes":{},"tag":"p","children":["List of training strategies that are available now:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["GridTraining(dx)"],"type":"node"},": Initialize points on a lattice uniformly spaced via ",{"attributes":{},"tag":"code","children":["dx"],"type":"node"},". If ",{"attributes":{},"tag":"code","children":["dx"],"type":"node"}," is a scalar, then ",{"attributes":{},"tag":"code","children":["dx"],"type":"node"}," corresponds to the spacing in each direction. If ",{"attributes":{},"tag":"code","children":["dx"],"type":"node"}," is a vector, then it should be sized to match the number of dimensions and corresponds to the spacing per direction."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["StochasticTraining(points;bcs_points = points)"],"type":"node"},": ",{"attributes":{},"tag":"code","children":["points"],"type":"node"}," is number of stochastically sampled points from the domain, ",{"attributes":{},"tag":"code","children":["bcs_points"],"type":"node"}," is number of points for boundary conditions(by default, it equals ",{"attributes":{},"tag":"code","children":["points"],"type":"node"},").",{"attributes":{},"tag":"br","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"},"In each optimization iteration, we randomly select a new subset of points from a full training set."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["QuasiRandomTraining(points;bcs_points = points, sampling_alg = UniformSample(), resampling = true, minibatch=500)"],"type":"node"},": The training set is generated on quasi-random low discrepency sequences. ",{"attributes":{},"tag":"code","children":["points"],"type":"node"}," is the number of quasi-random points in every subset or set, ",{"attributes":{},"tag":"code","children":["bcs_points"],"type":"node"}," is number of points for boundary conditions(by default, it equals ",{"attributes":{},"tag":"code","children":["points"],"type":"node"},"), ",{"attributes":{},"tag":"code","children":["sampling_alg"],"type":"node"}," is the quasi-Monte Carlo sampling algorithm. ",{"attributes":{},"tag":"code","children":["if resampling = false"],"type":"node"},", the full training set is generated in advance before training, and at each iteration, one subset is randomly selected out of the batch.",{"attributes":{},"tag":"code","children":["minibatch"],"type":"node"}," is the number of subsets in full training set. The number of the total points is ",{"attributes":{},"tag":"code","children":["length(lb) * points * minibatch"],"type":"node"},", where ",{"attributes":{},"tag":"code","children":["lb"],"type":"node"}," is the lower bound and ",{"attributes":{},"tag":"code","children":["length(lb)"],"type":"node"}," is the dimensionality. ",{"attributes":{},"tag":"code","children":["if resampling = true"],"type":"node"},", the training set isn't generated beforehand, and one set of quasi-random points is generated directly at each iteration in runtime. In this case ",{"attributes":{},"tag":"code","children":["minibatch"],"type":"node"}," has no effect."],"type":"node"},{"attributes":{},"tag":"p","children":["See the ",{"attributes":{"href":"https://github.com/SciML/QuasiMonteCarlo.jl","title":""},"tag":"a","children":["QuasiMonteCarlo.jl"],"type":"node"}," for the full set of quasi-random sampling algorithms which are available."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["QuadratureTraining(;quadrature_alg=CubatureJLh(),reltol= 1e-6,abstol= 1e-3,maxiters=1e3,batch=100)"],"type":"node"},": The loss is computed as an approximation of the integral of the PDE loss at each iteration using ",{"attributes":{"href":"https://en.wikipedia.org/wiki/Adaptive_quadrature","title":""},"tag":"a","children":["adaptive quadrature methods"],"type":"node"}," via the differentiable ",{"attributes":{"href":"https://github.com/SciML/Quadrature.jl","title":""},"tag":"a","children":["Quadrature.jl"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["quadrature_alg"],"type":"node"}," is quadrature algorithm,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["reltol"],"type":"node"},": relative tolerance,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["abstol"],"type":"node"},": absolute tolerance,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["maxiters"],"type":"node"},": the maximum number of iterations in quadrature algorithm,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["batch"],"type":"node"},": the preferred number of points to batch. If ",{"attributes":{},"tag":"code","children":["batch"],"type":"node"}," = 0, the number of points in the batch is determined adaptively by the algorithm."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["See the ",{"attributes":{"href":"https://github.com/SciML/Quadrature.jl","title":""},"tag":"a","children":["Quadrature.jl"],"type":"node"}," documentation for the choices of quadrature methods."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Transfer Learning with neural_adapter"],"type":"node"},{"attributes":{},"tag":"p","children":["Transfer learning is a machine learning technique where a model trained on one task is re-purposed on a second related task."],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["neural_adapter(loss_function,initθ,pde_system,strategy)"],"type":"node"},": the method that trains a neural network using the results from one already obtained prediction.",{"attributes":{},"tag":"br","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"},"Keyword arguments:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["loss_function"],"type":"node"},":the body of loss function,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["initθ"],"type":"node"},": the initial parameter of new neural networks,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["pde_system"],"type":"node"},": PDE are defined using the ModelingToolkit.jl ,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["strategy"],"type":"node"},": determines which training strategy will be used,"],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["neural_adapter(loss_functions::Array,initθ,pde_systems::Array,strategy)"],"type":"node"},": the method that trains a neural network using the results from many already obtained predictions. Keyword arguments:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["loss_functions"],"type":"node"},": the body of loss functions,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["initθ"],"type":"node"},": the initial parameter of the neural network,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["pde_systems"],"type":"node"},": PDEs are defined using the ModelingToolkit.jl,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["strategy"],"type":"node"},": determines which training strategy will be used."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Low-level API"],"type":"node"},{"attributes":{},"tag":"p","children":["These additional methods exist to help with introspection:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["symbolic_discretize(pde_system,discretization)"],"type":"node"},": This method is the same as ",{"attributes":{},"tag":"code","children":["discretize"],"type":"node"}," but instead returns the unevaluated Julia function to allow the user to see the generated training code."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["build_symbolic_loss_function(eqs,indvars,depvars, phi, derivative, initθ; bc_indvars=nothing)"],"type":"node"},": return symbolic inner representation for the loss function. Keyword arguments:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["eqs"],"type":"node"},": equation or equations,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["indvars"],"type":"node"},": independent variables (the parameter of the equation),"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["depvars"],"type":"node"},": dependent variables,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["phi"],"type":"node"},":trial solution,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["derivative"],"type":"node"},": method that calculates the derivative,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["initθ"],"type":"node"},": the initial parameter of the neural network,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["bc_indvars"],"type":"node"},": independent variables for each boundary conditions."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["build_symbolic_equation(eq,indvars,depvars)"],"type":"node"},": return symbolic inner representation for the equation."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["build_loss_function(eqs, indvars, depvars, phi, derivative, initθ; bc_indvars=nothing)"],"type":"node"},": returns the body of loss function, which is the executable Julia function, for the main equation or boundary condition."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["get_loss_function(loss_functions, train_sets, strategy::TrainingStrategies; τ = nothing)"],"type":"node"},": return the executable loss function. Keyword arguments:"],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["loss_functions"],"type":"node"},": the body of loss function, which is created using  ",{"attributes":{},"tag":"code","children":["build_loss_function"],"type":"node"},","],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["train_sets"],"type":"node"},": training sets,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["strategy"],"type":"node"},": training strategy,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["τ"],"type":"node"},": normalizing coefficient for loss function. If ",{"attributes":{},"tag":"code","children":["τ"],"type":"node"}," is nothing, then it is automatically set to ",{"attributes":{},"tag":"code","children":["1/n"],"type":"node"}," where ",{"attributes":{},"tag":"code","children":["n"],"type":"node"}," is the number of points checked in the loss function."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["get_phi(chain, parameterless_type_θ)"],"type":"node"},": return function for trial solution."],"type":"node"},{"attributes":{},"tag":"ul","children":[{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["chain"],"type":"node"},": neural network,"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["parameterless_type_θ"],"type":"node"},": number format type(Float64/Float32) of weights of neural network."],"type":"node"}],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["get_numeric_derivative()"],"type":"node"},": return method that calculates the derivative."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["generate_training_sets(domains,dx,bcs,_indvars::Array,_depvars::Array)"],"type":"node"},": return training sets for equations and boundary condition, that is used for GridTraining strategy."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["get_variables(eqs,_indvars::Array,_depvars::Array)"],"type":"node"},": returns all variables that are used in each equations or boundary condition."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["get_argument(eqs,_indvars::Array,_depvars::Array)"],"type":"node"},": returns all arguments that are used in each equations or boundary condition."],"type":"node"}],"type":"node"},{"attributes":{},"tag":"li","children":[{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"code","children":["get_bounds(domains,bcs,_indvars::Array,_depvars::Array)"],"type":"node"},": return pairs with lower and upper bounds for all domains. It is used for all non-grid training strategy: StochasticTraining, QuasiRandomTraining, QuadratureTraining."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["See how this can be used in ",{"attributes":{},"tag":"code","children":["Debugging"],"type":"node"}," section or ",{"attributes":{},"tag":"code","children":["2-D Burgers equation, low-level API"],"type":"node"},"  examples."],"type":"node"}],"type":"node"}],"type":"node"}