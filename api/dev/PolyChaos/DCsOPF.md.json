{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/PolyChaos/THVqe/docs/src/DCsOPF.md","title":"Chance-Constrained DC Optimal Power Flow"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":"@setup mysetup"},"tag":"codeblock","children":["using PolyChaos, JuMP, MosekTools, LinearAlgebra\nA = [ -1 1 0 0; -1 0 1 0; -1 0 0 1 ; 0 1 -1 0; 0 0 -1 1] # incidence matrix\nNl, N = size(A,1), size(A,2)\nBbr = diagm(0 => -( 2 .+ 10*rand(Nl) )) # line parameters\nΨ = [ zeros(Nl)  -Bbr*A[:,2:end]*inv(A[:,2:end]'*Bbr*A[:,2:end]) ] # PTDF matrix\nCp, Cd = [1 0; 0 0; 0 0; 0 1], [0 0; 1 0; 0 1; 0 0 ] # book-keeping\nNg, Nd = size(Cp,2), size(Cd,2)\nc = 4 .+ 10*rand(Ng) # cost function parameters\nλp, λl = 1.6*ones(Ng), 1.6*ones(Nl) # lambdas for chance constraint reformulations\npmax, pmin = 10*ones(Ng), zeros(Ng) # engineering limits\nplmax, plmin = 10*ones(Nl), -10*ones(Nl) # engineering limits\ndeg = 1\nopq = [Uniform01OrthoPoly(deg; Nrec=5*deg), Uniform01OrthoPoly(deg; Nrec=5*deg)]\nmop = MultiOrthoPoly(opq, deg)\nNpce = mop.dim\nd = zeros(Nd,Npce) # PCE coefficients of load\nd[1,[1,2]] = convert2affinePCE(1., 0.1, mop.uni[1], kind=\"μσ\")\nd[2,[1,3]] = convert2affinePCE(2., 0.2, mop.uni[2], kind=\"μσ\")\nfunction buildSOC(x::Vector,mop::MultiOrthoPoly)\n    t = [ sqrt(Tensor(2,mop).get([i,i])) for i in 0:mop.dim-1 ]\n    (t.*x)[2:end]\nend\nmodel = Model(with_optimizer(Mosek.Optimizer))\n@variable(model, p[i in 1:Ng,j in 1:Npce], base_name=\"p\")\n@constraint(model, energy_balance[j in 1:Npce], sum(p[i,j] for i in 1:Ng) - sum(d[i,j] for i in 1:Nd) == 0)\n@constraint(model, con_pmax[i in 1:Ng], [1/λp[i]*(pmax[i] - mean(p[i,:],mop)); buildSOC(p[i,:],mop)] in SecondOrderCone())\n@constraint(model, con_pmin[i in 1:Ng], [1/λp[i]*(mean(p[i,:],mop) - pmin[i]); buildSOC(p[i,:],mop)] in SecondOrderCone())\npl = Ψ*(Cp*p + Cd*d)\n@constraint(model, con_plmax[i in 1:Nl], [1/λl[i]*(plmax[i] - mean(pl[1,:],mop)); buildSOC(pl[i,:],mop)] in SecondOrderCone())\n@constraint(model, con_plmin[i in 1:Nl], [1/λl[i]*(mean(pl[1,:],mop) - plmin[i]); buildSOC(pl[i,:],mop)] in SecondOrderCone())\n@objective(model, Min, sum( mean(p[i,:],mop)*c[i] for i in 1:Ng) )\noptimize!(model) # here we go\n@assert termination_status(model) == MOI.OPTIMAL \"Model not solved to optimality.\"\npsol, plsol, obj = value.(p), value.(pl), objective_value(model)\np_moments = [ [mean(psol[i,:],mop) var(psol[i,:],mop) ] for i in 1:Ng ]\npbr_moments = [ [mean(plsol[i,:],mop) var(plsol[i,:],mop) ] for i in 1:Nl ]\n"],"type":"node"},{"attributes":{},"tag":"h1","children":["Chance-Constrained DC Optimal Power Flow"],"type":"node"},{"attributes":{},"tag":"p","children":["The purpose of this tutorial is to show how polynomial chaos can be leveraged to solve optimization problems under uncertainty. Specifically, we study chance-constrained DC optimal power flow as it is presented in ",{"attributes":{"href":"https://www.sciencedirect.com/science/article/pii/S235246771830105X","title":""},"tag":"a","children":["this paper"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["We consider the following 4-bus system that has a total of two generators (buses 1 and 3) and two loads (buses 2 and 4):"],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{"src":"assets/DCsOPF_drawing.png","alt":""},"tag":"img","children":["4-bus system"],"type":"node"}],"type":"node"},{"attributes":{},"tag":"p","children":["We formalize the numbering of the generators (superscript ",{"attributes":{},"tag":"math","children":["g"],"type":"node"},"), loads (superscript ",{"attributes":{},"tag":"math","children":["d"],"type":"node"}," for demand), and branches (superscript ",{"attributes":{},"tag":"math","children":["br"],"type":"node"},") as follows"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\mathcal{N}^g = \\{ 1, 3\\}, \\, \\mathcal{N}^d = \\{ 2, 4\\}, \\, \\mathcal{N}^{br} = \\{ 1, 2, 3, 4, 5 \\}."],"type":"node"},{"attributes":{},"tag":"p","children":["With each generator we associate a linear cost with cost coefficient ",{"attributes":{},"tag":"math","children":["c_i"],"type":"node"}," for all ",{"attributes":{},"tag":"math","children":["i \\in \\mathcal{N}^g"],"type":"node"},". Each generator must adhere to its engineering limits given by ",{"attributes":{},"tag":"math","children":["(\\underline{p}_i^g , \\overline{p}_i^g )"],"type":"node"}," for all ",{"attributes":{},"tag":"math","children":["i \\in \\mathcal{N}^g"],"type":"node"},". Also, each line is constrained by its limits ",{"attributes":{},"tag":"math","children":["(\\underline{p}_i^{br}, \\overline{p}_i^{br})"],"type":"node"}," for all ",{"attributes":{},"tag":"math","children":["i \\in \\mathcal{N}^{br}"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["We model the demand at the buses ",{"attributes":{},"tag":"math","children":["i \\in \\mathcal{N}^d"],"type":"node"}," in terms of uniform distributions with known mean ",{"attributes":{},"tag":"math","children":["\\mu_i"],"type":"node"}," and standard deviation ",{"attributes":{},"tag":"math","children":["\\sigma_i"],"type":"node"},". We concisely write"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\mathsf{p}_i^d \\sim \\mathsf{U}(\\mu_i, \\sigma_i) \\quad \\forall i \\in \\mathcal{N}^d."],"type":"node"},{"attributes":{},"tag":"p","children":["For simplicity we consider DC conditions. Hence, energy balance reads"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\sum_{i \\in \\mathcal{N}^g} \\mathsf{p}_i^g - \\sum_{i \\in \\mathcal{N}^d} \\mathsf{p}_i^d = 0,"],"type":"node"},{"attributes":{},"tag":"p","children":["and the vector of branch flows is computed from the power transfer distribution factor (PTDF) matrix ",{"attributes":{},"tag":"math","children":["\\Psi"],"type":"node"}," via"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\mathsf{p}^{br} = \\Psi (C^p\\mathsf{p}^g + C^d\\mathsf{p}^d)."],"type":"node"},{"attributes":{},"tag":"p","children":["The matrices ",{"attributes":{},"tag":"math","children":["C^p"],"type":"node"}," and ",{"attributes":{},"tag":"math","children":["C^d"],"type":"node"}," map the generators and the loads to the correct buses, respectively."],"type":"node"},{"attributes":{},"tag":"p","children":["We want to solve a chance-constrained optimal power flow problem under DC conditions. According to ",{"attributes":{"href":"https://www.sciencedirect.com/science/article/pii/S235246771830105X","title":""},"tag":"a","children":["this paper"],"type":"node"},", we can formulate the problem as $$\\underset}}} ",{"attributes":{},"tag":"backslash","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"},", \\sum__g} c_i \\mathbb( \\mathsf_i^g)$$ subject to"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\sum_{i \\in \\mathcal{N}^g} \\mathsf{p}_i^g - \\sum_{i \\in \\mathcal{N}^d} \\mathsf{p}_i^d = 0, \\\\\n\\underline{p}_i^g \\leq \\mathbb{E}(\\mathsf{p}_i^g) \\pm \\lambda_i^g \\sqrt{\\mathbb{V}(\\mathsf{p}_i^g)} \\leq \\overline{p}_i^g  \\forall i \\in \\mathcal{N}^g,\\\\\n\\underline{p}_i^{br} \\leq \\mathbb{E}(\\mathsf{p}_i^{br}) \\pm \\lambda_i^{br} \\sqrt{\\mathbb{V}(\\mathsf{p}_i^{br})} \\leq \\overline{p}_i^{br} \\forall i \\in \\mathcal{N}^{br},"],"type":"node"},{"attributes":{},"tag":"p","children":["which minimizes the total expected generation cost subject to the DC power flow equations and chance-constrained engineering limits."],"type":"node"},{"attributes":{},"tag":"p","children":["Let's solve the problem using ",{"attributes":{},"tag":"code","children":["PolyChaos"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["JuMP"],"type":"node"},", using ",{"attributes":{},"tag":"code","children":["Mosek"],"type":"node"}," as a solver."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["using PolyChaos, JuMP, MosekTools, LinearAlgebra\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Let's define system-specific quantities such as the incidence matrix and the branch flow parameters. From these we can compute the PTDF matrix ",{"attributes":{},"tag":"math","children":["\\Psi"],"type":"node"}," (assuming the slack is at bus 1)."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["A = [ -1 1 0 0; -1 0 1 0; -1 0 0 1 ; 0 1 -1 0; 0 0 -1 1] # incidence matrix\nNl, N = size(A,1), size(A,2)\nBbr = diagm(0 => -( 2 .+ 10*rand(Nl) )) # line parameters\nΨ = [ zeros(Nl)  -Bbr*A[:,2:end]*inv(A[:,2:end]'*Bbr*A[:,2:end]) ] # PTDF matrix\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Now we can continue the remaining ingredients that specify our systems:"],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["Cp, Cd = [1 0; 0 0; 0 0; 0 1], [0 0; 1 0; 0 1; 0 0 ] # book-keeping\nNg, Nd = size(Cp,2), size(Cd,2)\nc = 4 .+ 10*rand(Ng) # cost function parameters\nλp, λl = 1.6*ones(Ng), 1.6*ones(Nl) # lambdas for chance constraint reformulations\npmax, pmin = 10*ones(Ng), zeros(Ng) # engineering limits\nplmax, plmin = 10*ones(Nl), -10*ones(Nl) # engineering limits\n"],"type":"node"},{"attributes":{},"tag":"p","children":["We specify the uncertainty using ",{"attributes":{},"tag":"code","children":["PolyChaos"],"type":"node"},":"],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["deg = 1\nopq = [Uniform01OrthoPoly(deg; Nrec=5*deg), Uniform01OrthoPoly(deg; Nrec=5*deg)]\nmop = MultiOrthoPoly(opq, deg)\nNpce = mop.dim\n"],"type":"node"},{"attributes":{},"tag":"p","children":["It remains to specify the PCE coefficients, for which we will use ",{"attributes":{},"tag":"code","children":["convert2affine"],"type":"node"},"."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["d = zeros(Nd,Npce) # PCE coefficients of load\nd[1,[1,2]] = convert2affinePCE(1., 0.1, mop.uni[1], kind=\"μσ\")\nd[2,[1,3]] = convert2affinePCE(2., 0.2, mop.uni[2], kind=\"μσ\")\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Now, let's put it all into an optimization problem, specifically a second-order cone program. To build the second-order cone constraints we define a helper function ",{"attributes":{},"tag":"code","children":["buildSOC"],"type":"node"},"."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["function buildSOC(x::Vector,mop::MultiOrthoPoly)\n    t = [ sqrt(Tensor(2,mop).get([i,i])) for i in 0:mop.dim-1 ]\n    (t.*x)[2:end]\nend\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Finally, let's use ",{"attributes":{},"tag":"code","children":["JuMP"],"type":"node"}," to formulate and then solve the problem. We use ",{"attributes":{},"tag":"code","children":["Mosek"],"type":"node"}," to solve the problem; for academic use there are ",{"attributes":{"href":"https://www.mosek.com/products/academic-licenses/","title":""},"tag":"a","children":["free license"],"type":"node"},"."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["model = Model(with_optimizer(Mosek.Optimizer))\n@variable(model, p[i in 1:Ng,j in 1:Npce], base_name=\"p\")\n@constraint(model, energy_balance[j in 1:Npce], sum(p[i,j] for i in 1:Ng) - sum(d[i,j] for i in 1:Nd) == 0)\n@constraint(model, con_pmax[i in 1:Ng], [1/λp[i]*(pmax[i] - mean(p[i,:],mop)); buildSOC(p[i,:],mop)] in SecondOrderCone())\n@constraint(model, con_pmin[i in 1:Ng], [1/λp[i]*(mean(p[i,:],mop) - pmin[i]); buildSOC(p[i,:],mop)] in SecondOrderCone())\npl = Ψ*(Cp*p + Cd*d)\n@constraint(model, con_plmax[i in 1:Nl], [1/λl[i]*(plmax[i] - mean(pl[1,:],mop)); buildSOC(pl[i,:],mop)] in SecondOrderCone())\n@constraint(model, con_plmin[i in 1:Nl], [1/λl[i]*(mean(pl[1,:],mop) - plmin[i]); buildSOC(pl[i,:],mop)] in SecondOrderCone())\n@objective(model, Min, sum( mean(p[i,:],mop)*c[i] for i in 1:Ng) )\noptimize!(model) # here we go\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Let's extract the numerical values of the optimal solution."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["@assert termination_status(model) == MOI.OPTIMAL \"Model not solved to optimality.\"\npsol, plsol, obj = value.(p), value.(pl), objective_value(model)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Great, we've solved the problem. How do we now make sense of the solution? For instance, we can look at the moments of the generated power:"],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["p_moments = [ [mean(psol[i,:],mop) var(psol[i,:],mop) ] for i in 1:Ng ]\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Simiarly, we can study the moments for the branch flows:"],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["pbr_moments = [ [mean(plsol[i,:],mop) var(plsol[i,:],mop) ] for i in 1:Nl ]\n"],"type":"node"}],"type":"node"}],"type":"node"}