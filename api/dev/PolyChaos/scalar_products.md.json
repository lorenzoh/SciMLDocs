{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/PolyChaos/THVqe/docs/src/scalar_products.md","title":"[Computation of Scalar Products]( ComputationOfScalarProducts)"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":"@setup mysetup"},"tag":"codeblock","children":["using PolyChaos, LinearAlgebra\ndeg, n = 4, 20\ns_α, s_β = 2.1, 3.2\nopq = Beta01OrthoPoly(deg, s_α, s_β; Nrec=n, addQuadrature=true)\nnormsq = computeSP2(opq)\nm = 3\nt = Tensor(3,opq)\nt.get([1,2,3])\nT = [ t.get([i1,i2,i3]) for i1=0:dim(opq)-1, i2=0:dim(opq)-1, i3=0:dim(opq)-1]\n#@show normsq == diag(T[:,:,1])\n#@show normsq == diag(T[:,1,:])\n#@show normsq == diag(T[1,:,:])\nt2 = Tensor(2, opq)\n@show normsq == [ t2.get([i, i]) for i in 0:dim(opq)-1]\nusing SpecialFunctions\nsupp = (0, 1)\nw(t) = (t^(s_α-1)*(1-t)^(s_β-1)/SpecialFunctions.beta(s_α,s_β))\nmy_meas = Measure(\"my_meas\", w, supp, false)\nmy_opq = OrthoPoly(\"my_op\", deg, my_meas; Nrec=n, addQuadrature = true)\nmy_normsq = computeSP2(my_opq)\nmy_t = Tensor(m, my_opq)\nmy_T = [ my_t.get([i1,i2,i3]) for i1=0:dim(opq)-1,i2=0:dim(opq)-1,i3=0:dim(opq)-1]\n@show abs.(normsq-my_normsq)\n@show norm(T-my_T)\nmop = MultiOrthoPoly([opq, my_opq], deg)\nmt2 = Tensor(2,mop)\nmt3 = Tensor(3,mop)\nmT2 = [ mt2.get([i,i]) for i=0:dim(mop)-1 ]\nmop.ind\nind_opq = findUnivariateIndices(1,mop.ind)\nind_my_opq = findUnivariateIndices(2,mop.ind)\n@show mT2[ind_opq] - normsq\n@show mT2[ind_my_opq] - my_normsq;\n"],"type":"node"},{"attributes":{},"tag":"h1","children":["[Computation of Scalar Products](",{"attributes":{},"tag":"citation","children":[{"mimes":{"text/plain":"Any[]"},"type":"leaf"},{"mimes":{"text/plain":"Dict{Symbol, String}()"},"type":"leaf"}],"type":"node"}," ComputationOfScalarProducts)"],"type":"node"},{"attributes":{},"tag":"p","children":["By now, we are able to construct orthogonal polynomials, and to construct quadrature rules for a given nonnegative weight function, respectively. Now we combine both ideas to solve integrals involving the orthogonal polynomials"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\langle \\phi_{i_1} \\phi_{i_2} \\cdots \\phi_{i_{m-1}}, \\phi_{i_m} \\rangle\n= \\int \\phi_{i_1}(t) \\phi_{i_2}(t) \\cdots \\phi_{i_{m-1}}(t) \\phi_{i_m}(t) w(t) \\mathrm{d} t,"],"type":"node"},{"attributes":{},"tag":"p","children":["both for the univariate and multivariate case. The integrand is a polynomial (possibly multivariate) that can be solved exactly with the appropriate Gauss quadrature rules."],"type":"node"},{"attributes":{"class":"note"},"tag":"admonition","children":[{"attributes":{},"tag":"admonitiontitle","children":["Note"],"type":"node"},{"attributes":{},"tag":"admonitionbody","children":[{"attributes":{},"tag":"p","children":["To simplify notation we drop the integration interval. It is clear from the context."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Univariate Polynomials"],"type":"node"},{"attributes":{},"tag":"h3","children":["Classical Polynomials"],"type":"node"},{"attributes":{},"tag":"p","children":["Let's begin with a univariate basis for some ",{"attributes":{},"tag":"em","children":["classical"],"type":"node"}," orthogonal polynomial"],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["using PolyChaos\ndeg, n = 4, 20\ns_α, s_β = 2.1, 3.2\nopq = Beta01OrthoPoly(deg, s_α, s_β; Nrec=n, addQuadrature=true)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["By setting ",{"attributes":{},"tag":"code","children":["addQuadrature = true"],"type":"node"}," (which is default), an ",{"attributes":{},"tag":"math","children":["n"],"type":"node"},"-point Gauss quadrature rule is create relative to the underlying measure ",{"attributes":{},"tag":"code","children":["opq.measure"],"type":"node"},", where ",{"attributes":{},"tag":"math","children":["n"],"type":"node"}," is the number of recurrence coefficients stored in ",{"attributes":{},"tag":"code","children":["opq.α"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["opq.β"],"type":"node"},"."],"type":"node"},{"attributes":{},"tag":"p","children":["To compute the squared norms"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\| \\phi_k \\|^2 = \\langle \\phi_k, \\phi_k  \\rangle\n= \\int \\phi_k(t) \\phi_k(t) w(t) \\mathrm{d} t"],"type":"node"},{"attributes":{},"tag":"p","children":["of the basis we call ",{"attributes":{},"tag":"code","children":["computeSP2()"],"type":"node"}],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["normsq = computeSP2(opq)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["For the general case"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["\\langle \\phi_{i_1} \\phi_{i_2} \\cdots \\phi_{i_{m-1}}, \\phi_{i_m} \\rangle\n= \\int \\phi_{i_1}(t) \\phi_{i_2}(t) \\cdots \\phi_{i_{m-1}}(t) \\phi_{i_m}(t) w(t) \\mathrm{d} t,"],"type":"node"},{"attributes":{},"tag":"p","children":["there exists a type ",{"attributes":{},"tag":"code","children":["Tensor"],"type":"node"}," that requires only two arguments: the ",{"attributes":{},"tag":"em","children":["dimension"],"type":"node"}," ",{"attributes":{},"tag":"math","children":["m \\geq 1"],"type":"node"},", and an ",{"attributes":{},"tag":"code","children":["AbstractOrthoPoly"],"type":"node"}],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["m = 3\nt = Tensor(3,opq)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["To get the desired entries, ",{"attributes":{},"tag":"code","children":["Tensor"],"type":"node"}," comes with a ",{"attributes":{},"tag":"code","children":["get()"],"type":"node"}," function that is called for some index ",{"attributes":{},"tag":"math","children":["a \\in \\mathbb{N}_0^m"],"type":"node"}," that has the entries ",{"attributes":{},"tag":"math","children":["a = [i_1, i_2, \\dots, i_m]"],"type":"node"},". For example"],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["t.get([1,2,3])\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Or using comprehension"],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["T = [ t.get([i1,i2,i3]) for i1=0:dim(opq)-1, i2=0:dim(opq)-1, i3=0:dim(opq)-1]\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Notice that we can cross-check the results."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["using LinearAlgebra\nnormsq == diag(T[:,:,1]) == diag(T[:,1,:]) == diag(T[1,:,:])\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Also, ",{"attributes":{},"tag":"code","children":["normsq"],"type":"node"}," can be computed analogously in ",{"attributes":{},"tag":"code","children":["Tensor"],"type":"node"}," format"],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["t2 = Tensor(2, opq)\nnormsq == [ t2.get([i, i]) for i in 0:dim(opq)-1]\n"],"type":"node"},{"attributes":{},"tag":"h3","children":["Arbitrary Weights"],"type":"node"},{"attributes":{},"tag":"p","children":["Of course, the type ",{"attributes":{},"tag":"code","children":["OrthoPoly"],"type":"node"}," can be constructed for arbitrary weights ",{"attributes":{},"tag":"math","children":["w(t)"],"type":"node"},". In this case we have to compute the orthogonal basis and the respective quadrature rule. Let's re-work the above example by hand."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["using SpecialFunctions\nsupp = (0, 1)\nw(t) = (t^(s_α-1)*(1-t)^(s_β-1)/SpecialFunctions.beta(s_α,s_β))\nmy_meas = Measure(\"my_meas\", w, supp, false)\nmy_opq = OrthoPoly(\"my_op\", deg, my_meas; Nrec=n, addQuadrature = true)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Now we can compute the squared norms ",{"attributes":{},"tag":"math","children":["\\| \\phi_k \\|^2"],"type":"node"}],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["my_normsq = computeSP2(my_opq)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["And the tensor"],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["my_t = Tensor(m, my_opq)\nmy_T = [ my_t.get([i1,i2,i3]) for i1=0:dim(opq)-1,i2=0:dim(opq)-1,i3=0:dim(opq)-1]\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Let's compare the results:"],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["abs.(normsq-my_normsq)\n"],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["norm(T-my_T)\n"],"type":"node"},{"attributes":{"class":"note"},"tag":"admonition","children":[{"attributes":{},"tag":"admonitiontitle","children":["Note"],"type":"node"},{"attributes":{},"tag":"admonitionbody","children":[{"attributes":{},"tag":"p","children":["The possibility to create quadrature rules for arbitrary weights should be reserved to cases different from ",{"attributes":{},"tag":"em","children":["classical"],"type":"node"}," ones."],"type":"node"}],"type":"node"}],"type":"node"},{"attributes":{},"tag":"h2","children":["Multivariate Polynomials"],"type":"node"},{"attributes":{},"tag":"p","children":["For multivariate polynomials the syntax for ",{"attributes":{},"tag":"code","children":["Tensor"],"type":"node"}," is very much alike, except that we are dealing with the type ",{"attributes":{},"tag":"code","children":["MultiOrthoPoly"],"type":"node"}," now."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["mop = MultiOrthoPoly([opq, my_opq], deg)\n"],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["mt2 = Tensor(2,mop)\nmt3 = Tensor(3,mop)\nmT2 = [ mt2.get([i,i]) for i=0:dim(mop)-1 ]\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Notice that ",{"attributes":{},"tag":"code","children":["mT2"],"type":"node"}," carries the elements of the 2-dimensional tensors for the univariate bases ",{"attributes":{},"tag":"code","children":["opq"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["my_opq"],"type":"node"},". The encoding is given by the multi-index ",{"attributes":{},"tag":"code","children":["mop.ind"],"type":"node"}],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["mop.ind\n"],"type":"node"},{"attributes":{},"tag":"p","children":["To cross-check the results we can distribute the multi-index back to its univariate indices with the help of ",{"attributes":{},"tag":"code","children":["findUnivariateIndices"],"type":"node"},"."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["ind_opq = findUnivariateIndices(1,mop.ind)\nind_my_opq = findUnivariateIndices(2,mop.ind)\n"],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["mT2[ind_opq] - normsq\n"],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["mT2[ind_my_opq] - my_normsq\n"],"type":"node"}],"type":"node"}],"type":"node"}