{"attributes":{"backlinks":[],"path":"/Users/lorenz/.julia/packages/PolyChaos/THVqe/docs/src/chi_squared_k_greater1.md","title":"Chi-squared Distribution (k>1)"},"tag":"document","children":[{"attributes":{},"tag":"md","children":[{"attributes":{"lang":"@setup mysetup"},"tag":"codeblock","children":["k = 12\nusing PolyChaos\ndegree, Nrec = 2, 20\nopq = GaussOrthoPoly(degree; Nrec=Nrec, addQuadrature = true);\nmop = MultiOrthoPoly([opq for i in 1:k], degree)\nL = dim(mop)\nmu, sig = 0., 1.\nx = [ assign2multi(convert2affinePCE(mu, sig, opq),i,mop.ind) for i in 1:k ]\nt2 = Tensor(2,mop)\nt3 = Tensor(3,mop)\ny = [ sum( x[i][j1]*x[i][j2]*t3.get([j1-1,j2-1,m-1])/t2.get([m-1,m-1])  for i=1:k, j1=1:L, j2=1:L ) for m=1:L ]\nmoms_analytic(k) = [k, sqrt(2k), sqrt(8/k)]\nfunction myskew(y)\n   e3 = sum( y[i]*y[j]*y[k]*t3.get([i-1,j-1,k-1]) for i=1:L,j=1:L,k=1:L )\n   μ = y[1]\n   σ = std(y,mop)\n   (e3-3*μ*σ^2-μ^3)/(σ^3)\nend\nprint(\"Expected value:\\t\\t$(moms_analytic(k)[1]) = $(mean(y,mop))\\n\")\nprint(\"\\t\\t\\terror = $(abs(mean(y,mop)-moms_analytic(k)[1]))\\n\")\nprint(\"Standard deviation:\\t$(moms_analytic(k)[2]) = $(std(y,mop))\\n\")\nprint(\"\\t\\t\\terror = $(moms_analytic(k)[2]-std(y,mop))\\n\")\nprint(\"Skewness:\\t\\t$(moms_analytic(k)[3]) = $(myskew(y))\\n\")\nprint(\"\\t\\t\\terror = $(moms_analytic(k)[3]-myskew(y))\\n\")\nusing Plots\nNsmpl = 10000\nysmpl = samplePCE(Nsmpl, y, mop)\nhistogram(ysmpl;normalize=true, xlabel=\"t\",ylabel=\"rho(t)\")\nimport SpecialFunctions: gamma\nρ(t) = 1/(2^(0.5*k)*gamma(0.5*k))*t^(0.5*k-1)*exp(-0.5*t)\nt = range(0.1; stop=maximum(ysmpl), length=100)\nplot!(t,ρ.(t),w=4)\n"],"type":"node"},{"attributes":{},"tag":"h1","children":["Chi-squared Distribution (",{"attributes":{},"tag":"math","children":["k>1"],"type":"node"},")"],"type":"node"},{"attributes":{},"tag":"h2","children":["Theory"],"type":"node"},{"attributes":{},"tag":"p","children":["Given ",{"attributes":{},"tag":"math","children":["k"],"type":"node"}," standard random variables ",{"attributes":{},"tag":"math","children":["X_i \\sim \\mathcal{N}(0,1)"],"type":"node"}," for ",{"attributes":{},"tag":"math","children":["i=1,\\dots,k"],"type":"node"}," we would like to find the random variable ",{"attributes":{},"tag":"math","children":["Y = \\sum_{i=1}^k X_i^2"],"type":"node"},". The analytic solution is known: ",{"attributes":{},"tag":"math","children":["Y"],"type":"node"}," follows a chi-squared distribution with ",{"attributes":{},"tag":"math","children":["k"],"type":"node"}," degrees of freedom."],"type":"node"},{"attributes":{},"tag":"p","children":["Using polynomial chaos expansion (PCE), the problem can be solved using Galerkin projection. Let ",{"attributes":{},"tag":"math","children":["\\{\\phi_k \\}_{k=0}^{n}"],"type":"node"}," be the monic orthogonal basis relative to the probability density of ",{"attributes":{},"tag":"math","children":["X = [X_1, \\dots, X_k]"],"type":"node"},", namely"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["f_X(x) =  \\prod_{i=1}^k \\frac{1}{\\sqrt{2 \\pi}} \\, \\exp \\left( - \\frac{x_i^2}{2} \\right)."],"type":"node"},{"attributes":{},"tag":"p","children":["Then, the PCE of ",{"attributes":{},"tag":"math","children":["X_i"],"type":"node"}," is given by"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["X_i = \\sum_{k=0}^n x_{i,k} \\phi_k,"],"type":"node"},{"attributes":{},"tag":"p","children":["with"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["x_{i,0} = 0, \\quad x_{i,i+1} = 1, \\quad x_{i,l} = 0 \\quad \\forall l \\in \\{1,\\dots,n\\} \\setminus \\{i+1\\}."],"type":"node"},{"attributes":{},"tag":"p","children":["To find the PCE coefficients ",{"attributes":{},"tag":"math","children":["y_k"],"type":"node"}," for ",{"attributes":{},"tag":"math","children":["Y = \\sum_{k=}^n y_k \\phi_k"],"type":"node"},", we apply Galerkin projection, which leads to"],"type":"node"},{"attributes":{},"tag":"mathblock","children":["y_m \\langle \\phi_m, \\phi_m \\rangle = \\sum_{i=1}^k \\sum_{j_1=0}^n \\sum_{j_2=0}^n x_{i,j_1} x_{i,j_2} \\langle \\phi_{j_1} \\phi_{j_2}, \\phi_m \\rangle \\quad \\forall m = 0, \\dots, n."],"type":"node"},{"attributes":{},"tag":"p","children":["Hence, knowing the scalars ",{"attributes":{},"tag":"math","children":["\\langle \\phi_m, \\phi_m \\rangle"],"type":"node"},", and ",{"attributes":{},"tag":"math","children":["\\langle \\phi_{j_1} \\phi_{j_2}, \\phi_m \\rangle"],"type":"node"},", the PCE coefficients ",{"attributes":{},"tag":"math","children":["y_k"],"type":"node"}," can be obtained immediately. From the PCE coefficients we can get the moments and compare them to the closed-form expressions."],"type":"node"},{"attributes":{},"tag":"p","children":[{"attributes":{},"tag":"strong","children":["Notice:"],"type":"node"}," A maximum degree of 2 suffices to get the ",{"attributes":{},"tag":"em","children":["exact"],"type":"node"}," solution with PCE. In other words, increasing the maximum degree to values greater than 2 introduces nothing but computational overhead (and numerical errors, possibly)."],"type":"node"},{"attributes":{},"tag":"h2","children":["Practice"],"type":"node"},{"attributes":{},"tag":"p","children":["First, we create a orthogonal basis relative to ",{"attributes":{},"tag":"math","children":["f_X(x)"],"type":"node"}," of degree at most ",{"attributes":{},"tag":"math","children":["d=2"],"type":"node"}," (",{"attributes":{},"tag":"code","children":["degree"],"type":"node"}," below)."],"type":"node"},{"attributes":{},"tag":"p","children":["Notice that we consider a total of ",{"attributes":{},"tag":"code","children":["Nrec"],"type":"node"}," recursion coefficients, and that we also add a quadrature rule by setting ",{"attributes":{},"tag":"code","children":["addQuadrature = true"],"type":"node"},"."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["k = 12\nusing PolyChaos\ndegree, Nrec = 2, 20\nopq = GaussOrthoPoly(degree; Nrec=Nrec, addQuadrature = true);\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Now let's define a multivariate basis"],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["mop = MultiOrthoPoly([opq for i in 1:k], degree)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Next, we define the PCE for all ",{"attributes":{},"tag":"math","children":["X_i"],"type":"node"}," with ",{"attributes":{},"tag":"math","children":["i = 1, \\dots, k"],"type":"node"},"."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["L = dim(mop)\nmu, sig = 0., 1.\nx = [ assign2multi(convert2affinePCE(mu, sig, opq), i, mop.ind) for i in 1:k ]\n"],"type":"node"},{"attributes":{},"tag":"p","children":["With the orthogonal basis and the quadrature at hand, we can compute the tensors ",{"attributes":{},"tag":"code","children":["t2"],"type":"node"}," and ",{"attributes":{},"tag":"code","children":["t3"],"type":"node"}," that store the entries ",{"attributes":{},"tag":"math","children":["\\langle \\phi_m, \\phi_m \\rangle"],"type":"node"},", and ",{"attributes":{},"tag":"math","children":["\\langle \\phi_{j_1} \\phi_{j_2}, \\phi_m \\rangle"],"type":"node"},", respectively."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["t2 = Tensor(2,mop)\nt3 = Tensor(3,mop)\n"],"type":"node"},{"attributes":{},"tag":"p","children":["With the tensors at hand, we can compute the Galerkin projection."],"type":"node"},{"attributes":{},"tag":"p","children":["Notice: there are more efficient ways to do this, but let's keep it simple."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["y = [ sum( x[i][j1]*x[i][j2]*t3.get([j1-1,j2-1,m-1])/t2.get([m-1,m-1])  for i=1:k, j1=1:L, j2=1:L ) for m=1:L ]\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Let's compare the moments via PCE to the closed-form expressions."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["moms_analytic(k) = [k, sqrt(2k), sqrt(8/k)]\nfunction myskew(y)\n   e3 = sum( y[i]*y[j]*y[k]*t3.get([i-1,j-1,k-1]) for i=1:L,j=1:L,k=1:L )\n   μ = y[1]\n   σ = std(y,mop)\n   (e3-3*μ*σ^2-μ^3)/(σ^3)\nend\n\nprint(\"Expected value:\\t\\t$(moms_analytic(k)[1]) = $(mean(y,mop))\\n\")\nprint(\"\\t\\t\\terror = $(abs(mean(y,mop)-moms_analytic(k)[1]))\\n\")\nprint(\"Standard deviation:\\t$(moms_analytic(k)[2]) = $(std(y,mop))\\n\")\nprint(\"\\t\\t\\terror = $(moms_analytic(k)[2]-std(y,mop))\\n\")\nprint(\"Skewness:\\t\\t$(moms_analytic(k)[3]) = $(myskew(y))\\n\")\nprint(\"\\t\\t\\terror = $(moms_analytic(k)[3]-myskew(y))\\n\")\n\n"],"type":"node"},{"attributes":{},"tag":"p","children":["Let's plot the probability density function to compare results. We first draw samples from the measure with the help of ",{"attributes":{},"tag":"code","children":["sampleMeasure()"],"type":"node"},", and then evaluate the basis at these samples and multiply times the PCE coefficients. The latter stop is done using ",{"attributes":{},"tag":"code","children":["evaluatePCE()"],"type":"node"},". Both steps are combined in the function ",{"attributes":{},"tag":"code","children":["samplePCE()"],"type":"node"},". Finally, we compare the result agains the analytical PDF ",{"attributes":{},"tag":"math","children":["\\rho(t) = \\frac{t^{t/2-1}\\mathrm{e}^{-t/2}}{2^{k/2} \\, \\Gamma(k/2)}"],"type":"node"}," of the chi-squared distribution with one degree of freedom."],"type":"node"},{"attributes":{"lang":"@example mysetup"},"tag":"codeblock","children":["using Plots\nNsmpl = 10000\n# long way: ξ = sampleMeasure(Nsmpl,mop), ysmpl = evaluatePCE(y,ξ,mop)\nysmpl = samplePCE(Nsmpl, y, mop)\nhistogram(ysmpl;normalize=true, xlabel=\"t\",ylabel=\"rho(t)\")\n\nimport SpecialFunctions: gamma\nρ(t) = 1/(2^(0.5*k)*gamma(0.5*k))*t^(0.5*k-1)*exp(-0.5*t)\nt = range(0.1; stop=maximum(ysmpl), length=100)\nplot!(t, ρ.(t), w=4)\n"],"type":"node"}],"type":"node"}],"type":"node"}